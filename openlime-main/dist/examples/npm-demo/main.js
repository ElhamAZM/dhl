/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Annotation.js":
/*!***************************!*\
  !*** ./src/Annotation.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Annotation\": () => (/* binding */ Annotation)\n/* harmony export */ });\n/* harmony import */ var _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox.js */ \"./src/BoundingBox.js\");\n\n\n/** \n * An annotation is a decoration (text, graphics element, glyph) to be drawn in an overlay mode on the canvas.\n * Its purpose is to provide additional information useful for the interpretation of the underlying drawings. \n * This calls defines the content of an annotation which is represented by its unique identifier and additional \n * information (such as description, annotation category or class, drawing style, labels, etc.).\n */\nclass Annotation {\n\t/**\n\t * Instantiates an **Annotation** object. An object literal with Annotation `options` can be specified.\n\t * Note that the developer is free to define additional elements characterizing a custom annotation by adding new options to the constructor.\n\t * @param {Object} [options] An object literal with Annotation options (freely adjustable).\n\t * @param {string} options.label A string containing an annotation label.\n\t * @param {string} option.description A HTML text containg a comprehensive description of the annotation.\n\t * @param {string} option.class A class or category to cluster annotations.\n\t * @param {Object} option.state=null An object literal with state variables.\n\t */\n\tconstructor(options) {\n\t\tObject.assign(\n\t\t\tthis, \n\t\t\t{\n\t\t\t\tid: Annotation.UUID(),\n\t\t\t\tcode: null,\n\t\t\t\tlabel: null,\n\t\t\t\tdescription: null,\n\t\t\t\tclass: null,\n\t\t\t\ttarget: null,\n\t\t\t\tsvg: null,\n\t\t\t\timage: null,\n\t\t\t\tregion: null,\n\t\t\t\tdata: {},\n\t\t\t\tstyle: null,\n\t\t\t\tbbox: null,\n\t\t\t\tvisible: true,\n\t\t\t\tstate: null,\n\t\t\t\tready: false, //already: converted to svg\n\t\t\t\tneedsUpdate: true,\n\t\t\t\tediting: false,\n\t\t\t}, \n\t\t\toptions);\n\t\t\t//TODO label as null is problematic, sort this issue.\n\t\t\tif(!this.label) this.label = ''; \n\t\t\tthis.elements = []; //assign options is not recursive!!!\n\t}\n\n\t/** @ignore */\n\tstatic UUID() {\n\t\treturn 'axxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\t\tvar r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t\t\treturn v.toString(16);\n\t\t});\n\t}\n\n\t/**\n\t * Gets the bounding box of the annotation.\n\t * Note that the coordinates for annotations are always relative to the top left corner of the canvas.\n\t * @returns {BoundingBox} The bounding box\n\t */\n\tgetBBoxFromElements() {\n\t\tlet box = null;\n\t\tif(!this.elements.length) {\n\t\t\tif (this.region == null) {\n\t\t\t\tbox = new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\n\t\t\t} else {\n\t\t\t\tconst r = this.region;\n\t\t\t\tbox = new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({xLow: r.x, yLow: r.y, xHigh: r.x+r.w, yHigh: r.y+r.h});\n\t\t\t}\n\t\t} else {\n\t\t\tlet { x, y, width, height } = this.elements[0].getBBox();\n\t\t\tfor(let shape of this.elements) {\n\t\t\t\t\tconst { sx, sy, swidth, sheight } = shape.getBBox();\n\t\t\t\t\tx = Math.min(x, sx);\n\t\t\t\t\ty = Math.min(x, sy);\n\t\t\t\t\twidth = Math.max(width + x, sx + swidth) - x; \n\t\t\t\t\theight = Math.max(height + y, sy + sheight) - y; \n\t\t\t}\n\t\t\tbox = new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({xLow: x, yLow: y, xHigh: x+width, yHigh: y+width});\n\t\t}\n\t\treturn box;\n\t}\n\n\t/////////////////////////////////\n\t/* The class also provides functions for importing and exporting from and to files in JSON format. */\n\t/*\n\t * Copies an entry of a JSON file into an **Annotation** object.\n\t * @param {string} entry A JSON string representing an annotation.\n\t * @returns {Annotation} The annotation.\n\t */\n\t/** @ignore */\n\tstatic fromJsonLd(entry) {\n\t\tif(entry.type != 'Annotation')\n\t\t\tthrow \"Not a jsonld annotation.\";\n\t\tlet options = {id: entry.id};\n\n\t\tlet rename = { 'identifying': 'code', 'identifying': 'label', 'describing': 'description', 'classifying':'class' };\n\t\tfor(let item of entry.body) {\n\t\t\tlet field = rename[item.purpose];\n\t\t\tif(field)\n\t\t\t\toptions[field] = item.value;\n\t\t}\n\t\tlet selector = entry.target && entry.target.selector;\n\t\tif(selector) {\n\t\t\tswitch(selector.type) {\n\t\t\tcase 'SvgSelector':\n\t\t\t\toptions.svg = selector.value;\n\t\t\t\toptions.elements = [];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow \"Unsupported selector: \" + selector.type;\n\t\t\t}\n\t\t}\n\t\treturn new Annotation(options);\n\t}\n\t/*\n\t * Exports an Annotation to a JSON entry\n\t */\n\t/** @ignore */\n\ttoJsonLd() {\n\t\tlet body = [];\n\t\tif(this.code !== null)\n\t\t\tbody.push( { type: 'TextualBody', value: this.code, purpose: 'indentifying' });\n\t\tif(this.class !== null)\n\t\t\tbody.push( { type: 'TextualBody', value: this.class, purpose: 'classifying' });\n\t\tif(this.description !== null)\n\t\t\tbody.push( { type: 'TextualBody', value: this.description, purpose: 'describing' });\n\n\t\tlet obj = {\n\t\t\t\"@context\": \"http://www.w3.org/ns/anno.jsonld\",\n\t\t\tid: this.id,\n\t\t\ttype: \"Annotation\",\n\t\t\tbody: body,\n\t\t\ttarget: { selector: {} }\n\t\t}\n\t\tif(this.target)\n\t\t\ttarget.selector.source = this.target;\n\n\n\t\tif(this.element) {\n\t\t\tvar s = new XMLSerializer();\n\t\t\tobj.target.selector.type = 'SvgSelector';\n\t\t\tobj.target.selector.value = s.serializeToString(this.element);\n\t\t}\n\t}\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQW5ub3RhdGlvbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdEQUFXO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLGNBQWMsd0RBQVcsRUFBRSxxREFBcUQ7QUFDaEY7QUFDQSxJQUFJO0FBQ0osU0FBUyxzQkFBc0I7QUFDL0I7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBVyxFQUFFLGlEQUFpRDtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnRUFBZ0U7QUFDaEY7QUFDQSxnQkFBZ0IsZ0VBQWdFO0FBQ2hGO0FBQ0EsZ0JBQWdCLHFFQUFxRTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvQW5ub3RhdGlvbi5qcz9mOThmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvdW5kaW5nQm94IH0gZnJvbSAnLi9Cb3VuZGluZ0JveC5qcydcblxuLyoqIFxuICogQW4gYW5ub3RhdGlvbiBpcyBhIGRlY29yYXRpb24gKHRleHQsIGdyYXBoaWNzIGVsZW1lbnQsIGdseXBoKSB0byBiZSBkcmF3biBpbiBhbiBvdmVybGF5IG1vZGUgb24gdGhlIGNhbnZhcy5cbiAqIEl0cyBwdXJwb3NlIGlzIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB1c2VmdWwgZm9yIHRoZSBpbnRlcnByZXRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBkcmF3aW5ncy4gXG4gKiBUaGlzIGNhbGxzIGRlZmluZXMgdGhlIGNvbnRlbnQgb2YgYW4gYW5ub3RhdGlvbiB3aGljaCBpcyByZXByZXNlbnRlZCBieSBpdHMgdW5pcXVlIGlkZW50aWZpZXIgYW5kIGFkZGl0aW9uYWwgXG4gKiBpbmZvcm1hdGlvbiAoc3VjaCBhcyBkZXNjcmlwdGlvbiwgYW5ub3RhdGlvbiBjYXRlZ29yeSBvciBjbGFzcywgZHJhd2luZyBzdHlsZSwgbGFiZWxzLCBldGMuKS5cbiAqL1xuY2xhc3MgQW5ub3RhdGlvbiB7XG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYW4gKipBbm5vdGF0aW9uKiogb2JqZWN0LiBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIEFubm90YXRpb24gYG9wdGlvbnNgIGNhbiBiZSBzcGVjaWZpZWQuXG5cdCAqIE5vdGUgdGhhdCB0aGUgZGV2ZWxvcGVyIGlzIGZyZWUgdG8gZGVmaW5lIGFkZGl0aW9uYWwgZWxlbWVudHMgY2hhcmFjdGVyaXppbmcgYSBjdXN0b20gYW5ub3RhdGlvbiBieSBhZGRpbmcgbmV3IG9wdGlvbnMgdG8gdGhlIGNvbnN0cnVjdG9yLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggQW5ub3RhdGlvbiBvcHRpb25zIChmcmVlbHkgYWRqdXN0YWJsZSkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxhYmVsIEEgc3RyaW5nIGNvbnRhaW5pbmcgYW4gYW5ub3RhdGlvbiBsYWJlbC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbi5kZXNjcmlwdGlvbiBBIEhUTUwgdGV4dCBjb250YWluZyBhIGNvbXByZWhlbnNpdmUgZGVzY3JpcHRpb24gb2YgdGhlIGFubm90YXRpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb24uY2xhc3MgQSBjbGFzcyBvciBjYXRlZ29yeSB0byBjbHVzdGVyIGFubm90YXRpb25zLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uLnN0YXRlPW51bGwgQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBzdGF0ZSB2YXJpYWJsZXMuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmFzc2lnbihcblx0XHRcdHRoaXMsIFxuXHRcdFx0e1xuXHRcdFx0XHRpZDogQW5ub3RhdGlvbi5VVUlEKCksXG5cdFx0XHRcdGNvZGU6IG51bGwsXG5cdFx0XHRcdGxhYmVsOiBudWxsLFxuXHRcdFx0XHRkZXNjcmlwdGlvbjogbnVsbCxcblx0XHRcdFx0Y2xhc3M6IG51bGwsXG5cdFx0XHRcdHRhcmdldDogbnVsbCxcblx0XHRcdFx0c3ZnOiBudWxsLFxuXHRcdFx0XHRpbWFnZTogbnVsbCxcblx0XHRcdFx0cmVnaW9uOiBudWxsLFxuXHRcdFx0XHRkYXRhOiB7fSxcblx0XHRcdFx0c3R5bGU6IG51bGwsXG5cdFx0XHRcdGJib3g6IG51bGwsXG5cdFx0XHRcdHZpc2libGU6IHRydWUsXG5cdFx0XHRcdHN0YXRlOiBudWxsLFxuXHRcdFx0XHRyZWFkeTogZmFsc2UsIC8vYWxyZWFkeTogY29udmVydGVkIHRvIHN2Z1xuXHRcdFx0XHRuZWVkc1VwZGF0ZTogdHJ1ZSxcblx0XHRcdFx0ZWRpdGluZzogZmFsc2UsXG5cdFx0XHR9LCBcblx0XHRcdG9wdGlvbnMpO1xuXHRcdFx0Ly9UT0RPIGxhYmVsIGFzIG51bGwgaXMgcHJvYmxlbWF0aWMsIHNvcnQgdGhpcyBpc3N1ZS5cblx0XHRcdGlmKCF0aGlzLmxhYmVsKSB0aGlzLmxhYmVsID0gJyc7IFxuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFtdOyAvL2Fzc2lnbiBvcHRpb25zIGlzIG5vdCByZWN1cnNpdmUhISFcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHN0YXRpYyBVVUlEKCkge1xuXHRcdHJldHVybiAnYXh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcblx0XHRcdHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcblx0XHRcdHJldHVybiB2LnRvU3RyaW5nKDE2KTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGFubm90YXRpb24uXG5cdCAqIE5vdGUgdGhhdCB0aGUgY29vcmRpbmF0ZXMgZm9yIGFubm90YXRpb25zIGFyZSBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzLlxuXHQgKiBAcmV0dXJucyB7Qm91bmRpbmdCb3h9IFRoZSBib3VuZGluZyBib3hcblx0ICovXG5cdGdldEJCb3hGcm9tRWxlbWVudHMoKSB7XG5cdFx0bGV0IGJveCA9IG51bGw7XG5cdFx0aWYoIXRoaXMuZWxlbWVudHMubGVuZ3RoKSB7XG5cdFx0XHRpZiAodGhpcy5yZWdpb24gPT0gbnVsbCkge1xuXHRcdFx0XHRib3ggPSBuZXcgQm91bmRpbmdCb3goKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHIgPSB0aGlzLnJlZ2lvbjtcblx0XHRcdFx0Ym94ID0gbmV3IEJvdW5kaW5nQm94KHt4TG93OiByLngsIHlMb3c6IHIueSwgeEhpZ2g6IHIueCtyLncsIHlIaWdoOiByLnkrci5ofSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuZWxlbWVudHNbMF0uZ2V0QkJveCgpO1xuXHRcdFx0Zm9yKGxldCBzaGFwZSBvZiB0aGlzLmVsZW1lbnRzKSB7XG5cdFx0XHRcdFx0Y29uc3QgeyBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCB9ID0gc2hhcGUuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdHggPSBNYXRoLm1pbih4LCBzeCk7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWluKHgsIHN5KTtcblx0XHRcdFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoICsgeCwgc3ggKyBzd2lkdGgpIC0geDsgXG5cdFx0XHRcdFx0aGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0ICsgeSwgc3kgKyBzaGVpZ2h0KSAtIHk7IFxuXHRcdFx0fVxuXHRcdFx0Ym94ID0gbmV3IEJvdW5kaW5nQm94KHt4TG93OiB4LCB5TG93OiB5LCB4SGlnaDogeCt3aWR0aCwgeUhpZ2g6IHkrd2lkdGh9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJveDtcblx0fVxuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvKiBUaGUgY2xhc3MgYWxzbyBwcm92aWRlcyBmdW5jdGlvbnMgZm9yIGltcG9ydGluZyBhbmQgZXhwb3J0aW5nIGZyb20gYW5kIHRvIGZpbGVzIGluIEpTT04gZm9ybWF0LiAqL1xuXHQvKlxuXHQgKiBDb3BpZXMgYW4gZW50cnkgb2YgYSBKU09OIGZpbGUgaW50byBhbiAqKkFubm90YXRpb24qKiBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeSBBIEpTT04gc3RyaW5nIHJlcHJlc2VudGluZyBhbiBhbm5vdGF0aW9uLlxuXHQgKiBAcmV0dXJucyB7QW5ub3RhdGlvbn0gVGhlIGFubm90YXRpb24uXG5cdCAqL1xuXHQvKiogQGlnbm9yZSAqL1xuXHRzdGF0aWMgZnJvbUpzb25MZChlbnRyeSkge1xuXHRcdGlmKGVudHJ5LnR5cGUgIT0gJ0Fubm90YXRpb24nKVxuXHRcdFx0dGhyb3cgXCJOb3QgYSBqc29ubGQgYW5ub3RhdGlvbi5cIjtcblx0XHRsZXQgb3B0aW9ucyA9IHtpZDogZW50cnkuaWR9O1xuXG5cdFx0bGV0IHJlbmFtZSA9IHsgJ2lkZW50aWZ5aW5nJzogJ2NvZGUnLCAnaWRlbnRpZnlpbmcnOiAnbGFiZWwnLCAnZGVzY3JpYmluZyc6ICdkZXNjcmlwdGlvbicsICdjbGFzc2lmeWluZyc6J2NsYXNzJyB9O1xuXHRcdGZvcihsZXQgaXRlbSBvZiBlbnRyeS5ib2R5KSB7XG5cdFx0XHRsZXQgZmllbGQgPSByZW5hbWVbaXRlbS5wdXJwb3NlXTtcblx0XHRcdGlmKGZpZWxkKVxuXHRcdFx0XHRvcHRpb25zW2ZpZWxkXSA9IGl0ZW0udmFsdWU7XG5cdFx0fVxuXHRcdGxldCBzZWxlY3RvciA9IGVudHJ5LnRhcmdldCAmJiBlbnRyeS50YXJnZXQuc2VsZWN0b3I7XG5cdFx0aWYoc2VsZWN0b3IpIHtcblx0XHRcdHN3aXRjaChzZWxlY3Rvci50eXBlKSB7XG5cdFx0XHRjYXNlICdTdmdTZWxlY3Rvcic6XG5cdFx0XHRcdG9wdGlvbnMuc3ZnID0gc2VsZWN0b3IudmFsdWU7XG5cdFx0XHRcdG9wdGlvbnMuZWxlbWVudHMgPSBbXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBcIlVuc3VwcG9ydGVkIHNlbGVjdG9yOiBcIiArIHNlbGVjdG9yLnR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgQW5ub3RhdGlvbihvcHRpb25zKTtcblx0fVxuXHQvKlxuXHQgKiBFeHBvcnRzIGFuIEFubm90YXRpb24gdG8gYSBKU09OIGVudHJ5XG5cdCAqL1xuXHQvKiogQGlnbm9yZSAqL1xuXHR0b0pzb25MZCgpIHtcblx0XHRsZXQgYm9keSA9IFtdO1xuXHRcdGlmKHRoaXMuY29kZSAhPT0gbnVsbClcblx0XHRcdGJvZHkucHVzaCggeyB0eXBlOiAnVGV4dHVhbEJvZHknLCB2YWx1ZTogdGhpcy5jb2RlLCBwdXJwb3NlOiAnaW5kZW50aWZ5aW5nJyB9KTtcblx0XHRpZih0aGlzLmNsYXNzICE9PSBudWxsKVxuXHRcdFx0Ym9keS5wdXNoKCB7IHR5cGU6ICdUZXh0dWFsQm9keScsIHZhbHVlOiB0aGlzLmNsYXNzLCBwdXJwb3NlOiAnY2xhc3NpZnlpbmcnIH0pO1xuXHRcdGlmKHRoaXMuZGVzY3JpcHRpb24gIT09IG51bGwpXG5cdFx0XHRib2R5LnB1c2goIHsgdHlwZTogJ1RleHR1YWxCb2R5JywgdmFsdWU6IHRoaXMuZGVzY3JpcHRpb24sIHB1cnBvc2U6ICdkZXNjcmliaW5nJyB9KTtcblxuXHRcdGxldCBvYmogPSB7XG5cdFx0XHRcIkBjb250ZXh0XCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvYW5uby5qc29ubGRcIixcblx0XHRcdGlkOiB0aGlzLmlkLFxuXHRcdFx0dHlwZTogXCJBbm5vdGF0aW9uXCIsXG5cdFx0XHRib2R5OiBib2R5LFxuXHRcdFx0dGFyZ2V0OiB7IHNlbGVjdG9yOiB7fSB9XG5cdFx0fVxuXHRcdGlmKHRoaXMudGFyZ2V0KVxuXHRcdFx0dGFyZ2V0LnNlbGVjdG9yLnNvdXJjZSA9IHRoaXMudGFyZ2V0O1xuXG5cblx0XHRpZih0aGlzLmVsZW1lbnQpIHtcblx0XHRcdHZhciBzID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcblx0XHRcdG9iai50YXJnZXQuc2VsZWN0b3IudHlwZSA9ICdTdmdTZWxlY3Rvcic7XG5cdFx0XHRvYmoudGFyZ2V0LnNlbGVjdG9yLnZhbHVlID0gcy5zZXJpYWxpemVUb1N0cmluZyh0aGlzLmVsZW1lbnQpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgeyBBbm5vdGF0aW9uIH0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Annotation.js\n");

/***/ }),

/***/ "./src/BoundingBox.js":
/*!****************************!*\
  !*** ./src/BoundingBox.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BoundingBox\": () => (/* binding */ BoundingBox)\n/* harmony export */ });\n/**\n * The bounding box is a rectangular box that is wrapped as tightly as possible around a geometric element. It is oriented parallel to the axes.\n * It is defined by two opposite vertices. The class It includes a comprehensive set of functions for various processing tasks related to bounding boxes.\n * \n */\nclass BoundingBox {\n    /**\n     * Instantiates a **BoundingBox** object.\n     * @param {Object} [options] An object literal defining the bounding box.\n     * @param {number} xLow=1e20 The x coordinate of the low corner a rectangle.\n     * @param {number} yLow=1e20 The y coordinate of the low corner a rectangle.\n     * @param {number} xHigh=-1e20 The x coordinate of the high corner a rectangle.\n     * @param {number} xHigh=-1e20 The y coordinate of the high corner a rectangle.\n     */\n    constructor(options) {\n        Object.assign(this, {\n            xLow: 1e20,\n            yLow: 1e20,\n            xHigh: -1e20, \n            yHigh: -1e20 });\n        Object.assign(this, options);\n    }\n\n    /**\n     * Defines a bonding box from an array of four elements.\n     * @param {Array<number>} x The array of four elements with the two corners ([xLow, yLow, xHigh, yHigh]).\n     */\n    fromArray(x) {\n        this.xLow = x[0];\n        this.yLow = x[1]; \n        this.xHigh = x[2];\n        this.yHigh  = x[3];\n    }\n    \n    /**\n     * Empties a bounding box.\n     */\n    toEmpty() {\n        this.xLow = 1e20;\n        this.yLow = 1e20; \n        this.xHigh = -1e20;\n        this.yHigh  = -1e20;\n    }\n\n    /**\n     * Tests weather the bounding box is empty.\n     * @returns {bool} The test result.\n     */\n    isEmpty() {\n        return this.xLow > this.xHigh || this.yLow > this.yHigh;\n    }\n\n    /**\n     * Returns an array of four elements containg the low and high corners.\n     * @returns {Array<number>} The array of corners.\n     */\n    toArray() {\n        return [this.xLow, this.yLow, this.xHigh, this. yHigh];\n    }\n\n    /**\n     * Returns a text string with the corner coordinates separated by a space.\n     * @returns {string} The string of corners.\n     */\n    toString() {\n        return this.xLow.toString() + \" \" + this.yLow.toString() + \" \" + this.xHigh.toString() + \" \" + this.yHigh.toString();\n    }\n\n    /**\n     * Merges a `box` to `this` BoundingBox.\n     * @param {BoundingBox} box The bounding box to be merged. \n     */\n    mergeBox(box) {\n\t\tif (box == null)\n            return;\n\n        if(this.isEmpty())\n            Object.assign(this, box);\n        else {\n            this.xLow = Math.min(this.xLow,  box.xLow);\n            this.yLow = Math.min(this.yLow,  box.yLow);\n            this.xHigh = Math.max(this.xHigh, box.xHigh);\n            this.yHigh = Math.max(this.yHigh, box.yHigh);\n        }\n    }\n\n    /**\n     * Merges a point `p`{x, y} to `this` BoundingBox.\n     * @param {{x, y}} p The point to be merged. \n     */\n    mergePoint(p) {\n        this.xLow = Math.min(this.xLow, p.x);\n        this.yLow = Math.min(this.yLow, p.y);\n        this.xHigh = Math.max(this.xHigh, p.x);\n        this.yHigh = Math.max(this.yHigh, p.y);\n    }\n    \n    /**\n     * Translates the bounding box by a displacement vector (dx, dy).\n     * @param {number} dx Displacement along the x-axis.\n     * @param {number} dy Displacement along the y-axis.\n     */\n    shift(dx, dy) {\n        this.xLow += dx;\n        this.yLow += dy;\n        this.xHigh += dx;\n        this.yHigh += dy;\n    }\n\n    /**\n     * Divides by `side` and truncates the corner coordinates.\n     * @param {*} side The value to divide by.\n     */\n    quantize(side) {\n        this.xLow =  Math.floor(this.xLow/side);\n        this.yLow =  Math.floor(this.yLow/side);\n        this.xHigh = Math.floor((this.xHigh-1)/side) + 1;\n        this.yHigh = Math.floor((this.yHigh-1)/side) + 1;\n    }\n\n    /**\n     * Returns the bounding box width.\n     * @returns {number} The width value.\n     */\n    width() {\n        return this.xHigh - this.xLow;\n    }\n    \n    /**\n     * Returns the bounding box height.\n     * @returns {number} The height value.\n     */\n    height() {\n        return this.yHigh - this.yLow;\n    }\n\n    /**\n     * Returns the bounding box center.\n     * @returns {number} The center value.\n     */\n    center() {\n        return [(this.xLow+this.xHigh)/2, (this.yLow+this.yHigh)/2];\n    }\n\n    /**\n     * Returns the i-th corner.\n     * @param {number} i The index of the corner. \n     * @returns {Array<number>} A [x, y] pair.\n     */\n    corner(i) {\n        // To avoid the switch\n        let v = this.toArray();\n        return {x: v[0 + (i&0x1)<<1], y: v[1 + (i&0x2)] };\n    }\n\n    intersects(box) {\n        return xLow <= box.xHigh && xHigh >= box.xLow && yLow <= box.yHigh && yHigh >= box.yLow;\n    }\n    /**\n     * Prints out the bounding box corners in the console.\n     */\n    print() {\n        console.log(\"BOX=\" + this.xLow.toFixed(2) + \", \" + this.yLow.toFixed(2) + \", \" + this.xHigh.toFixed(2) + \", \" + this.yHigh.toFixed(2))\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQm91bmRpbmdCb3guanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9Cb3VuZGluZ0JveC5qcz9hMjk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIGJvdW5kaW5nIGJveCBpcyBhIHJlY3Rhbmd1bGFyIGJveCB0aGF0IGlzIHdyYXBwZWQgYXMgdGlnaHRseSBhcyBwb3NzaWJsZSBhcm91bmQgYSBnZW9tZXRyaWMgZWxlbWVudC4gSXQgaXMgb3JpZW50ZWQgcGFyYWxsZWwgdG8gdGhlIGF4ZXMuXG4gKiBJdCBpcyBkZWZpbmVkIGJ5IHR3byBvcHBvc2l0ZSB2ZXJ0aWNlcy4gVGhlIGNsYXNzIEl0IGluY2x1ZGVzIGEgY29tcHJlaGVuc2l2ZSBzZXQgb2YgZnVuY3Rpb25zIGZvciB2YXJpb3VzIHByb2Nlc3NpbmcgdGFza3MgcmVsYXRlZCB0byBib3VuZGluZyBib3hlcy5cbiAqIFxuICovXG5jbGFzcyBCb3VuZGluZ0JveCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGEgKipCb3VuZGluZ0JveCoqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBsaXRlcmFsIGRlZmluaW5nIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhMb3c9MWUyMCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsb3cgY29ybmVyIGEgcmVjdGFuZ2xlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5TG93PTFlMjAgVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbG93IGNvcm5lciBhIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geEhpZ2g9LTFlMjAgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgaGlnaCBjb3JuZXIgYSByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhIaWdoPS0xZTIwIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGhpZ2ggY29ybmVyIGEgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgICB4TG93OiAxZTIwLFxuICAgICAgICAgICAgeUxvdzogMWUyMCxcbiAgICAgICAgICAgIHhIaWdoOiAtMWUyMCwgXG4gICAgICAgICAgICB5SGlnaDogLTFlMjAgfSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIGJvbmRpbmcgYm94IGZyb20gYW4gYXJyYXkgb2YgZm91ciBlbGVtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHggVGhlIGFycmF5IG9mIGZvdXIgZWxlbWVudHMgd2l0aCB0aGUgdHdvIGNvcm5lcnMgKFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdKS5cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkoeCkge1xuICAgICAgICB0aGlzLnhMb3cgPSB4WzBdO1xuICAgICAgICB0aGlzLnlMb3cgPSB4WzFdOyBcbiAgICAgICAgdGhpcy54SGlnaCA9IHhbMl07XG4gICAgICAgIHRoaXMueUhpZ2ggID0geFszXTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogRW1wdGllcyBhIGJvdW5kaW5nIGJveC5cbiAgICAgKi9cbiAgICB0b0VtcHR5KCkge1xuICAgICAgICB0aGlzLnhMb3cgPSAxZTIwO1xuICAgICAgICB0aGlzLnlMb3cgPSAxZTIwOyBcbiAgICAgICAgdGhpcy54SGlnaCA9IC0xZTIwO1xuICAgICAgICB0aGlzLnlIaWdoICA9IC0xZTIwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdlYXRoZXIgdGhlIGJvdW5kaW5nIGJveCBpcyBlbXB0eS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbH0gVGhlIHRlc3QgcmVzdWx0LlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhMb3cgPiB0aGlzLnhIaWdoIHx8IHRoaXMueUxvdyA+IHRoaXMueUhpZ2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmb3VyIGVsZW1lbnRzIGNvbnRhaW5nIHRoZSBsb3cgYW5kIGhpZ2ggY29ybmVycy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIGFycmF5IG9mIGNvcm5lcnMuXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnhMb3csIHRoaXMueUxvdywgdGhpcy54SGlnaCwgdGhpcy4geUhpZ2hdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0ZXh0IHN0cmluZyB3aXRoIHRoZSBjb3JuZXIgY29vcmRpbmF0ZXMgc2VwYXJhdGVkIGJ5IGEgc3BhY2UuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyBvZiBjb3JuZXJzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54TG93LnRvU3RyaW5nKCkgKyBcIiBcIiArIHRoaXMueUxvdy50b1N0cmluZygpICsgXCIgXCIgKyB0aGlzLnhIaWdoLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRoaXMueUhpZ2gudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBgYm94YCB0byBgdGhpc2AgQm91bmRpbmdCb3guXG4gICAgICogQHBhcmFtIHtCb3VuZGluZ0JveH0gYm94IFRoZSBib3VuZGluZyBib3ggdG8gYmUgbWVyZ2VkLiBcbiAgICAgKi9cbiAgICBtZXJnZUJveChib3gpIHtcblx0XHRpZiAoYm94ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYodGhpcy5pc0VtcHR5KCkpXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGJveCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54TG93ID0gTWF0aC5taW4odGhpcy54TG93LCAgYm94LnhMb3cpO1xuICAgICAgICAgICAgdGhpcy55TG93ID0gTWF0aC5taW4odGhpcy55TG93LCAgYm94LnlMb3cpO1xuICAgICAgICAgICAgdGhpcy54SGlnaCA9IE1hdGgubWF4KHRoaXMueEhpZ2gsIGJveC54SGlnaCk7XG4gICAgICAgICAgICB0aGlzLnlIaWdoID0gTWF0aC5tYXgodGhpcy55SGlnaCwgYm94LnlIaWdoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhIHBvaW50IGBwYHt4LCB5fSB0byBgdGhpc2AgQm91bmRpbmdCb3guXG4gICAgICogQHBhcmFtIHt7eCwgeX19IHAgVGhlIHBvaW50IHRvIGJlIG1lcmdlZC4gXG4gICAgICovXG4gICAgbWVyZ2VQb2ludChwKSB7XG4gICAgICAgIHRoaXMueExvdyA9IE1hdGgubWluKHRoaXMueExvdywgcC54KTtcbiAgICAgICAgdGhpcy55TG93ID0gTWF0aC5taW4odGhpcy55TG93LCBwLnkpO1xuICAgICAgICB0aGlzLnhIaWdoID0gTWF0aC5tYXgodGhpcy54SGlnaCwgcC54KTtcbiAgICAgICAgdGhpcy55SGlnaCA9IE1hdGgubWF4KHRoaXMueUhpZ2gsIHAueSk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGJvdW5kaW5nIGJveCBieSBhIGRpc3BsYWNlbWVudCB2ZWN0b3IgKGR4LCBkeSkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR4IERpc3BsYWNlbWVudCBhbG9uZyB0aGUgeC1heGlzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeSBEaXNwbGFjZW1lbnQgYWxvbmcgdGhlIHktYXhpcy5cbiAgICAgKi9cbiAgICBzaGlmdChkeCwgZHkpIHtcbiAgICAgICAgdGhpcy54TG93ICs9IGR4O1xuICAgICAgICB0aGlzLnlMb3cgKz0gZHk7XG4gICAgICAgIHRoaXMueEhpZ2ggKz0gZHg7XG4gICAgICAgIHRoaXMueUhpZ2ggKz0gZHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBieSBgc2lkZWAgYW5kIHRydW5jYXRlcyB0aGUgY29ybmVyIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7Kn0gc2lkZSBUaGUgdmFsdWUgdG8gZGl2aWRlIGJ5LlxuICAgICAqL1xuICAgIHF1YW50aXplKHNpZGUpIHtcbiAgICAgICAgdGhpcy54TG93ID0gIE1hdGguZmxvb3IodGhpcy54TG93L3NpZGUpO1xuICAgICAgICB0aGlzLnlMb3cgPSAgTWF0aC5mbG9vcih0aGlzLnlMb3cvc2lkZSk7XG4gICAgICAgIHRoaXMueEhpZ2ggPSBNYXRoLmZsb29yKCh0aGlzLnhIaWdoLTEpL3NpZGUpICsgMTtcbiAgICAgICAgdGhpcy55SGlnaCA9IE1hdGguZmxvb3IoKHRoaXMueUhpZ2gtMSkvc2lkZSkgKyAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCB3aWR0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggdmFsdWUuXG4gICAgICovXG4gICAgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhIaWdoIC0gdGhpcy54TG93O1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggaGVpZ2h0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBoZWlnaHQgdmFsdWUuXG4gICAgICovXG4gICAgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy55SGlnaCAtIHRoaXMueUxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggY2VudGVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjZW50ZXIgdmFsdWUuXG4gICAgICovXG4gICAgY2VudGVyKCkge1xuICAgICAgICByZXR1cm4gWyh0aGlzLnhMb3crdGhpcy54SGlnaCkvMiwgKHRoaXMueUxvdyt0aGlzLnlIaWdoKS8yXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpLXRoIGNvcm5lci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXggb2YgdGhlIGNvcm5lci4gXG4gICAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IEEgW3gsIHldIHBhaXIuXG4gICAgICovXG4gICAgY29ybmVyKGkpIHtcbiAgICAgICAgLy8gVG8gYXZvaWQgdGhlIHN3aXRjaFxuICAgICAgICBsZXQgdiA9IHRoaXMudG9BcnJheSgpO1xuICAgICAgICByZXR1cm4ge3g6IHZbMCArIChpJjB4MSk8PDFdLCB5OiB2WzEgKyAoaSYweDIpXSB9O1xuICAgIH1cblxuICAgIGludGVyc2VjdHMoYm94KSB7XG4gICAgICAgIHJldHVybiB4TG93IDw9IGJveC54SGlnaCAmJiB4SGlnaCA+PSBib3gueExvdyAmJiB5TG93IDw9IGJveC55SGlnaCAmJiB5SGlnaCA+PSBib3gueUxvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpbnRzIG91dCB0aGUgYm91bmRpbmcgYm94IGNvcm5lcnMgaW4gdGhlIGNvbnNvbGUuXG4gICAgICovXG4gICAgcHJpbnQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQk9YPVwiICsgdGhpcy54TG93LnRvRml4ZWQoMikgKyBcIiwgXCIgKyB0aGlzLnlMb3cudG9GaXhlZCgyKSArIFwiLCBcIiArIHRoaXMueEhpZ2gudG9GaXhlZCgyKSArIFwiLCBcIiArIHRoaXMueUhpZ2gudG9GaXhlZCgyKSlcbiAgICB9XG5cbn1cblxuZXhwb3J0eyBCb3VuZGluZ0JveCB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/BoundingBox.js\n");

/***/ }),

/***/ "./src/Cache.js":
/*!**********************!*\
  !*** ./src/Cache.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cache\": () => (/* binding */ Cache)\n/* harmony export */ });\n/*\n * The singleton class **Cache** implements a cache for faster retrieval of the tiles required by layers.\n * @class Cache\n */\n/** @ignore */\nclass _Cache {\n\t/**\n\t * Instantiates a Cache object. Tiles to be fetched are stored in an ordered `queue` in {Layer}.\n\t * @param {Object} [options] An object literal with cache parameters.\n\t * @param {number} options.capacity=536870912 The total cache capacity (in bytes).\n\t * @param {number} options.maxRequest=6 Max number of concurrent HTTP requests. Most common browsers allow six connections per domain.\n\t */\n\tconstructor(options) {\n\t\tObject.assign(this, {\n\t\t\tcapacity: 512*(1<<20),  //256 MB total capacity available\n\t\t\tsize: 0,                //amount of GPU ram used\n\n\t\t\tmaxRequest: 6,          //max number of concurrent HTTP requests\n\t\t\trequested: 0,\n\t\t\tmaxPrefetch: 8*(1<<20), //max amount of prefetched tiles.\n\t\t\tprefetched: 0           //amount of currently prefetched GPU ram.\n\t\t});\n\n\t\tObject.assign(this, options);\n\t\tthis.layers = [];   //map on layer.\n\t}\n\n\t/**\n\t * Determines which tiles of a given `layer` are candidates to be downloaded.\n\t * Cleans up the cache and schedules the web data fetch. \n\t * @param {Layer} layer A layer.\n\t */\n\tsetCandidates(layer) {\n\t\tif(!this.layers.includes(layer))\n\t\t\tthis.layers.push(layer);\n\t\tsetTimeout(() => { this.update(); }, 0); //ensure all the queues are set before updating.\n\t}\n\n\t/** @ignore */\n\tupdate() {\n\t\tif(this.requested > this.maxRequest)\n\t\t\treturn;\n\n\t\tlet best = this.findBestCandidate();\n\t\tif(!best) return;\n\t\twhile(this.size > this.capacity) { //we need to make room.\n\t\t\tlet worst = this.findWorstTile();\n\t\t\tif(!worst) {\n\t\t\t\tconsole.log(\"BIG problem in the cache\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(worst.tile.time < best.tile.time)\n\t\t\t\tthis.dropTile(worst.layer, worst.tile)\n\t\t\telse\n\t\t\t\treturn; \n\t\t}\n\t\tconsole.assert(best != best.layer.queue[0]);\n\t\tbest.layer.queue.shift();\n\t\tthis.loadTile(best.layer, best.tile);\n\t}\n\n\t/* Finds the best tile to be downloaded */\n\t/** @ignore */\n\tfindBestCandidate() {\n\t\tlet best = null;\n\t\tfor(let layer of this.layers) {\n\t\t\twhile(layer.queue.length > 0 && layer.tiles.has(layer.queue[0].index)) {\n\t\t\t\tlayer.queue.shift();\n\t\t\t}\n\t\t\tif(!layer.queue.length)\n\t\t\t\tcontinue;\n\t\t\tlet tile = layer.queue[0];\n\t\t\tif(!best ||\n\t\t\t\ttile.time > best.tile.time  + 1.0 ||  //old requests ignored\n\t\t\t\ttile.priority > best.tile.priority)\n\t\t\t\tbest = { layer, tile }\n\t\t}\n\t\treturn best;\n\t}\n\n\t/* Finds the worst tile to be dropped */\n\t/** @ignore */\n\tfindWorstTile() {\n\t\tlet worst = null;\n\t\tfor(let layer of this.layers) {\n\t\t\tfor(let tile of layer.tiles.values()) {\n\t\t\t\t//TODO might be some are present when switching shaders.\n\t\t\t\tif(tile.missing != 0) continue;\n\t\t\t\tif(!worst || \n\t\t\t\t   tile.time < worst.tile.time || \n\t\t\t\t   (tile.time == worst.tile.time && tile.priority < worst.tile.priority)) {\n\t\t\t\t\tworst = {layer, tile};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn worst;\n\t}\n\n\t/** @ignore */\n\tloadTile(layer, tile) {\n\t\tthis.requested++;\n\t\t(async () =>  { layer.loadTile(tile, (size) => { this.size += size; this.requested--; this.update(); } ); })();\n\t}\n\n\t/** @ignore */\n\tdropTile(layer, tile) {\n\t\tthis.size -= tile.size;\n\t\tlayer.dropTile(tile);\n\t}\n\n\n\t/**\n\t * Flushes all tiles for a `layer`.\n\t * @param {Layer} layer A layer.\n \t */\n\tflushLayer(layer) {\n\t\tif(!this.layers.includes(layer))\n\t\t\treturn;\n\t\tfor(let tile of layer.tiles.values())\n\t\t\tthis.dropTile(layer, tile);\n\t}\n}\n\n/**\n * Instantiates a Cache object. Tiles to be fetched are stored in an ordered `queue` in {Layer}.\n * @classdesc The singleton class **Cache** implements a cache for faster retrieval of the tiles required by layers.\n * @class Cache\n * @param {Object} [options] An object literal to define cache parameters.\n * @param {number} options.capacity=536870912 The total cache capacity (in bytes).\n * @param {number} options.maxRequest=6 Max number of concurrent HTTP requests. Most common browsers allow six connections per domain.\n */\nlet Cache = new _Cache;\n\n/**\n * Flushes all tiles for a `layer`.\n * @function flushLayer\n * @memberof Cache\n * @instance\n * @param {Layer} layer A layer.\n */\n\n/**\n * Determines which tiles of a given `layer` are candidates to be downloaded.\n * Cleans up the cache and schedules the web data fetch.\n * @function setCandidates\n * @memberof Cache\n * @instance\n * @param {Layer} layer A layer.\n */\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2FjaGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLE1BQU07QUFDaEcsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQixNQUFNO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQyxtQkFBbUIsa0JBQWtCLGlCQUFpQixJQUFJO0FBQzdHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlGQUF5RixNQUFNO0FBQy9GO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9DYWNoZS5qcz9iMmFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBUaGUgc2luZ2xldG9uIGNsYXNzICoqQ2FjaGUqKiBpbXBsZW1lbnRzIGEgY2FjaGUgZm9yIGZhc3RlciByZXRyaWV2YWwgb2YgdGhlIHRpbGVzIHJlcXVpcmVkIGJ5IGxheWVycy5cbiAqIEBjbGFzcyBDYWNoZVxuICovXG4vKiogQGlnbm9yZSAqL1xuY2xhc3MgX0NhY2hlIHtcblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIENhY2hlIG9iamVjdC4gVGlsZXMgdG8gYmUgZmV0Y2hlZCBhcmUgc3RvcmVkIGluIGFuIG9yZGVyZWQgYHF1ZXVlYCBpbiB7TGF5ZXJ9LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggY2FjaGUgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FwYWNpdHk9NTM2ODcwOTEyIFRoZSB0b3RhbCBjYWNoZSBjYXBhY2l0eSAoaW4gYnl0ZXMpLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhSZXF1ZXN0PTYgTWF4IG51bWJlciBvZiBjb25jdXJyZW50IEhUVFAgcmVxdWVzdHMuIE1vc3QgY29tbW9uIGJyb3dzZXJzIGFsbG93IHNpeCBjb25uZWN0aW9ucyBwZXIgZG9tYWluLlxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywge1xuXHRcdFx0Y2FwYWNpdHk6IDUxMiooMTw8MjApLCAgLy8yNTYgTUIgdG90YWwgY2FwYWNpdHkgYXZhaWxhYmxlXG5cdFx0XHRzaXplOiAwLCAgICAgICAgICAgICAgICAvL2Ftb3VudCBvZiBHUFUgcmFtIHVzZWRcblxuXHRcdFx0bWF4UmVxdWVzdDogNiwgICAgICAgICAgLy9tYXggbnVtYmVyIG9mIGNvbmN1cnJlbnQgSFRUUCByZXF1ZXN0c1xuXHRcdFx0cmVxdWVzdGVkOiAwLFxuXHRcdFx0bWF4UHJlZmV0Y2g6IDgqKDE8PDIwKSwgLy9tYXggYW1vdW50IG9mIHByZWZldGNoZWQgdGlsZXMuXG5cdFx0XHRwcmVmZXRjaGVkOiAwICAgICAgICAgICAvL2Ftb3VudCBvZiBjdXJyZW50bHkgcHJlZmV0Y2hlZCBHUFUgcmFtLlxuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLmxheWVycyA9IFtdOyAgIC8vbWFwIG9uIGxheWVyLlxuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgd2hpY2ggdGlsZXMgb2YgYSBnaXZlbiBgbGF5ZXJgIGFyZSBjYW5kaWRhdGVzIHRvIGJlIGRvd25sb2FkZWQuXG5cdCAqIENsZWFucyB1cCB0aGUgY2FjaGUgYW5kIHNjaGVkdWxlcyB0aGUgd2ViIGRhdGEgZmV0Y2guIFxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciBBIGxheWVyLlxuXHQgKi9cblx0c2V0Q2FuZGlkYXRlcyhsYXllcikge1xuXHRcdGlmKCF0aGlzLmxheWVycy5pbmNsdWRlcyhsYXllcikpXG5cdFx0XHR0aGlzLmxheWVycy5wdXNoKGxheWVyKTtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy51cGRhdGUoKTsgfSwgMCk7IC8vZW5zdXJlIGFsbCB0aGUgcXVldWVzIGFyZSBzZXQgYmVmb3JlIHVwZGF0aW5nLlxuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0dXBkYXRlKCkge1xuXHRcdGlmKHRoaXMucmVxdWVzdGVkID4gdGhpcy5tYXhSZXF1ZXN0KVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0bGV0IGJlc3QgPSB0aGlzLmZpbmRCZXN0Q2FuZGlkYXRlKCk7XG5cdFx0aWYoIWJlc3QpIHJldHVybjtcblx0XHR3aGlsZSh0aGlzLnNpemUgPiB0aGlzLmNhcGFjaXR5KSB7IC8vd2UgbmVlZCB0byBtYWtlIHJvb20uXG5cdFx0XHRsZXQgd29yc3QgPSB0aGlzLmZpbmRXb3JzdFRpbGUoKTtcblx0XHRcdGlmKCF3b3JzdCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkJJRyBwcm9ibGVtIGluIHRoZSBjYWNoZVwiKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZih3b3JzdC50aWxlLnRpbWUgPCBiZXN0LnRpbGUudGltZSlcblx0XHRcdFx0dGhpcy5kcm9wVGlsZSh3b3JzdC5sYXllciwgd29yc3QudGlsZSlcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmV0dXJuOyBcblx0XHR9XG5cdFx0Y29uc29sZS5hc3NlcnQoYmVzdCAhPSBiZXN0LmxheWVyLnF1ZXVlWzBdKTtcblx0XHRiZXN0LmxheWVyLnF1ZXVlLnNoaWZ0KCk7XG5cdFx0dGhpcy5sb2FkVGlsZShiZXN0LmxheWVyLCBiZXN0LnRpbGUpO1xuXHR9XG5cblx0LyogRmluZHMgdGhlIGJlc3QgdGlsZSB0byBiZSBkb3dubG9hZGVkICovXG5cdC8qKiBAaWdub3JlICovXG5cdGZpbmRCZXN0Q2FuZGlkYXRlKCkge1xuXHRcdGxldCBiZXN0ID0gbnVsbDtcblx0XHRmb3IobGV0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG5cdFx0XHR3aGlsZShsYXllci5xdWV1ZS5sZW5ndGggPiAwICYmIGxheWVyLnRpbGVzLmhhcyhsYXllci5xdWV1ZVswXS5pbmRleCkpIHtcblx0XHRcdFx0bGF5ZXIucXVldWUuc2hpZnQoKTtcblx0XHRcdH1cblx0XHRcdGlmKCFsYXllci5xdWV1ZS5sZW5ndGgpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0bGV0IHRpbGUgPSBsYXllci5xdWV1ZVswXTtcblx0XHRcdGlmKCFiZXN0IHx8XG5cdFx0XHRcdHRpbGUudGltZSA+IGJlc3QudGlsZS50aW1lICArIDEuMCB8fCAgLy9vbGQgcmVxdWVzdHMgaWdub3JlZFxuXHRcdFx0XHR0aWxlLnByaW9yaXR5ID4gYmVzdC50aWxlLnByaW9yaXR5KVxuXHRcdFx0XHRiZXN0ID0geyBsYXllciwgdGlsZSB9XG5cdFx0fVxuXHRcdHJldHVybiBiZXN0O1xuXHR9XG5cblx0LyogRmluZHMgdGhlIHdvcnN0IHRpbGUgdG8gYmUgZHJvcHBlZCAqL1xuXHQvKiogQGlnbm9yZSAqL1xuXHRmaW5kV29yc3RUaWxlKCkge1xuXHRcdGxldCB3b3JzdCA9IG51bGw7XG5cdFx0Zm9yKGxldCBsYXllciBvZiB0aGlzLmxheWVycykge1xuXHRcdFx0Zm9yKGxldCB0aWxlIG9mIGxheWVyLnRpbGVzLnZhbHVlcygpKSB7XG5cdFx0XHRcdC8vVE9ETyBtaWdodCBiZSBzb21lIGFyZSBwcmVzZW50IHdoZW4gc3dpdGNoaW5nIHNoYWRlcnMuXG5cdFx0XHRcdGlmKHRpbGUubWlzc2luZyAhPSAwKSBjb250aW51ZTtcblx0XHRcdFx0aWYoIXdvcnN0IHx8IFxuXHRcdFx0XHQgICB0aWxlLnRpbWUgPCB3b3JzdC50aWxlLnRpbWUgfHwgXG5cdFx0XHRcdCAgICh0aWxlLnRpbWUgPT0gd29yc3QudGlsZS50aW1lICYmIHRpbGUucHJpb3JpdHkgPCB3b3JzdC50aWxlLnByaW9yaXR5KSkge1xuXHRcdFx0XHRcdHdvcnN0ID0ge2xheWVyLCB0aWxlfTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gd29yc3Q7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRsb2FkVGlsZShsYXllciwgdGlsZSkge1xuXHRcdHRoaXMucmVxdWVzdGVkKys7XG5cdFx0KGFzeW5jICgpID0+ICB7IGxheWVyLmxvYWRUaWxlKHRpbGUsIChzaXplKSA9PiB7IHRoaXMuc2l6ZSArPSBzaXplOyB0aGlzLnJlcXVlc3RlZC0tOyB0aGlzLnVwZGF0ZSgpOyB9ICk7IH0pKCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRkcm9wVGlsZShsYXllciwgdGlsZSkge1xuXHRcdHRoaXMuc2l6ZSAtPSB0aWxlLnNpemU7XG5cdFx0bGF5ZXIuZHJvcFRpbGUodGlsZSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBGbHVzaGVzIGFsbCB0aWxlcyBmb3IgYSBgbGF5ZXJgLlxuXHQgKiBAcGFyYW0ge0xheWVyfSBsYXllciBBIGxheWVyLlxuIFx0ICovXG5cdGZsdXNoTGF5ZXIobGF5ZXIpIHtcblx0XHRpZighdGhpcy5sYXllcnMuaW5jbHVkZXMobGF5ZXIpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGZvcihsZXQgdGlsZSBvZiBsYXllci50aWxlcy52YWx1ZXMoKSlcblx0XHRcdHRoaXMuZHJvcFRpbGUobGF5ZXIsIHRpbGUpO1xuXHR9XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgQ2FjaGUgb2JqZWN0LiBUaWxlcyB0byBiZSBmZXRjaGVkIGFyZSBzdG9yZWQgaW4gYW4gb3JkZXJlZCBgcXVldWVgIGluIHtMYXllcn0uXG4gKiBAY2xhc3NkZXNjIFRoZSBzaW5nbGV0b24gY2xhc3MgKipDYWNoZSoqIGltcGxlbWVudHMgYSBjYWNoZSBmb3IgZmFzdGVyIHJldHJpZXZhbCBvZiB0aGUgdGlsZXMgcmVxdWlyZWQgYnkgbGF5ZXJzLlxuICogQGNsYXNzIENhY2hlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBsaXRlcmFsIHRvIGRlZmluZSBjYWNoZSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FwYWNpdHk9NTM2ODcwOTEyIFRoZSB0b3RhbCBjYWNoZSBjYXBhY2l0eSAoaW4gYnl0ZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4UmVxdWVzdD02IE1heCBudW1iZXIgb2YgY29uY3VycmVudCBIVFRQIHJlcXVlc3RzLiBNb3N0IGNvbW1vbiBicm93c2VycyBhbGxvdyBzaXggY29ubmVjdGlvbnMgcGVyIGRvbWFpbi5cbiAqL1xubGV0IENhY2hlID0gbmV3IF9DYWNoZTtcblxuLyoqXG4gKiBGbHVzaGVzIGFsbCB0aWxlcyBmb3IgYSBgbGF5ZXJgLlxuICogQGZ1bmN0aW9uIGZsdXNoTGF5ZXJcbiAqIEBtZW1iZXJvZiBDYWNoZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0xheWVyfSBsYXllciBBIGxheWVyLlxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGljaCB0aWxlcyBvZiBhIGdpdmVuIGBsYXllcmAgYXJlIGNhbmRpZGF0ZXMgdG8gYmUgZG93bmxvYWRlZC5cbiAqIENsZWFucyB1cCB0aGUgY2FjaGUgYW5kIHNjaGVkdWxlcyB0aGUgd2ViIGRhdGEgZmV0Y2guXG4gKiBAZnVuY3Rpb24gc2V0Q2FuZGlkYXRlc1xuICogQG1lbWJlcm9mIENhY2hlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIEEgbGF5ZXIuXG4gKi9cblxuXG5leHBvcnQgeyBDYWNoZSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Cache.js\n");

/***/ }),

/***/ "./src/Camera.js":
/*!***********************!*\
  !*** ./src/Camera.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _Transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform.js */ \"./src/Transform.js\");\n/* harmony import */ var _BoundingBox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BoundingBox.js */ \"./src/BoundingBox.js\");\n/* harmony import */ var _Signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Signals.js */ \"./src/Signals.js\");\n\n\n \n\n/**\n * The type Viewport defines a rectangular viewing region inside a (wxh) area\n * @typedef {Object} Viewport\n * @property {number} x x-component of the lower left corner.\n * @property {number} y y-component of the lower left corner.\n * @property {number} dx x-component of the top right corner.\n * @property {number} dy y-component of the top right corner.\n * @property {number} w the viewport width.\n * @property {number} w the viewport height.\n */\n\n/**\n * The class Camera does not have an operational role, but it is rather a container of parameters \n * needed by the system to define the viewport, the camera position and to calculate the appropriate view.\n * \n * To enable the animation, a camera contains two view matrices (two {@link Transform} objects): a `source` with the \n * current position and a `target` with the position the camera will arrive at in a time `dt`. \n * \n * The member function `setPosition()` takes care of defining the target, the OpenLIME system automatically animates the \n * camera to bring it from source to target, unless the user manually interrupts the current animation.\n * \n * User-generated device events (such as touch events or mouse events) can modify camera parameters via an appropriate {@link Controller}.\n */\n\n \nclass Camera {\n\t/**\n\t * Creates a scene's camera. An update event is issued when the camera has completed its positioning.\n \t * Additionally, an object literal with Viewer `options` can be specified.\n \t * @param {Object} [options]\n \t * @param {bool} options.bounded=true Weather to limit the translation of the camera to the boundary of the scene.\n \t * @param {number} options.maxFixedZoom=2 The maximum pixel size.\n  \t * @param {number} options.minScreenFraction=1 The minimum portion of the screen to zoom in.\n \t */\n\tconstructor(options) {\n\t\tObject.assign(this, {\n\t\t\tviewport: null,\n\t\t\tbounded: true,\n\t\t\tminScreenFraction: 1,\n\t\t\tmaxFixedZoom: 2,\n\t\t\tmaxZoom: 2,\n\t\t\tminZoom: 1,\n\t\t\tboundingBox: new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_1__.BoundingBox,\n\t\t});\n\t\tObject.assign(this, options);\n\t\tthis.target = new _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform(this.target);\n\t\tthis.source = this.target.copy();\n\t\tthis.easing = 'linear';\n\t}\n\n\t/**\n\t * Defines the copy constructor.\n\t * @returns A copy of the Camera.\n\t */\n\tcopy() {\n\t\tlet camera = new Camera();\n\t\tObject.assign(camera, this);\n\t\treturn camera;\n\t}\n\n\t/**\n\t * Sets the viewport and updates the camera position as close as possible to the previuos one.\n\t * @param {Viewport} view The new viewport (in CSS coordinates). \n\t */\n\tsetViewport(view) {\n\t\tif (this.viewport) {\n\t\t\tlet rz = Math.sqrt((view.w / this.viewport.w) * (view.h / this.viewport.h));\n\t\t\tthis.viewport = view;\n\t\t\tconst { x, y, z, a } = this.target;\n\t\t\tthis.setPosition(0, x, y, z * rz, a);\n\t\t} else {\n\t\t\tthis.viewport = view;\n\t\t}\n\t}\n\n\t/** \n\t* Gets the current viewport (in device coordinates).\n\t* @return the current viewport\n\t*/\n\tglViewport() {\n\t\tlet d = window.devicePixelRatio;\n\t\tlet viewport = {};\n\t\tfor (let i in this.viewport)\n\t\t\tviewport[i] = this.viewport[i] * d;\n\t\treturn viewport;\n\t}\n\n\t/**\n\t * Map coordinate relative to the canvas into scene coords using the specified transform.\n\t * @return {Object} {X, Y} in scene coordinates (relative to the center of the viewport).\n\t */\n\tmapToScene(x, y, transform) {\n\t\t//compute coords relative to the center of the viewport.\n\t\tx -= this.viewport.w / 2;\n\t\ty -= this.viewport.h / 2;\n\t\tx -= transform.x;\n\t\ty -= transform.y;\n\t\tx /= transform.z;\n\t\ty /= transform.z;\n\t\tlet r = _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform.rotate(x, y, -transform.a);\n\t\treturn { x: r.x, y: r.y };\n\t}\n\n\t/**\n\t * Map coordinate relative to the scene into canvas coords using the specified transform.\n\t * @return {Object} {X, Y} in canvas coordinates.\n\t */\n\tsceneToCanvas(x, y, transform) {\n\t\tlet r = _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform.rotate(x, y, transform.a);\n\t\tx = r.x * transform.z + transform.x - this.viewport.x + this.viewport.w/2;\n\t\ty = r.y * transform.z - transform.y + this.viewport.y + this.viewport.h/2;\n\t\treturn { x: x, y: y };\n\t}\n\n\t/**\n\t * Sets the camera target parameters (position, rotation, )\n\t * @param {number} dt The animation duration in millisecond.\n\t * @param {*} x The x-component of the translation vector.\n\t * @param {*} y The y-component of the translation vector.\n\t * @param {*} z The zoom factor.\n\t * @param {*} a The rotation angle (in degrees).\n\t * @param {Easing} easing The function aimed at making the camera movement less severe or pronounced.\n\t */\n\tsetPosition(dt, x, y, z, a, easing) {\n\t\t/**\n\t\t* The event is fired when the camera target is changed.\n\t\t* @event Camera#update\n\t\t*/\n\n\t\t// Discard events due to cursor outside window\n\t\t//if (Math.abs(x) > 64000 || Math.abs(y) > 64000) return;\n\t\tthis.easing = easing || this.easing;\n\n\t\tif (this.bounded) {\n\t\t\tconst sw = this.viewport.dx;\n\t\t\tconst sh = this.viewport.dy;\n\n\t\t\t//\n\t\t\tlet xform = new _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform({ x: x, y: y, z: z, a: a, t: 0 });\n\t\t\tlet tbox = xform.transformBox(this.boundingBox);\n\t\t\tconst bw = tbox.width();\n\t\t\tconst bh = tbox.height();\n\n\t\t\t// Screen space offset between image boundary and screen boundary\n\t\t\t// Do not let transform offet go beyond this limit.\n\t\t\t// if (scaled-image-size < screen) it remains fully contained\n\t\t\t// else the scaled-image boundary closest to the screen cannot enter the screen.\n\t\t\tconst dx = Math.abs(bw - sw) / 2;\n\t\t\tx = Math.min(Math.max(-dx, x), dx);\n\n\t\t\tconst dy = Math.abs(bh - sh) / 2;\n\t\t\ty = Math.min(Math.max(-dy, y), dy);\n\t\t}\n\n\t\tlet now = performance.now();\n\t\tthis.source = this.getCurrentTransform(now);\n\t\t//the angle needs to be interpolated in the shortest direction.\n\t\t//target it is kept between 0 and +360, source is kept relative.\n\t\ta = _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform.normalizeAngle(a);\n\t\tthis.source.a = _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform.normalizeAngle(this.source.a);\n\t\tif (a - this.source.a > 180) this.source.a += 360;\n\t\tif (this.source.a - a > 180) this.source.a -= 360;\n\t\tObject.assign(this.target, { x: x, y: y, z: z, a: a, t: now + dt });\n\t\tthis.emit('update');\n\t}\n\n\t/**\n\t * Pan the camera (in canvas coords)\n\t * @param {number} dt The animation duration in millisecond.\n\t * @param {number} dx The horizontal displancement.\n\t * @param {number} dy The vertical displacement. \n\t */\n\tpan(dt, dx, dy) {\n\t\tlet now = performance.now();\n\t\tlet m = this.getCurrentTransform(now);\n\t\tm.x += dx;\n\t\tm.y += dy;\n\t\tthis.setPosition(dt, m.x, m.y, m.z, m.a);\n\t}\n\n\t/** Zoom in or out at a specific point (in canvas coords)\n\t * @param {number} dt The animation duration in millisecond.\n\t * @param {number} z The distance of the camera from the canvas.\n\t * @param {number} x The x coord to zoom in|out\n\t * @param {number} y The y coord to zoom in|out\n\t */\n\tzoom(dt, z, x, y) {\n\t\tif (!x) x = 0;\n\t\tif (!y) y = 0;\n\n\t\tlet now = performance.now();\n\t\tlet m = this.getCurrentTransform(now);\n\n\t\tif (this.bounded) {\n\t\t\tz = Math.min(Math.max(z, this.minZoom), this.maxZoom);\n\t\t}\n\n\t\t//x, an y should be the center of the zoom.\n\t\tm.x += (m.x + x) * (m.z - z) / m.z;\n\t\tm.y += (m.y + y) * (m.z - z) / m.z;\n\n\t\tthis.setPosition(dt, m.x, m.y, z, m.a);\n\t}\n\n\t/**\n\t * Rotate the camera around its z-axis by an `a` angle (in degrees) \n\t * @param {number} dt The animation duration in millisecond.\n\t * @param {angle} a The rotation angle (in degrees).\n\t */\n\trotate(dt, a) {\n\n\t\tlet now = performance.now();\n\t\tlet m = this.getCurrentTransform(now);\n\n\t\tthis.setPosition(dt, m.x, m.y, m.z, this.target.a + a);\n\t}\n\n\t/** Zoom in or out at a specific point (in canvas coords)\n\t * @param {number} dt The animation duration in millisecond.\n\t * @param {number} dz The scroll amount for the z-axis.\n\t * @param {number} x=0 The x coord to zoom in|out\n\t * @param {number} y=0 The y coord to zoom in|out\n\t */\n\tdeltaZoom(dt, dz, x=0, y=0) {\n\n\t\tlet now = performance.now();\n\t\tlet m = this.getCurrentTransform(now);\n\n\t\t//rapid firing wheel event need to compound.\n\t\t//but the x, y in input are relative to the current transform.\n\t\tdz *= this.target.z / m.z;\n\n\t\tif (this.bounded) {\n\t\t\tif (m.z * dz < this.minZoom) dz = this.minZoom / m.z;\n\t\t\tif (m.z * dz > this.maxZoom) dz = this.maxZoom / m.z;\n\t\t}\n\n\t\t//transform is x*z + dx = X , there x is positrion in scene, X on screen\n\t\t//we want x*z*dz + dx1 = X (stay put, we need to find dx1.\n\t\tlet r = _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform.rotate(x, y, m.a);\n\t\tm.x += r.x * m.z * (1 - dz);\n\t\tm.y += r.y * m.z * (1 - dz);\n\n\t\tthis.setPosition(dt, m.x, m.y, m.z * dz, m.a);\n\t}\n\n\t/**\n\t * Gets the camera transform at `time` in canvas coords.\n\t * @param {time} time The current time (a DOMHighResTimeStamp variable, as in `performance.now()`).\n\t * @returns {Transform} The current transform\n\t */\n\tgetCurrentTransform(time) {\n\t\tif(time > this.target.t) this.easing = 'linear';\n\t\treturn _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform.interpolate(this.source, this.target, time, this.easing);\n\t}\n\n\t/**\n\t * Gets the camera transform at `time` in device coords.\n\t * @param {time} time The current time (a DOMHighResTimeStamp variable, as in `performance.now()`).\n\t * @returns {Transform} The current transform\n\t */\n\t getGlCurrentTransform(time) {\n\t\tconst pos = this.getCurrentTransform(time);\n\t\tpos.x *= window.devicePixelRatio;\n\t\tpos.y *= window.devicePixelRatio;\n\t\tpos.z *= window.devicePixelRatio;\n\t\treturn pos;\n\t}\n\n\n\t/**\n\t * Modify the camera settings to frame the specified `box` \n\t * @param {BoundingBox} box The specified rectangle [minx, miny, maxx, maxy] in the canvas.\n\t * @param {number} dt The animation duration in millisecond \n\t */\n\tfit(box, dt) {\n\t\tif (box.isEmpty()) return;\n\t\tif (!dt) dt = 0;\n\n\t\t//find if we align the topbottom borders or the leftright border.\n\t\tlet w = this.viewport.dx;\n\t\tlet h = this.viewport.dy;\n\n\t\tlet bw = box.width();\n\t\tlet bh = box.height();\n\t\tlet c = box.center();\n\t\tlet z = Math.min(w / bw, h / bh);\n\n\t\tthis.setPosition(dt, -c[0], -c[1], z, 0);\n\t}\n\n\t/**\n\t * Modify the camera settings to the factory values (home). \n\t * @param {number} dt animation duration in millisecond\n\t */\n\tfitCameraBox(dt) {\n\t\tthis.fit(this.boundingBox, dt);\n\t}\n\n\t/** @ignore */\n\tupdateBounds(box, minScale) {\n\t\tthis.boundingBox = box;\n\t\tconst w = this.viewport.dx;\n\t\tconst h = this.viewport.dy;\n\n\t\tlet bw = this.boundingBox.width();\n\t\tlet bh = this.boundingBox.height();\n\n\t\tthis.minZoom = Math.min(w / bw, h / bh) * this.minScreenFraction;\n\t\tthis.maxZoom = minScale > 0 ? this.maxFixedZoom / minScale : this.maxFixedZoom;\n\t\tthis.maxZoom = Math.max(this.minZoom, this.maxZoom);\n\t}\n}\n\n(0,_Signals_js__WEBPACK_IMPORTED_MODULE_2__.addSignals)(Camera, 'update');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0VBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQVU7O0FBRU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9DYW1lcmEuanM/YzIyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL1RyYW5zZm9ybS5qcydcbmltcG9ydCB7IEJvdW5kaW5nQm94IH0gZnJvbSAnLi9Cb3VuZGluZ0JveC5qcydcbmltcG9ydCB7IGFkZFNpZ25hbHMgfSBmcm9tICcuL1NpZ25hbHMuanMnIFxuXG4vKipcbiAqIFRoZSB0eXBlIFZpZXdwb3J0IGRlZmluZXMgYSByZWN0YW5ndWxhciB2aWV3aW5nIHJlZ2lvbiBpbnNpZGUgYSAod3hoKSBhcmVhXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3cG9ydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggeC1jb21wb25lbnQgb2YgdGhlIGxvd2VyIGxlZnQgY29ybmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgeS1jb21wb25lbnQgb2YgdGhlIGxvd2VyIGxlZnQgY29ybmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR4IHgtY29tcG9uZW50IG9mIHRoZSB0b3AgcmlnaHQgY29ybmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR5IHktY29tcG9uZW50IG9mIHRoZSB0b3AgcmlnaHQgY29ybmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHcgdGhlIHZpZXdwb3J0IHdpZHRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHcgdGhlIHZpZXdwb3J0IGhlaWdodC5cbiAqL1xuXG4vKipcbiAqIFRoZSBjbGFzcyBDYW1lcmEgZG9lcyBub3QgaGF2ZSBhbiBvcGVyYXRpb25hbCByb2xlLCBidXQgaXQgaXMgcmF0aGVyIGEgY29udGFpbmVyIG9mIHBhcmFtZXRlcnMgXG4gKiBuZWVkZWQgYnkgdGhlIHN5c3RlbSB0byBkZWZpbmUgdGhlIHZpZXdwb3J0LCB0aGUgY2FtZXJhIHBvc2l0aW9uIGFuZCB0byBjYWxjdWxhdGUgdGhlIGFwcHJvcHJpYXRlIHZpZXcuXG4gKiBcbiAqIFRvIGVuYWJsZSB0aGUgYW5pbWF0aW9uLCBhIGNhbWVyYSBjb250YWlucyB0d28gdmlldyBtYXRyaWNlcyAodHdvIHtAbGluayBUcmFuc2Zvcm19IG9iamVjdHMpOiBhIGBzb3VyY2VgIHdpdGggdGhlIFxuICogY3VycmVudCBwb3NpdGlvbiBhbmQgYSBgdGFyZ2V0YCB3aXRoIHRoZSBwb3NpdGlvbiB0aGUgY2FtZXJhIHdpbGwgYXJyaXZlIGF0IGluIGEgdGltZSBgZHRgLiBcbiAqIFxuICogVGhlIG1lbWJlciBmdW5jdGlvbiBgc2V0UG9zaXRpb24oKWAgdGFrZXMgY2FyZSBvZiBkZWZpbmluZyB0aGUgdGFyZ2V0LCB0aGUgT3BlbkxJTUUgc3lzdGVtIGF1dG9tYXRpY2FsbHkgYW5pbWF0ZXMgdGhlIFxuICogY2FtZXJhIHRvIGJyaW5nIGl0IGZyb20gc291cmNlIHRvIHRhcmdldCwgdW5sZXNzIHRoZSB1c2VyIG1hbnVhbGx5IGludGVycnVwdHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuICogXG4gKiBVc2VyLWdlbmVyYXRlZCBkZXZpY2UgZXZlbnRzIChzdWNoIGFzIHRvdWNoIGV2ZW50cyBvciBtb3VzZSBldmVudHMpIGNhbiBtb2RpZnkgY2FtZXJhIHBhcmFtZXRlcnMgdmlhIGFuIGFwcHJvcHJpYXRlIHtAbGluayBDb250cm9sbGVyfS5cbiAqL1xuXG4gXG5jbGFzcyBDYW1lcmEge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIHNjZW5lJ3MgY2FtZXJhLiBBbiB1cGRhdGUgZXZlbnQgaXMgaXNzdWVkIHdoZW4gdGhlIGNhbWVyYSBoYXMgY29tcGxldGVkIGl0cyBwb3NpdGlvbmluZy5cbiBcdCAqIEFkZGl0aW9uYWxseSwgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBWaWV3ZXIgYG9wdGlvbnNgIGNhbiBiZSBzcGVjaWZpZWQuXG4gXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gXHQgKiBAcGFyYW0ge2Jvb2x9IG9wdGlvbnMuYm91bmRlZD10cnVlIFdlYXRoZXIgdG8gbGltaXQgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBjYW1lcmEgdG8gdGhlIGJvdW5kYXJ5IG9mIHRoZSBzY2VuZS5cbiBcdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heEZpeGVkWm9vbT0yIFRoZSBtYXhpbXVtIHBpeGVsIHNpemUuXG4gIFx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWluU2NyZWVuRnJhY3Rpb249MSBUaGUgbWluaW11bSBwb3J0aW9uIG9mIHRoZSBzY3JlZW4gdG8gem9vbSBpbi5cbiBcdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XG5cdFx0XHR2aWV3cG9ydDogbnVsbCxcblx0XHRcdGJvdW5kZWQ6IHRydWUsXG5cdFx0XHRtaW5TY3JlZW5GcmFjdGlvbjogMSxcblx0XHRcdG1heEZpeGVkWm9vbTogMixcblx0XHRcdG1heFpvb206IDIsXG5cdFx0XHRtaW5ab29tOiAxLFxuXHRcdFx0Ym91bmRpbmdCb3g6IG5ldyBCb3VuZGluZ0JveCxcblx0XHR9KTtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMudGFyZ2V0ID0gbmV3IFRyYW5zZm9ybSh0aGlzLnRhcmdldCk7XG5cdFx0dGhpcy5zb3VyY2UgPSB0aGlzLnRhcmdldC5jb3B5KCk7XG5cdFx0dGhpcy5lYXNpbmcgPSAnbGluZWFyJztcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIHRoZSBjb3B5IGNvbnN0cnVjdG9yLlxuXHQgKiBAcmV0dXJucyBBIGNvcHkgb2YgdGhlIENhbWVyYS5cblx0ICovXG5cdGNvcHkoKSB7XG5cdFx0bGV0IGNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcblx0XHRPYmplY3QuYXNzaWduKGNhbWVyYSwgdGhpcyk7XG5cdFx0cmV0dXJuIGNhbWVyYTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2aWV3cG9ydCBhbmQgdXBkYXRlcyB0aGUgY2FtZXJhIHBvc2l0aW9uIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIHRoZSBwcmV2aXVvcyBvbmUuXG5cdCAqIEBwYXJhbSB7Vmlld3BvcnR9IHZpZXcgVGhlIG5ldyB2aWV3cG9ydCAoaW4gQ1NTIGNvb3JkaW5hdGVzKS4gXG5cdCAqL1xuXHRzZXRWaWV3cG9ydCh2aWV3KSB7XG5cdFx0aWYgKHRoaXMudmlld3BvcnQpIHtcblx0XHRcdGxldCByeiA9IE1hdGguc3FydCgodmlldy53IC8gdGhpcy52aWV3cG9ydC53KSAqICh2aWV3LmggLyB0aGlzLnZpZXdwb3J0LmgpKTtcblx0XHRcdHRoaXMudmlld3BvcnQgPSB2aWV3O1xuXHRcdFx0Y29uc3QgeyB4LCB5LCB6LCBhIH0gPSB0aGlzLnRhcmdldDtcblx0XHRcdHRoaXMuc2V0UG9zaXRpb24oMCwgeCwgeSwgeiAqIHJ6LCBhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52aWV3cG9ydCA9IHZpZXc7XG5cdFx0fVxuXHR9XG5cblx0LyoqIFxuXHQqIEdldHMgdGhlIGN1cnJlbnQgdmlld3BvcnQgKGluIGRldmljZSBjb29yZGluYXRlcykuXG5cdCogQHJldHVybiB0aGUgY3VycmVudCB2aWV3cG9ydFxuXHQqL1xuXHRnbFZpZXdwb3J0KCkge1xuXHRcdGxldCBkID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdFx0bGV0IHZpZXdwb3J0ID0ge307XG5cdFx0Zm9yIChsZXQgaSBpbiB0aGlzLnZpZXdwb3J0KVxuXHRcdFx0dmlld3BvcnRbaV0gPSB0aGlzLnZpZXdwb3J0W2ldICogZDtcblx0XHRyZXR1cm4gdmlld3BvcnQ7XG5cdH1cblxuXHQvKipcblx0ICogTWFwIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyBpbnRvIHNjZW5lIGNvb3JkcyB1c2luZyB0aGUgc3BlY2lmaWVkIHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7T2JqZWN0fSB7WCwgWX0gaW4gc2NlbmUgY29vcmRpbmF0ZXMgKHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0KS5cblx0ICovXG5cdG1hcFRvU2NlbmUoeCwgeSwgdHJhbnNmb3JtKSB7XG5cdFx0Ly9jb21wdXRlIGNvb3JkcyByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydC5cblx0XHR4IC09IHRoaXMudmlld3BvcnQudyAvIDI7XG5cdFx0eSAtPSB0aGlzLnZpZXdwb3J0LmggLyAyO1xuXHRcdHggLT0gdHJhbnNmb3JtLng7XG5cdFx0eSAtPSB0cmFuc2Zvcm0ueTtcblx0XHR4IC89IHRyYW5zZm9ybS56O1xuXHRcdHkgLz0gdHJhbnNmb3JtLno7XG5cdFx0bGV0IHIgPSBUcmFuc2Zvcm0ucm90YXRlKHgsIHksIC10cmFuc2Zvcm0uYSk7XG5cdFx0cmV0dXJuIHsgeDogci54LCB5OiByLnkgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXAgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgc2NlbmUgaW50byBjYW52YXMgY29vcmRzIHVzaW5nIHRoZSBzcGVjaWZpZWQgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHtYLCBZfSBpbiBjYW52YXMgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRzY2VuZVRvQ2FudmFzKHgsIHksIHRyYW5zZm9ybSkge1xuXHRcdGxldCByID0gVHJhbnNmb3JtLnJvdGF0ZSh4LCB5LCB0cmFuc2Zvcm0uYSk7XG5cdFx0eCA9IHIueCAqIHRyYW5zZm9ybS56ICsgdHJhbnNmb3JtLnggLSB0aGlzLnZpZXdwb3J0LnggKyB0aGlzLnZpZXdwb3J0LncvMjtcblx0XHR5ID0gci55ICogdHJhbnNmb3JtLnogLSB0cmFuc2Zvcm0ueSArIHRoaXMudmlld3BvcnQueSArIHRoaXMudmlld3BvcnQuaC8yO1xuXHRcdHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjYW1lcmEgdGFyZ2V0IHBhcmFtZXRlcnMgKHBvc2l0aW9uLCByb3RhdGlvbiwgKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHQgVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZC5cblx0ICogQHBhcmFtIHsqfSB4IFRoZSB4LWNvbXBvbmVudCBvZiB0aGUgdHJhbnNsYXRpb24gdmVjdG9yLlxuXHQgKiBAcGFyYW0geyp9IHkgVGhlIHktY29tcG9uZW50IG9mIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7Kn0geiBUaGUgem9vbSBmYWN0b3IuXG5cdCAqIEBwYXJhbSB7Kn0gYSBUaGUgcm90YXRpb24gYW5nbGUgKGluIGRlZ3JlZXMpLlxuXHQgKiBAcGFyYW0ge0Vhc2luZ30gZWFzaW5nIFRoZSBmdW5jdGlvbiBhaW1lZCBhdCBtYWtpbmcgdGhlIGNhbWVyYSBtb3ZlbWVudCBsZXNzIHNldmVyZSBvciBwcm9ub3VuY2VkLlxuXHQgKi9cblx0c2V0UG9zaXRpb24oZHQsIHgsIHksIHosIGEsIGVhc2luZykge1xuXHRcdC8qKlxuXHRcdCogVGhlIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNhbWVyYSB0YXJnZXQgaXMgY2hhbmdlZC5cblx0XHQqIEBldmVudCBDYW1lcmEjdXBkYXRlXG5cdFx0Ki9cblxuXHRcdC8vIERpc2NhcmQgZXZlbnRzIGR1ZSB0byBjdXJzb3Igb3V0c2lkZSB3aW5kb3dcblx0XHQvL2lmIChNYXRoLmFicyh4KSA+IDY0MDAwIHx8IE1hdGguYWJzKHkpID4gNjQwMDApIHJldHVybjtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCB0aGlzLmVhc2luZztcblxuXHRcdGlmICh0aGlzLmJvdW5kZWQpIHtcblx0XHRcdGNvbnN0IHN3ID0gdGhpcy52aWV3cG9ydC5keDtcblx0XHRcdGNvbnN0IHNoID0gdGhpcy52aWV3cG9ydC5keTtcblxuXHRcdFx0Ly9cblx0XHRcdGxldCB4Zm9ybSA9IG5ldyBUcmFuc2Zvcm0oeyB4OiB4LCB5OiB5LCB6OiB6LCBhOiBhLCB0OiAwIH0pO1xuXHRcdFx0bGV0IHRib3ggPSB4Zm9ybS50cmFuc2Zvcm1Cb3godGhpcy5ib3VuZGluZ0JveCk7XG5cdFx0XHRjb25zdCBidyA9IHRib3gud2lkdGgoKTtcblx0XHRcdGNvbnN0IGJoID0gdGJveC5oZWlnaHQoKTtcblxuXHRcdFx0Ly8gU2NyZWVuIHNwYWNlIG9mZnNldCBiZXR3ZWVuIGltYWdlIGJvdW5kYXJ5IGFuZCBzY3JlZW4gYm91bmRhcnlcblx0XHRcdC8vIERvIG5vdCBsZXQgdHJhbnNmb3JtIG9mZmV0IGdvIGJleW9uZCB0aGlzIGxpbWl0LlxuXHRcdFx0Ly8gaWYgKHNjYWxlZC1pbWFnZS1zaXplIDwgc2NyZWVuKSBpdCByZW1haW5zIGZ1bGx5IGNvbnRhaW5lZFxuXHRcdFx0Ly8gZWxzZSB0aGUgc2NhbGVkLWltYWdlIGJvdW5kYXJ5IGNsb3Nlc3QgdG8gdGhlIHNjcmVlbiBjYW5ub3QgZW50ZXIgdGhlIHNjcmVlbi5cblx0XHRcdGNvbnN0IGR4ID0gTWF0aC5hYnMoYncgLSBzdykgLyAyO1xuXHRcdFx0eCA9IE1hdGgubWluKE1hdGgubWF4KC1keCwgeCksIGR4KTtcblxuXHRcdFx0Y29uc3QgZHkgPSBNYXRoLmFicyhiaCAtIHNoKSAvIDI7XG5cdFx0XHR5ID0gTWF0aC5taW4oTWF0aC5tYXgoLWR5LCB5KSwgZHkpO1xuXHRcdH1cblxuXHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHR0aGlzLnNvdXJjZSA9IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybShub3cpO1xuXHRcdC8vdGhlIGFuZ2xlIG5lZWRzIHRvIGJlIGludGVycG9sYXRlZCBpbiB0aGUgc2hvcnRlc3QgZGlyZWN0aW9uLlxuXHRcdC8vdGFyZ2V0IGl0IGlzIGtlcHQgYmV0d2VlbiAwIGFuZCArMzYwLCBzb3VyY2UgaXMga2VwdCByZWxhdGl2ZS5cblx0XHRhID0gVHJhbnNmb3JtLm5vcm1hbGl6ZUFuZ2xlKGEpO1xuXHRcdHRoaXMuc291cmNlLmEgPSBUcmFuc2Zvcm0ubm9ybWFsaXplQW5nbGUodGhpcy5zb3VyY2UuYSk7XG5cdFx0aWYgKGEgLSB0aGlzLnNvdXJjZS5hID4gMTgwKSB0aGlzLnNvdXJjZS5hICs9IDM2MDtcblx0XHRpZiAodGhpcy5zb3VyY2UuYSAtIGEgPiAxODApIHRoaXMuc291cmNlLmEgLT0gMzYwO1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcy50YXJnZXQsIHsgeDogeCwgeTogeSwgejogeiwgYTogYSwgdDogbm93ICsgZHQgfSk7XG5cdFx0dGhpcy5lbWl0KCd1cGRhdGUnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYW4gdGhlIGNhbWVyYSAoaW4gY2FudmFzIGNvb3Jkcylcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR0IFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkeCBUaGUgaG9yaXpvbnRhbCBkaXNwbGFuY2VtZW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHkgVGhlIHZlcnRpY2FsIGRpc3BsYWNlbWVudC4gXG5cdCAqL1xuXHRwYW4oZHQsIGR4LCBkeSkge1xuXHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgbSA9IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybShub3cpO1xuXHRcdG0ueCArPSBkeDtcblx0XHRtLnkgKz0gZHk7XG5cdFx0dGhpcy5zZXRQb3NpdGlvbihkdCwgbS54LCBtLnksIG0ueiwgbS5hKTtcblx0fVxuXG5cdC8qKiBab29tIGluIG9yIG91dCBhdCBhIHNwZWNpZmljIHBvaW50IChpbiBjYW52YXMgY29vcmRzKVxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHQgVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIGRpc3RhbmNlIG9mIHRoZSBjYW1lcmEgZnJvbSB0aGUgY2FudmFzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeCBjb29yZCB0byB6b29tIGlufG91dFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBjb29yZCB0byB6b29tIGlufG91dFxuXHQgKi9cblx0em9vbShkdCwgeiwgeCwgeSkge1xuXHRcdGlmICgheCkgeCA9IDA7XG5cdFx0aWYgKCF5KSB5ID0gMDtcblxuXHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgbSA9IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybShub3cpO1xuXG5cdFx0aWYgKHRoaXMuYm91bmRlZCkge1xuXHRcdFx0eiA9IE1hdGgubWluKE1hdGgubWF4KHosIHRoaXMubWluWm9vbSksIHRoaXMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0Ly94LCBhbiB5IHNob3VsZCBiZSB0aGUgY2VudGVyIG9mIHRoZSB6b29tLlxuXHRcdG0ueCArPSAobS54ICsgeCkgKiAobS56IC0geikgLyBtLno7XG5cdFx0bS55ICs9IChtLnkgKyB5KSAqIChtLnogLSB6KSAvIG0uejtcblxuXHRcdHRoaXMuc2V0UG9zaXRpb24oZHQsIG0ueCwgbS55LCB6LCBtLmEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZSB0aGUgY2FtZXJhIGFyb3VuZCBpdHMgei1heGlzIGJ5IGFuIGBhYCBhbmdsZSAoaW4gZGVncmVlcykgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdCBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kLlxuXHQgKiBAcGFyYW0ge2FuZ2xlfSBhIFRoZSByb3RhdGlvbiBhbmdsZSAoaW4gZGVncmVlcykuXG5cdCAqL1xuXHRyb3RhdGUoZHQsIGEpIHtcblxuXHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgbSA9IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybShub3cpO1xuXG5cdFx0dGhpcy5zZXRQb3NpdGlvbihkdCwgbS54LCBtLnksIG0ueiwgdGhpcy50YXJnZXQuYSArIGEpO1xuXHR9XG5cblx0LyoqIFpvb20gaW4gb3Igb3V0IGF0IGEgc3BlY2lmaWMgcG9pbnQgKGluIGNhbnZhcyBjb29yZHMpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdCBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHogVGhlIHNjcm9sbCBhbW91bnQgZm9yIHRoZSB6LWF4aXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4PTAgVGhlIHggY29vcmQgdG8gem9vbSBpbnxvdXRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHk9MCBUaGUgeSBjb29yZCB0byB6b29tIGlufG91dFxuXHQgKi9cblx0ZGVsdGFab29tKGR0LCBkeiwgeD0wLCB5PTApIHtcblxuXHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgbSA9IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybShub3cpO1xuXG5cdFx0Ly9yYXBpZCBmaXJpbmcgd2hlZWwgZXZlbnQgbmVlZCB0byBjb21wb3VuZC5cblx0XHQvL2J1dCB0aGUgeCwgeSBpbiBpbnB1dCBhcmUgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgdHJhbnNmb3JtLlxuXHRcdGR6ICo9IHRoaXMudGFyZ2V0LnogLyBtLno7XG5cblx0XHRpZiAodGhpcy5ib3VuZGVkKSB7XG5cdFx0XHRpZiAobS56ICogZHogPCB0aGlzLm1pblpvb20pIGR6ID0gdGhpcy5taW5ab29tIC8gbS56O1xuXHRcdFx0aWYgKG0ueiAqIGR6ID4gdGhpcy5tYXhab29tKSBkeiA9IHRoaXMubWF4Wm9vbSAvIG0uejtcblx0XHR9XG5cblx0XHQvL3RyYW5zZm9ybSBpcyB4KnogKyBkeCA9IFggLCB0aGVyZSB4IGlzIHBvc2l0cmlvbiBpbiBzY2VuZSwgWCBvbiBzY3JlZW5cblx0XHQvL3dlIHdhbnQgeCp6KmR6ICsgZHgxID0gWCAoc3RheSBwdXQsIHdlIG5lZWQgdG8gZmluZCBkeDEuXG5cdFx0bGV0IHIgPSBUcmFuc2Zvcm0ucm90YXRlKHgsIHksIG0uYSk7XG5cdFx0bS54ICs9IHIueCAqIG0ueiAqICgxIC0gZHopO1xuXHRcdG0ueSArPSByLnkgKiBtLnogKiAoMSAtIGR6KTtcblxuXHRcdHRoaXMuc2V0UG9zaXRpb24oZHQsIG0ueCwgbS55LCBtLnogKiBkeiwgbS5hKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjYW1lcmEgdHJhbnNmb3JtIGF0IGB0aW1lYCBpbiBjYW52YXMgY29vcmRzLlxuXHQgKiBAcGFyYW0ge3RpbWV9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSAoYSBET01IaWdoUmVzVGltZVN0YW1wIHZhcmlhYmxlLCBhcyBpbiBgcGVyZm9ybWFuY2Uubm93KClgKS5cblx0ICogQHJldHVybnMge1RyYW5zZm9ybX0gVGhlIGN1cnJlbnQgdHJhbnNmb3JtXG5cdCAqL1xuXHRnZXRDdXJyZW50VHJhbnNmb3JtKHRpbWUpIHtcblx0XHRpZih0aW1lID4gdGhpcy50YXJnZXQudCkgdGhpcy5lYXNpbmcgPSAnbGluZWFyJztcblx0XHRyZXR1cm4gVHJhbnNmb3JtLmludGVycG9sYXRlKHRoaXMuc291cmNlLCB0aGlzLnRhcmdldCwgdGltZSwgdGhpcy5lYXNpbmcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGNhbWVyYSB0cmFuc2Zvcm0gYXQgYHRpbWVgIGluIGRldmljZSBjb29yZHMuXG5cdCAqIEBwYXJhbSB7dGltZX0gdGltZSBUaGUgY3VycmVudCB0aW1lIChhIERPTUhpZ2hSZXNUaW1lU3RhbXAgdmFyaWFibGUsIGFzIGluIGBwZXJmb3JtYW5jZS5ub3coKWApLlxuXHQgKiBAcmV0dXJucyB7VHJhbnNmb3JtfSBUaGUgY3VycmVudCB0cmFuc2Zvcm1cblx0ICovXG5cdCBnZXRHbEN1cnJlbnRUcmFuc2Zvcm0odGltZSkge1xuXHRcdGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybSh0aW1lKTtcblx0XHRwb3MueCAqPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0XHRwb3MueSAqPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0XHRwb3MueiAqPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0XHRyZXR1cm4gcG9zO1xuXHR9XG5cblxuXHQvKipcblx0ICogTW9kaWZ5IHRoZSBjYW1lcmEgc2V0dGluZ3MgdG8gZnJhbWUgdGhlIHNwZWNpZmllZCBgYm94YCBcblx0ICogQHBhcmFtIHtCb3VuZGluZ0JveH0gYm94IFRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlIFttaW54LCBtaW55LCBtYXh4LCBtYXh5XSBpbiB0aGUgY2FudmFzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHQgVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZCBcblx0ICovXG5cdGZpdChib3gsIGR0KSB7XG5cdFx0aWYgKGJveC5pc0VtcHR5KCkpIHJldHVybjtcblx0XHRpZiAoIWR0KSBkdCA9IDA7XG5cblx0XHQvL2ZpbmQgaWYgd2UgYWxpZ24gdGhlIHRvcGJvdHRvbSBib3JkZXJzIG9yIHRoZSBsZWZ0cmlnaHQgYm9yZGVyLlxuXHRcdGxldCB3ID0gdGhpcy52aWV3cG9ydC5keDtcblx0XHRsZXQgaCA9IHRoaXMudmlld3BvcnQuZHk7XG5cblx0XHRsZXQgYncgPSBib3gud2lkdGgoKTtcblx0XHRsZXQgYmggPSBib3guaGVpZ2h0KCk7XG5cdFx0bGV0IGMgPSBib3guY2VudGVyKCk7XG5cdFx0bGV0IHogPSBNYXRoLm1pbih3IC8gYncsIGggLyBiaCk7XG5cblx0XHR0aGlzLnNldFBvc2l0aW9uKGR0LCAtY1swXSwgLWNbMV0sIHosIDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1vZGlmeSB0aGUgY2FtZXJhIHNldHRpbmdzIHRvIHRoZSBmYWN0b3J5IHZhbHVlcyAoaG9tZSkuIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHQgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kXG5cdCAqL1xuXHRmaXRDYW1lcmFCb3goZHQpIHtcblx0XHR0aGlzLmZpdCh0aGlzLmJvdW5kaW5nQm94LCBkdCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR1cGRhdGVCb3VuZHMoYm94LCBtaW5TY2FsZSkge1xuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3g7XG5cdFx0Y29uc3QgdyA9IHRoaXMudmlld3BvcnQuZHg7XG5cdFx0Y29uc3QgaCA9IHRoaXMudmlld3BvcnQuZHk7XG5cblx0XHRsZXQgYncgPSB0aGlzLmJvdW5kaW5nQm94LndpZHRoKCk7XG5cdFx0bGV0IGJoID0gdGhpcy5ib3VuZGluZ0JveC5oZWlnaHQoKTtcblxuXHRcdHRoaXMubWluWm9vbSA9IE1hdGgubWluKHcgLyBidywgaCAvIGJoKSAqIHRoaXMubWluU2NyZWVuRnJhY3Rpb247XG5cdFx0dGhpcy5tYXhab29tID0gbWluU2NhbGUgPiAwID8gdGhpcy5tYXhGaXhlZFpvb20gLyBtaW5TY2FsZSA6IHRoaXMubWF4Rml4ZWRab29tO1xuXHRcdHRoaXMubWF4Wm9vbSA9IE1hdGgubWF4KHRoaXMubWluWm9vbSwgdGhpcy5tYXhab29tKTtcblx0fVxufVxuXG5hZGRTaWduYWxzKENhbWVyYSwgJ3VwZGF0ZScpO1xuXG5leHBvcnQgeyBDYW1lcmEgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Camera.js\n");

/***/ }),

/***/ "./src/Canvas.js":
/*!***********************!*\
  !*** ./src/Canvas.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Canvas\": () => (/* binding */ Canvas)\n/* harmony export */ });\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ \"./src/Util.js\");\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Camera */ \"./src/Camera.js\");\n/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Layer */ \"./src/Layer.js\");\n/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Cache */ \"./src/Cache.js\");\n/* harmony import */ var _Signals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signals */ \"./src/Signals.js\");\n\n\n\n\n\n\n//// HELPERS\n\nwindow.structuredClone = typeof(structuredClone) == \"function\" ? structuredClone : function (value) { return  JSON.parse(JSON.stringify(value)); };\n\n\n/**\n * Creates the WebGL context for the `canvas`. It stores information related to the `overlay` DOM element and the `camera` of the scene.\n * Signals are triggered in case of scene modifications.\n * Additionally, an object literal with Canvas `options` can be specified.\n * @param {(element|string)} canvas DOM element or selector for a `<canvas>`.\n * @param {(element|string)} overlay DOM element or selector for overlay decorations (i.e. annotations, glyphs, etc...)\n * @param {Camera} camera  The scene's camera.\n * @param {Object} [options] An object literal.\n * @param {Object} options.layers Object specifies layers (see. {@link Layer})\n * @param {bool} options.preserveDrawingBuffer=false Whether to preserve the buffers until manually cleared or overwritten. Needed for screenshots \n * (otherwise is just a performance penalty).\n * \n*/\n\nclass Canvas {\n\n\tconstructor(canvas, overlay, camera, options) {\n\t\tObject.assign(this, { \n\t\t\tcanvasElement: null,\n\t\t\tpreserveDrawingBuffer: false, \n\t\t\tgl: null,\n\t\t\toverlayElement: null,\n\t\t\tcamera: camera,\n\t\t\tlayers: {},\n\t\t\tsignals: {'update':[], 'updateSize':[], 'ready': []}\n\t\t});\n\t\tObject.assign(this, options);\n\n\t\tthis.init(canvas, overlay);\n\t\t\t\n\t\tfor(let id in this.layers)\n\t\t\tthis.addLayer(id, new _Layer__WEBPACK_IMPORTED_MODULE_2__.Layer(this.layers[id]));\n\t\tthis.camera.addEvent('update', () => this.emit('update'));\n\t}\n\n\t/*\n \t* Adds a Canvas Event\n \t* @param {*} event A label to identify the event.\n \t* @param {*} callback The event callback function.\n \t*/\n\n\n\n\t/** @ignore */\n\tinit(canvas, overlay) {\n\t\tif(!canvas)\n\t\t\tthrow \"Missing element parameter\"\n\n\t\tif(typeof(canvas) == 'string') {\n\t\t\tcanvas = document.querySelector(canvas);\n\t\t\tif(!canvas)\n\t\t\t\tthrow \"Could not find dom element.\";\n\t\t}\n\n\t\tif(!overlay)\n\t\t\tthrow \"Missing element parameter\"\n\n\t\tif(typeof(overlay) == 'string') {\n\t\t\toverlay = document.querySelector(overlay);\n\t\t\tif(!overlay)\n\t\t\t\tthrow \"Could not find dom element.\";\n\t\t}\n\n\t\tif(!canvas.tagName)\n\t\t\tthrow \"Element is not a DOM element\"\n\n\t\tif(canvas.tagName != \"CANVAS\")\n\t\t\tthrow \"Element is not a canvas element\";\n\n\t\tthis.canvasElement = canvas;\n\t\tthis.overlayElement = overlay;\n\n\t\t/* test context loss */\n\t\t/* canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas);\n\t\tcanvas.loseContextInNCalls(1000); */\n\n\n\t\tlet glopt = { antialias: false, depth: false, preserveDrawingBuffer: this.preserveDrawingBuffer };\n\t\tthis.gl = this.gl || \n\t\t\tcanvas.getContext(\"webgl2\", glopt) || \n\t\t\tcanvas.getContext(\"webgl\", glopt) || \n\t\t\tcanvas.getContext(\"experimental-webgl\", glopt) ;\n\n\t\tif (!this.gl)\n\t\t\tthrow \"Could not create a WebGL context\";\n\n\t\tcanvas.addEventListener(\"webglcontextlost\", (event) => { console.log(\"Context lost.\"); event.preventDefault(); }, false);\n\t\tcanvas.addEventListener(\"webglcontextrestored\", ()  => { this.restoreWebGL(); }, false);\n\t\tdocument.addEventListener(\"visibilitychange\", (event) => { if(this.gl.isContextLost()) { this.restoreWebGL(); }});\n\t}\n\n\t/**\n\t * Sets the state variables of all the system\n\t * @param {Object} state An object with state variables.\n\t * @param {number} dt The animation duration in millisecond.\n\t * @param {Easing} easing The function aimed at making the camera movement or control adjustments less severe or pronounced.\n\t */\n\tsetState(state, dt, easing = 'linear') {\n\t\tif ('camera' in state) {\n\t\t\tconst m = state.camera;\n\t\t\tthis.camera.setPosition(dt, m.x, m.y, m.z, m.a, easing);\n\t\t}\n\t\tif ('layers' in state)\n\t\t\tfor (const [k, layerState] of Object.entries(state.layers))\n\t\t\t\tif (k in this.layers) {\n\t\t\t\t\tconst layer = this.layers[k];\n\t\t\t\t\tlayer.setState(layerState, dt, easing);\n\t\t\t\t}\n\t}\n\n\t/**\n\t * Gets the state variables of all the system as described in the stateMask\n\t * @return {Object} An object with state variables.\n\t */\n\tgetState(stateMask=null) {\n\t\tlet state = {};\n\t\tif (!stateMask || stateMask.camera) {\n\t\t\tlet now = performance.now();\n\t\t\tlet m = this.camera.getCurrentTransform(now);\n\t\t\tstate.camera = { 'x': m.x, 'y': m.y, 'z': m.z, 'a': m.a };\n\t\t}\n\t\tstate.layers = {};\n\t\tfor (let layer of Object.values(this.layers)) {\n\t\t\tconst layerMask = window.structuredClone(stateMask);\n\t\t\tif (stateMask && stateMask.layers) Object.assign(layerMask, stateMask.layers[layer.id]);\n\t\t\tstate.layers[layer.id] = layer.getState(layerMask);\n\t\t}\n\t\treturn state;\n\t}\n\n\t/** @ignore */\n\trestoreWebGL() {\n\t\tlet glopt = { antialias: false, depth: false, preserveDrawingBuffer: this.preserveDrawingBuffer };\n\t\tthis.gl = this.gl || \n\t\t\tthis.canvasElement.getContext(\"webgl2\", glopt) || \n\t\t\tthis.canvasElement.getContext(\"webgl\", glopt) || \n\t\t\tthis.canvasElement.getContext(\"experimental-webgl\", glopt) ;\n\n\t\tfor(let layer of Object.values(this.layers)) {\n\t\t\tlayer.gl = this.gl;\n\t\t\tlayer.clear();\n\t\t\tif(layer.shader)\n\t\t\t\tlayer.shader.restoreWebGL(this.gl);\n\t\t}\n\t\tthis.prefetch();\n\t\tthis.emit('update');\n\t}\n\n    /** Adds the given layer to the Canvas and connects the layer's events to it.\n    * @param {string} id A label to identify the layer.\n    * @param {Layer} layer An OpenLIME Layer object.\n    */\n\t addLayer(id, layer) {\n\t\t/**\n\t\t* The event is fired if a layer is updated, added or removed.\n\t\t* @event Canvas#update\n\t\t*/\n\n\t\t/** \n\t\t* The event is fired when all the layers are ready (i.e. initialized and with data ready to be displayed).\n\t\t* @event Canvas#ready\n\t\t*/\n\n\t\tconsole.assert(!(id in this.layers), \"Duplicated layer id\");\n\n\t\tlayer.id = id;\n\t\tlayer.addEvent('ready', () => { \n\t\t\tif(Object.values(this.layers).every( l => l.status == 'ready'))\n\t\t\t\tthis.emit('ready');\n\t\t\tthis.prefetch();\n\t\t});\n\t\tlayer.addEvent('update', () => { this.emit('update'); });\n\t\tlayer.addEvent('updateSize', () => { this.updateSize(); });\n\t\tlayer.gl = this.gl;\n\t\tlayer.overlayElement = this.overlayElement;\n\t\tthis.layers[id] = layer;\n\t\tthis.prefetch();\n\t}\n\n    /** Remove the given layer from the Canvas\n    * @param {Layer} layer An OpenLIME Layer object.\n\t* \n\t* @example\n\t* let layer0 = new Layer(options);\n\t* canvas.addLayer('kdmap', layer0);\n    * ...\n\t* canvas.removeLayer(layer0);\n    */\n\tremoveLayer(layer) {\n\t\tlayer.clear(); //order is important.\n\n\t\tdelete this.layers[layer.id];\n\t\tdelete _Cache__WEBPACK_IMPORTED_MODULE_3__.Cache.layers[layer];\n\t\tthis.prefetch();\n\t}\n\n\t/** @ignore */\n\tupdateSize() {\n\t\t/**\n \t\t* The event is fired if a layout changes its size or position (the event forces the re-computation of the layer bounding boxes).\n \t\t* @event Canvas#updateSize\n \t\t*/\n\t\tconst discardHidden = true;\n\t\tlet sceneBBox = _Layer__WEBPACK_IMPORTED_MODULE_2__.Layer.computeLayersBBox(this.layers, discardHidden);\n\t\tlet minScale =  _Layer__WEBPACK_IMPORTED_MODULE_2__.Layer.computeLayersMinScale(this.layers, discardHidden);\n\t\t\n\t\tif (sceneBBox != null) this.camera.updateBounds(sceneBBox, minScale);\n\t\tthis.emit('updateSize');\n\t}\n\n\t/** @ignore */\n\tdraw(time) {\n\t\tlet gl = this.gl;\n\t\tlet view = this.camera.glViewport();\n\t\tgl.viewport(view.x, view.y, view.dx, view.dy);\n\n\t\tvar b = [0, 0, 0, 0];\n\t\tgl.clearColor(b[0], b[1], b[2], b[3], b[4]);\n\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\t\tgl.enable(gl.BLEND);\n\n\t\t//TODO: getCurren shoudl redurn {position, done}\n\t\tlet pos = this.camera.getGlCurrentTransform(time);\n\t\t//todo we could actually prefetch toward the future a little bit\n\t\tthis.prefetch(pos);\n\n\t\t//pos layers using zindex.\n\t\tlet ordered = Object.values(this.layers).sort( (a, b) => a.zindex - b.zindex);\n\n\t\t//NOTICE: camera(pos) must be relative to the WHOLE canvas\n\t\tlet done = true;\n\t\tfor(let layer of ordered) {\n\t\t\tif(layer.visible)\n\t\t\t\tdone = layer.draw(pos, view) && done;\n\t\t}\n\n\t\t//TODO not really an elegant solution to tell if we have reached the target, the check should be in getCurrentTransform.\n\t\treturn done && pos.t >= this.camera.target.t;\n\t}\n\n\t/*\n \t* This function have each layer to check which tiles are needed and schedule them for download.\n \t* @param {object} transform is the camera position (layer will combine with local transform).\n \t*/\n\t/** @ignore */\n\tprefetch(transform) {\n\t\tif(!transform)\n\t\t\ttransform = this.camera.getGlCurrentTransform(performance.now());\n\t\tfor(let id in this.layers) {\n\t\t\tlet layer = this.layers[id];\n\t\t\t//console.log(layer);\n\t\t\t//console.log(layer.layout.status);\n\t\t\tif(layer.visible && layer.status == 'ready') {\n\t\t\t\tlayer.prefetch(transform, this.camera.glViewport());\n\t\t\t}\n\t\t}\n\t}\n}\n\n(0,_Signals__WEBPACK_IMPORTED_MODULE_4__.addSignals)(Canvas, 'update', 'updateSize', 'ready');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ2FudmFzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2QjtBQUNJO0FBQ0Q7QUFDRDtBQUNPOztBQUV0Qzs7QUFFQSxzR0FBc0c7OztBQUd0RztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLDhDQUE4QyxZQUFZO0FBQzdFLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQUs7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsWUFBWSxHQUFHO0FBQ2Y7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DOzs7QUFHcEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkRBQTJELDhCQUE4Qix5QkFBeUI7QUFDbEgsMkRBQTJELHNCQUFzQjtBQUNqRiw2REFBNkQsOEJBQThCLHVCQUF1QjtBQUNsSDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQ0FBbUMsc0JBQXNCO0FBQ3pELHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLFNBQVMsZ0RBQVk7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBdUI7QUFDekMsa0JBQWtCLCtEQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFVOztBQUVPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvQ2FudmFzLmpzP2E5YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbCdcbmltcG9ydCB7IENhbWVyYSB9IGZyb20gJy4vQ2FtZXJhJ1xuaW1wb3J0IHsgTGF5ZXIgIH0gZnJvbSAnLi9MYXllcidcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9DYWNoZSdcbmltcG9ydCB7IGFkZFNpZ25hbHMgfSBmcm9tICcuL1NpZ25hbHMnXG5cbi8vLy8gSEVMUEVSU1xuXG53aW5kb3cuc3RydWN0dXJlZENsb25lID0gdHlwZW9mKHN0cnVjdHVyZWRDbG9uZSkgPT0gXCJmdW5jdGlvblwiID8gc3RydWN0dXJlZENsb25lIDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpOyB9O1xuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgV2ViR0wgY29udGV4dCBmb3IgdGhlIGBjYW52YXNgLiBJdCBzdG9yZXMgaW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgYG92ZXJsYXlgIERPTSBlbGVtZW50IGFuZCB0aGUgYGNhbWVyYWAgb2YgdGhlIHNjZW5lLlxuICogU2lnbmFscyBhcmUgdHJpZ2dlcmVkIGluIGNhc2Ugb2Ygc2NlbmUgbW9kaWZpY2F0aW9ucy5cbiAqIEFkZGl0aW9uYWxseSwgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBDYW52YXMgYG9wdGlvbnNgIGNhbiBiZSBzcGVjaWZpZWQuXG4gKiBAcGFyYW0geyhlbGVtZW50fHN0cmluZyl9IGNhbnZhcyBET00gZWxlbWVudCBvciBzZWxlY3RvciBmb3IgYSBgPGNhbnZhcz5gLlxuICogQHBhcmFtIHsoZWxlbWVudHxzdHJpbmcpfSBvdmVybGF5IERPTSBlbGVtZW50IG9yIHNlbGVjdG9yIGZvciBvdmVybGF5IGRlY29yYXRpb25zIChpLmUuIGFubm90YXRpb25zLCBnbHlwaHMsIGV0Yy4uLilcbiAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgIFRoZSBzY2VuZSdzIGNhbWVyYS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGxpdGVyYWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5sYXllcnMgT2JqZWN0IHNwZWNpZmllcyBsYXllcnMgKHNlZS4ge0BsaW5rIExheWVyfSlcbiAqIEBwYXJhbSB7Ym9vbH0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI9ZmFsc2UgV2hldGhlciB0byBwcmVzZXJ2ZSB0aGUgYnVmZmVycyB1bnRpbCBtYW51YWxseSBjbGVhcmVkIG9yIG92ZXJ3cml0dGVuLiBOZWVkZWQgZm9yIHNjcmVlbnNob3RzIFxuICogKG90aGVyd2lzZSBpcyBqdXN0IGEgcGVyZm9ybWFuY2UgcGVuYWx0eSkuXG4gKiBcbiovXG5cbmNsYXNzIENhbnZhcyB7XG5cblx0Y29uc3RydWN0b3IoY2FudmFzLCBvdmVybGF5LCBjYW1lcmEsIG9wdGlvbnMpIHtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHsgXG5cdFx0XHRjYW52YXNFbGVtZW50OiBudWxsLFxuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSwgXG5cdFx0XHRnbDogbnVsbCxcblx0XHRcdG92ZXJsYXlFbGVtZW50OiBudWxsLFxuXHRcdFx0Y2FtZXJhOiBjYW1lcmEsXG5cdFx0XHRsYXllcnM6IHt9LFxuXHRcdFx0c2lnbmFsczogeyd1cGRhdGUnOltdLCAndXBkYXRlU2l6ZSc6W10sICdyZWFkeSc6IFtdfVxuXHRcdH0pO1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cblx0XHR0aGlzLmluaXQoY2FudmFzLCBvdmVybGF5KTtcblx0XHRcdFxuXHRcdGZvcihsZXQgaWQgaW4gdGhpcy5sYXllcnMpXG5cdFx0XHR0aGlzLmFkZExheWVyKGlkLCBuZXcgTGF5ZXIodGhpcy5sYXllcnNbaWRdKSk7XG5cdFx0dGhpcy5jYW1lcmEuYWRkRXZlbnQoJ3VwZGF0ZScsICgpID0+IHRoaXMuZW1pdCgndXBkYXRlJykpO1xuXHR9XG5cblx0LypcbiBcdCogQWRkcyBhIENhbnZhcyBFdmVudFxuIFx0KiBAcGFyYW0geyp9IGV2ZW50IEEgbGFiZWwgdG8gaWRlbnRpZnkgdGhlIGV2ZW50LlxuIFx0KiBAcGFyYW0geyp9IGNhbGxiYWNrIFRoZSBldmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbiBcdCovXG5cblxuXG5cdC8qKiBAaWdub3JlICovXG5cdGluaXQoY2FudmFzLCBvdmVybGF5KSB7XG5cdFx0aWYoIWNhbnZhcylcblx0XHRcdHRocm93IFwiTWlzc2luZyBlbGVtZW50IHBhcmFtZXRlclwiXG5cblx0XHRpZih0eXBlb2YoY2FudmFzKSA9PSAnc3RyaW5nJykge1xuXHRcdFx0Y2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihjYW52YXMpO1xuXHRcdFx0aWYoIWNhbnZhcylcblx0XHRcdFx0dGhyb3cgXCJDb3VsZCBub3QgZmluZCBkb20gZWxlbWVudC5cIjtcblx0XHR9XG5cblx0XHRpZighb3ZlcmxheSlcblx0XHRcdHRocm93IFwiTWlzc2luZyBlbGVtZW50IHBhcmFtZXRlclwiXG5cblx0XHRpZih0eXBlb2Yob3ZlcmxheSkgPT0gJ3N0cmluZycpIHtcblx0XHRcdG92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG92ZXJsYXkpO1xuXHRcdFx0aWYoIW92ZXJsYXkpXG5cdFx0XHRcdHRocm93IFwiQ291bGQgbm90IGZpbmQgZG9tIGVsZW1lbnQuXCI7XG5cdFx0fVxuXG5cdFx0aWYoIWNhbnZhcy50YWdOYW1lKVxuXHRcdFx0dGhyb3cgXCJFbGVtZW50IGlzIG5vdCBhIERPTSBlbGVtZW50XCJcblxuXHRcdGlmKGNhbnZhcy50YWdOYW1lICE9IFwiQ0FOVkFTXCIpXG5cdFx0XHR0aHJvdyBcIkVsZW1lbnQgaXMgbm90IGEgY2FudmFzIGVsZW1lbnRcIjtcblxuXHRcdHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhcztcblx0XHR0aGlzLm92ZXJsYXlFbGVtZW50ID0gb3ZlcmxheTtcblxuXHRcdC8qIHRlc3QgY29udGV4dCBsb3NzICovXG5cdFx0LyogY2FudmFzID0gV2ViR0xEZWJ1Z1V0aWxzLm1ha2VMb3N0Q29udGV4dFNpbXVsYXRpbmdDYW52YXMoY2FudmFzKTtcblx0XHRjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscygxMDAwKTsgKi9cblxuXG5cdFx0bGV0IGdsb3B0ID0geyBhbnRpYWxpYXM6IGZhbHNlLCBkZXB0aDogZmFsc2UsIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgfTtcblx0XHR0aGlzLmdsID0gdGhpcy5nbCB8fCBcblx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIGdsb3B0KSB8fCBcblx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgZ2xvcHQpIHx8IFxuXHRcdFx0Y2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgZ2xvcHQpIDtcblxuXHRcdGlmICghdGhpcy5nbClcblx0XHRcdHRocm93IFwiQ291bGQgbm90IGNyZWF0ZSBhIFdlYkdMIGNvbnRleHRcIjtcblxuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCAoZXZlbnQpID0+IHsgY29uc29sZS5sb2coXCJDb250ZXh0IGxvc3QuXCIpOyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCAoKSAgPT4geyB0aGlzLnJlc3RvcmVXZWJHTCgpOyB9LCBmYWxzZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgKGV2ZW50KSA9PiB7IGlmKHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpKSB7IHRoaXMucmVzdG9yZVdlYkdMKCk7IH19KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzdGF0ZSB2YXJpYWJsZXMgb2YgYWxsIHRoZSBzeXN0ZW1cblx0ICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIEFuIG9iamVjdCB3aXRoIHN0YXRlIHZhcmlhYmxlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGR0IFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmQuXG5cdCAqIEBwYXJhbSB7RWFzaW5nfSBlYXNpbmcgVGhlIGZ1bmN0aW9uIGFpbWVkIGF0IG1ha2luZyB0aGUgY2FtZXJhIG1vdmVtZW50IG9yIGNvbnRyb2wgYWRqdXN0bWVudHMgbGVzcyBzZXZlcmUgb3IgcHJvbm91bmNlZC5cblx0ICovXG5cdHNldFN0YXRlKHN0YXRlLCBkdCwgZWFzaW5nID0gJ2xpbmVhcicpIHtcblx0XHRpZiAoJ2NhbWVyYScgaW4gc3RhdGUpIHtcblx0XHRcdGNvbnN0IG0gPSBzdGF0ZS5jYW1lcmE7XG5cdFx0XHR0aGlzLmNhbWVyYS5zZXRQb3NpdGlvbihkdCwgbS54LCBtLnksIG0ueiwgbS5hLCBlYXNpbmcpO1xuXHRcdH1cblx0XHRpZiAoJ2xheWVycycgaW4gc3RhdGUpXG5cdFx0XHRmb3IgKGNvbnN0IFtrLCBsYXllclN0YXRlXSBvZiBPYmplY3QuZW50cmllcyhzdGF0ZS5sYXllcnMpKVxuXHRcdFx0XHRpZiAoayBpbiB0aGlzLmxheWVycykge1xuXHRcdFx0XHRcdGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNba107XG5cdFx0XHRcdFx0bGF5ZXIuc2V0U3RhdGUobGF5ZXJTdGF0ZSwgZHQsIGVhc2luZyk7XG5cdFx0XHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzdGF0ZSB2YXJpYWJsZXMgb2YgYWxsIHRoZSBzeXN0ZW0gYXMgZGVzY3JpYmVkIGluIHRoZSBzdGF0ZU1hc2tcblx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBzdGF0ZSB2YXJpYWJsZXMuXG5cdCAqL1xuXHRnZXRTdGF0ZShzdGF0ZU1hc2s9bnVsbCkge1xuXHRcdGxldCBzdGF0ZSA9IHt9O1xuXHRcdGlmICghc3RhdGVNYXNrIHx8IHN0YXRlTWFzay5jYW1lcmEpIHtcblx0XHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGxldCBtID0gdGhpcy5jYW1lcmEuZ2V0Q3VycmVudFRyYW5zZm9ybShub3cpO1xuXHRcdFx0c3RhdGUuY2FtZXJhID0geyAneCc6IG0ueCwgJ3knOiBtLnksICd6JzogbS56LCAnYSc6IG0uYSB9O1xuXHRcdH1cblx0XHRzdGF0ZS5sYXllcnMgPSB7fTtcblx0XHRmb3IgKGxldCBsYXllciBvZiBPYmplY3QudmFsdWVzKHRoaXMubGF5ZXJzKSkge1xuXHRcdFx0Y29uc3QgbGF5ZXJNYXNrID0gd2luZG93LnN0cnVjdHVyZWRDbG9uZShzdGF0ZU1hc2spO1xuXHRcdFx0aWYgKHN0YXRlTWFzayAmJiBzdGF0ZU1hc2subGF5ZXJzKSBPYmplY3QuYXNzaWduKGxheWVyTWFzaywgc3RhdGVNYXNrLmxheWVyc1tsYXllci5pZF0pO1xuXHRcdFx0c3RhdGUubGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyLmdldFN0YXRlKGxheWVyTWFzayk7XG5cdFx0fVxuXHRcdHJldHVybiBzdGF0ZTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHJlc3RvcmVXZWJHTCgpIHtcblx0XHRsZXQgZ2xvcHQgPSB7IGFudGlhbGlhczogZmFsc2UsIGRlcHRoOiBmYWxzZSwgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciB9O1xuXHRcdHRoaXMuZ2wgPSB0aGlzLmdsIHx8IFxuXHRcdFx0dGhpcy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgZ2xvcHQpIHx8IFxuXHRcdFx0dGhpcy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoXCJ3ZWJnbFwiLCBnbG9wdCkgfHwgXG5cdFx0XHR0aGlzLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBnbG9wdCkgO1xuXG5cdFx0Zm9yKGxldCBsYXllciBvZiBPYmplY3QudmFsdWVzKHRoaXMubGF5ZXJzKSkge1xuXHRcdFx0bGF5ZXIuZ2wgPSB0aGlzLmdsO1xuXHRcdFx0bGF5ZXIuY2xlYXIoKTtcblx0XHRcdGlmKGxheWVyLnNoYWRlcilcblx0XHRcdFx0bGF5ZXIuc2hhZGVyLnJlc3RvcmVXZWJHTCh0aGlzLmdsKTtcblx0XHR9XG5cdFx0dGhpcy5wcmVmZXRjaCgpO1xuXHRcdHRoaXMuZW1pdCgndXBkYXRlJyk7XG5cdH1cblxuICAgIC8qKiBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgQ2FudmFzIGFuZCBjb25uZWN0cyB0aGUgbGF5ZXIncyBldmVudHMgdG8gaXQuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBsYWJlbCB0byBpZGVudGlmeSB0aGUgbGF5ZXIuXG4gICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciBBbiBPcGVuTElNRSBMYXllciBvYmplY3QuXG4gICAgKi9cblx0IGFkZExheWVyKGlkLCBsYXllcikge1xuXHRcdC8qKlxuXHRcdCogVGhlIGV2ZW50IGlzIGZpcmVkIGlmIGEgbGF5ZXIgaXMgdXBkYXRlZCwgYWRkZWQgb3IgcmVtb3ZlZC5cblx0XHQqIEBldmVudCBDYW52YXMjdXBkYXRlXG5cdFx0Ki9cblxuXHRcdC8qKiBcblx0XHQqIFRoZSBldmVudCBpcyBmaXJlZCB3aGVuIGFsbCB0aGUgbGF5ZXJzIGFyZSByZWFkeSAoaS5lLiBpbml0aWFsaXplZCBhbmQgd2l0aCBkYXRhIHJlYWR5IHRvIGJlIGRpc3BsYXllZCkuXG5cdFx0KiBAZXZlbnQgQ2FudmFzI3JlYWR5XG5cdFx0Ki9cblxuXHRcdGNvbnNvbGUuYXNzZXJ0KCEoaWQgaW4gdGhpcy5sYXllcnMpLCBcIkR1cGxpY2F0ZWQgbGF5ZXIgaWRcIik7XG5cblx0XHRsYXllci5pZCA9IGlkO1xuXHRcdGxheWVyLmFkZEV2ZW50KCdyZWFkeScsICgpID0+IHsgXG5cdFx0XHRpZihPYmplY3QudmFsdWVzKHRoaXMubGF5ZXJzKS5ldmVyeSggbCA9PiBsLnN0YXR1cyA9PSAncmVhZHknKSlcblx0XHRcdFx0dGhpcy5lbWl0KCdyZWFkeScpO1xuXHRcdFx0dGhpcy5wcmVmZXRjaCgpO1xuXHRcdH0pO1xuXHRcdGxheWVyLmFkZEV2ZW50KCd1cGRhdGUnLCAoKSA9PiB7IHRoaXMuZW1pdCgndXBkYXRlJyk7IH0pO1xuXHRcdGxheWVyLmFkZEV2ZW50KCd1cGRhdGVTaXplJywgKCkgPT4geyB0aGlzLnVwZGF0ZVNpemUoKTsgfSk7XG5cdFx0bGF5ZXIuZ2wgPSB0aGlzLmdsO1xuXHRcdGxheWVyLm92ZXJsYXlFbGVtZW50ID0gdGhpcy5vdmVybGF5RWxlbWVudDtcblx0XHR0aGlzLmxheWVyc1tpZF0gPSBsYXllcjtcblx0XHR0aGlzLnByZWZldGNoKCk7XG5cdH1cblxuICAgIC8qKiBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIENhbnZhc1xuICAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgQW4gT3BlbkxJTUUgTGF5ZXIgb2JqZWN0LlxuXHQqIFxuXHQqIEBleGFtcGxlXG5cdCogbGV0IGxheWVyMCA9IG5ldyBMYXllcihvcHRpb25zKTtcblx0KiBjYW52YXMuYWRkTGF5ZXIoJ2tkbWFwJywgbGF5ZXIwKTtcbiAgICAqIC4uLlxuXHQqIGNhbnZhcy5yZW1vdmVMYXllcihsYXllcjApO1xuICAgICovXG5cdHJlbW92ZUxheWVyKGxheWVyKSB7XG5cdFx0bGF5ZXIuY2xlYXIoKTsgLy9vcmRlciBpcyBpbXBvcnRhbnQuXG5cblx0XHRkZWxldGUgdGhpcy5sYXllcnNbbGF5ZXIuaWRdO1xuXHRcdGRlbGV0ZSBDYWNoZS5sYXllcnNbbGF5ZXJdO1xuXHRcdHRoaXMucHJlZmV0Y2goKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHVwZGF0ZVNpemUoKSB7XG5cdFx0LyoqXG4gXHRcdCogVGhlIGV2ZW50IGlzIGZpcmVkIGlmIGEgbGF5b3V0IGNoYW5nZXMgaXRzIHNpemUgb3IgcG9zaXRpb24gKHRoZSBldmVudCBmb3JjZXMgdGhlIHJlLWNvbXB1dGF0aW9uIG9mIHRoZSBsYXllciBib3VuZGluZyBib3hlcykuXG4gXHRcdCogQGV2ZW50IENhbnZhcyN1cGRhdGVTaXplXG4gXHRcdCovXG5cdFx0Y29uc3QgZGlzY2FyZEhpZGRlbiA9IHRydWU7XG5cdFx0bGV0IHNjZW5lQkJveCA9IExheWVyLmNvbXB1dGVMYXllcnNCQm94KHRoaXMubGF5ZXJzLCBkaXNjYXJkSGlkZGVuKTtcblx0XHRsZXQgbWluU2NhbGUgPSAgTGF5ZXIuY29tcHV0ZUxheWVyc01pblNjYWxlKHRoaXMubGF5ZXJzLCBkaXNjYXJkSGlkZGVuKTtcblx0XHRcblx0XHRpZiAoc2NlbmVCQm94ICE9IG51bGwpIHRoaXMuY2FtZXJhLnVwZGF0ZUJvdW5kcyhzY2VuZUJCb3gsIG1pblNjYWxlKTtcblx0XHR0aGlzLmVtaXQoJ3VwZGF0ZVNpemUnKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGRyYXcodGltZSkge1xuXHRcdGxldCBnbCA9IHRoaXMuZ2w7XG5cdFx0bGV0IHZpZXcgPSB0aGlzLmNhbWVyYS5nbFZpZXdwb3J0KCk7XG5cdFx0Z2wudmlld3BvcnQodmlldy54LCB2aWV3LnksIHZpZXcuZHgsIHZpZXcuZHkpO1xuXG5cdFx0dmFyIGIgPSBbMCwgMCwgMCwgMF07XG5cdFx0Z2wuY2xlYXJDb2xvcihiWzBdLCBiWzFdLCBiWzJdLCBiWzNdLCBiWzRdKTtcblx0XHRnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcblxuXHRcdGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXHRcdGdsLmVuYWJsZShnbC5CTEVORCk7XG5cblx0XHQvL1RPRE86IGdldEN1cnJlbiBzaG91ZGwgcmVkdXJuIHtwb3NpdGlvbiwgZG9uZX1cblx0XHRsZXQgcG9zID0gdGhpcy5jYW1lcmEuZ2V0R2xDdXJyZW50VHJhbnNmb3JtKHRpbWUpO1xuXHRcdC8vdG9kbyB3ZSBjb3VsZCBhY3R1YWxseSBwcmVmZXRjaCB0b3dhcmQgdGhlIGZ1dHVyZSBhIGxpdHRsZSBiaXRcblx0XHR0aGlzLnByZWZldGNoKHBvcyk7XG5cblx0XHQvL3BvcyBsYXllcnMgdXNpbmcgemluZGV4LlxuXHRcdGxldCBvcmRlcmVkID0gT2JqZWN0LnZhbHVlcyh0aGlzLmxheWVycykuc29ydCggKGEsIGIpID0+IGEuemluZGV4IC0gYi56aW5kZXgpO1xuXG5cdFx0Ly9OT1RJQ0U6IGNhbWVyYShwb3MpIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIFdIT0xFIGNhbnZhc1xuXHRcdGxldCBkb25lID0gdHJ1ZTtcblx0XHRmb3IobGV0IGxheWVyIG9mIG9yZGVyZWQpIHtcblx0XHRcdGlmKGxheWVyLnZpc2libGUpXG5cdFx0XHRcdGRvbmUgPSBsYXllci5kcmF3KHBvcywgdmlldykgJiYgZG9uZTtcblx0XHR9XG5cblx0XHQvL1RPRE8gbm90IHJlYWxseSBhbiBlbGVnYW50IHNvbHV0aW9uIHRvIHRlbGwgaWYgd2UgaGF2ZSByZWFjaGVkIHRoZSB0YXJnZXQsIHRoZSBjaGVjayBzaG91bGQgYmUgaW4gZ2V0Q3VycmVudFRyYW5zZm9ybS5cblx0XHRyZXR1cm4gZG9uZSAmJiBwb3MudCA+PSB0aGlzLmNhbWVyYS50YXJnZXQudDtcblx0fVxuXG5cdC8qXG4gXHQqIFRoaXMgZnVuY3Rpb24gaGF2ZSBlYWNoIGxheWVyIHRvIGNoZWNrIHdoaWNoIHRpbGVzIGFyZSBuZWVkZWQgYW5kIHNjaGVkdWxlIHRoZW0gZm9yIGRvd25sb2FkLlxuIFx0KiBAcGFyYW0ge29iamVjdH0gdHJhbnNmb3JtIGlzIHRoZSBjYW1lcmEgcG9zaXRpb24gKGxheWVyIHdpbGwgY29tYmluZSB3aXRoIGxvY2FsIHRyYW5zZm9ybSkuXG4gXHQqL1xuXHQvKiogQGlnbm9yZSAqL1xuXHRwcmVmZXRjaCh0cmFuc2Zvcm0pIHtcblx0XHRpZighdHJhbnNmb3JtKVxuXHRcdFx0dHJhbnNmb3JtID0gdGhpcy5jYW1lcmEuZ2V0R2xDdXJyZW50VHJhbnNmb3JtKHBlcmZvcm1hbmNlLm5vdygpKTtcblx0XHRmb3IobGV0IGlkIGluIHRoaXMubGF5ZXJzKSB7XG5cdFx0XHRsZXQgbGF5ZXIgPSB0aGlzLmxheWVyc1tpZF07XG5cdFx0XHQvL2NvbnNvbGUubG9nKGxheWVyKTtcblx0XHRcdC8vY29uc29sZS5sb2cobGF5ZXIubGF5b3V0LnN0YXR1cyk7XG5cdFx0XHRpZihsYXllci52aXNpYmxlICYmIGxheWVyLnN0YXR1cyA9PSAncmVhZHknKSB7XG5cdFx0XHRcdGxheWVyLnByZWZldGNoKHRyYW5zZm9ybSwgdGhpcy5jYW1lcmEuZ2xWaWV3cG9ydCgpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuYWRkU2lnbmFscyhDYW52YXMsICd1cGRhdGUnLCAndXBkYXRlU2l6ZScsICdyZWFkeScpO1xuXG5leHBvcnQgeyBDYW52YXMgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Canvas.js\n");

/***/ }),

/***/ "./src/Controller.js":
/*!***************************!*\
  !*** ./src/Controller.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Controller\": () => (/* binding */ Controller)\n/* harmony export */ });\n/**\n * **Controller** is a virtual base class that handles user interaction via device events (mouse/touch events).\n * It provides an abstract user interface to define interaction actions such as panning, pinching, tapping, etc...\n * The actions are implemented by pre-defined callback functions:\n * * `panStart(e)` intercepts the initial pan event (movement of the mouse after pressing a mouse button or moving a finger).\n * The event is captured calling `e.preventDefault()`.\n * * `panMove(e)` receives and handles the pan event.\n * * `panEnd(e)` intercepts the final pan event (the user releases the left mouse button or removes his finger from the screen).\n * * `pinchStart(e1, e2)` intercepts the initial pinch event (a continuous gesture that tracks the positions between the first two fingers that touch the screen).\n * The event is captured calling `e1.preventDefault()`.\n * * `pinchMove(e1,e2)` receives and handles the pinch event.\n * * `pinchEnd(e1,e2)` intercepts the final pinch event (the user removes one of their two fingers from the screen).\n * * `mouseWheel(e)` receives and handles the mouse wheel event (the user rotates the mouse wheel button).\n * * `fingerSingleTap(e)` receives and handles the single-tap event (the user presses a mouse button quickly or touches the screen shortly with a finger).\n * * `fingerDoubleTap(e)` receives and handles the double-tap event (the user quickly presses a mouse button twice or shortly touches the screen with a finger twice).\n * \n * `e.preventDefault()` will capture the event and wont be propagated to other controllers.\n * \n * This class only describes user interactions by implementing actions or callbacks. A **Controller** works in concert with a **PointerManager** object \n * that emits events and links them to actions.\n * \n * In the example below a **ControllerPanZoom** object (derived from **Controller**) is created and associated with the `pointerManager` of the `viewer`.\n * ```\n * const panzoom = new OpenLIME.ControllerPanZoom(viewer.camera, {\n *     priority: -1000,\n *     activeModifiers: [0, 1]\n * });\n * viewer.pointerManager.onEvent(panzoom);\n * ```\t\n */\nclass Controller {\n\t/**\n\t * Instantiates a Controller object.\n\t * @param {Object} [options] An object literal with controller parameters.\n\t * @param {number} options.panDelay=50 Inertial value of the movement in ms for panning movements.\n\t * @param {number} options.zoomDelay=200 A zoom event is smoothed over this delay in ms,\n\t * @param {number} options.priority=0 Higher priority controllers are invoked first.\n\t */\n\tconstructor(options) {\n\t\tObject.assign(this, {\n\t\t\tactive: true,\n\t\t\tdebug: false,\n\t\t\tpanDelay: 50,\n\t\t\tzoomDelay: 200,\n\t\t\tpriority: 0,\n\t\t\tactiveModifiers: [0]\n\t\t});\n\n\t\tObject.assign(this, options);\n\n\t}\n\n\t/**\n\t * Returns the modifier state of the event `e`. Modifiers are keyboard events that happens simultaneously \n\t * with a device event (e.g. shift + left mouse button).\n\t * The modifiers handled by a controller are:\n\t * * NoModifiers = 0\n\t * * CrtlModifier = 1\n\t * * ShiftModifier = 2\n\t * * AltModifier = 4\n\t * \n\t * The modifier state is the sum of values above corresponding to the key pressed (CTRL, SHIFT or ALT).\n\t * @param {Event} e \n\t * @returns {number} The modifier state.\n\t */\n\tmodifierState(e) {\n\t\tlet state = 0;\n\t\tif(e.ctrlKey) state += 1;\n\t\tif(e.shiftKey) state += 2;\n\t\tif(e.altKey) state += 4;\n\t\t\n\t\treturn state;\n\t}\n\n\t/** @ignore */\n\tcaptureEvents() {\n\t\tthis.capture = true;\n\t}\n\n\t/** @ignore */\n\treleaseEvents() {\n\t\tthis.capture = false;\n\t}\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvQ29udHJvbGxlci5qcz9hMjRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogKipDb250cm9sbGVyKiogaXMgYSB2aXJ0dWFsIGJhc2UgY2xhc3MgdGhhdCBoYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb24gdmlhIGRldmljZSBldmVudHMgKG1vdXNlL3RvdWNoIGV2ZW50cykuXG4gKiBJdCBwcm92aWRlcyBhbiBhYnN0cmFjdCB1c2VyIGludGVyZmFjZSB0byBkZWZpbmUgaW50ZXJhY3Rpb24gYWN0aW9ucyBzdWNoIGFzIHBhbm5pbmcsIHBpbmNoaW5nLCB0YXBwaW5nLCBldGMuLi5cbiAqIFRoZSBhY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBieSBwcmUtZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbnM6XG4gKiAqIGBwYW5TdGFydChlKWAgaW50ZXJjZXB0cyB0aGUgaW5pdGlhbCBwYW4gZXZlbnQgKG1vdmVtZW50IG9mIHRoZSBtb3VzZSBhZnRlciBwcmVzc2luZyBhIG1vdXNlIGJ1dHRvbiBvciBtb3ZpbmcgYSBmaW5nZXIpLlxuICogVGhlIGV2ZW50IGlzIGNhcHR1cmVkIGNhbGxpbmcgYGUucHJldmVudERlZmF1bHQoKWAuXG4gKiAqIGBwYW5Nb3ZlKGUpYCByZWNlaXZlcyBhbmQgaGFuZGxlcyB0aGUgcGFuIGV2ZW50LlxuICogKiBgcGFuRW5kKGUpYCBpbnRlcmNlcHRzIHRoZSBmaW5hbCBwYW4gZXZlbnQgKHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBvciByZW1vdmVzIGhpcyBmaW5nZXIgZnJvbSB0aGUgc2NyZWVuKS5cbiAqICogYHBpbmNoU3RhcnQoZTEsIGUyKWAgaW50ZXJjZXB0cyB0aGUgaW5pdGlhbCBwaW5jaCBldmVudCAoYSBjb250aW51b3VzIGdlc3R1cmUgdGhhdCB0cmFja3MgdGhlIHBvc2l0aW9ucyBiZXR3ZWVuIHRoZSBmaXJzdCB0d28gZmluZ2VycyB0aGF0IHRvdWNoIHRoZSBzY3JlZW4pLlxuICogVGhlIGV2ZW50IGlzIGNhcHR1cmVkIGNhbGxpbmcgYGUxLnByZXZlbnREZWZhdWx0KClgLlxuICogKiBgcGluY2hNb3ZlKGUxLGUyKWAgcmVjZWl2ZXMgYW5kIGhhbmRsZXMgdGhlIHBpbmNoIGV2ZW50LlxuICogKiBgcGluY2hFbmQoZTEsZTIpYCBpbnRlcmNlcHRzIHRoZSBmaW5hbCBwaW5jaCBldmVudCAodGhlIHVzZXIgcmVtb3ZlcyBvbmUgb2YgdGhlaXIgdHdvIGZpbmdlcnMgZnJvbSB0aGUgc2NyZWVuKS5cbiAqICogYG1vdXNlV2hlZWwoZSlgIHJlY2VpdmVzIGFuZCBoYW5kbGVzIHRoZSBtb3VzZSB3aGVlbCBldmVudCAodGhlIHVzZXIgcm90YXRlcyB0aGUgbW91c2Ugd2hlZWwgYnV0dG9uKS5cbiAqICogYGZpbmdlclNpbmdsZVRhcChlKWAgcmVjZWl2ZXMgYW5kIGhhbmRsZXMgdGhlIHNpbmdsZS10YXAgZXZlbnQgKHRoZSB1c2VyIHByZXNzZXMgYSBtb3VzZSBidXR0b24gcXVpY2tseSBvciB0b3VjaGVzIHRoZSBzY3JlZW4gc2hvcnRseSB3aXRoIGEgZmluZ2VyKS5cbiAqICogYGZpbmdlckRvdWJsZVRhcChlKWAgcmVjZWl2ZXMgYW5kIGhhbmRsZXMgdGhlIGRvdWJsZS10YXAgZXZlbnQgKHRoZSB1c2VyIHF1aWNrbHkgcHJlc3NlcyBhIG1vdXNlIGJ1dHRvbiB0d2ljZSBvciBzaG9ydGx5IHRvdWNoZXMgdGhlIHNjcmVlbiB3aXRoIGEgZmluZ2VyIHR3aWNlKS5cbiAqIFxuICogYGUucHJldmVudERlZmF1bHQoKWAgd2lsbCBjYXB0dXJlIHRoZSBldmVudCBhbmQgd29udCBiZSBwcm9wYWdhdGVkIHRvIG90aGVyIGNvbnRyb2xsZXJzLlxuICogXG4gKiBUaGlzIGNsYXNzIG9ubHkgZGVzY3JpYmVzIHVzZXIgaW50ZXJhY3Rpb25zIGJ5IGltcGxlbWVudGluZyBhY3Rpb25zIG9yIGNhbGxiYWNrcy4gQSAqKkNvbnRyb2xsZXIqKiB3b3JrcyBpbiBjb25jZXJ0IHdpdGggYSAqKlBvaW50ZXJNYW5hZ2VyKiogb2JqZWN0IFxuICogdGhhdCBlbWl0cyBldmVudHMgYW5kIGxpbmtzIHRoZW0gdG8gYWN0aW9ucy5cbiAqIFxuICogSW4gdGhlIGV4YW1wbGUgYmVsb3cgYSAqKkNvbnRyb2xsZXJQYW5ab29tKiogb2JqZWN0IChkZXJpdmVkIGZyb20gKipDb250cm9sbGVyKiopIGlzIGNyZWF0ZWQgYW5kIGFzc29jaWF0ZWQgd2l0aCB0aGUgYHBvaW50ZXJNYW5hZ2VyYCBvZiB0aGUgYHZpZXdlcmAuXG4gKiBgYGBcbiAqIGNvbnN0IHBhbnpvb20gPSBuZXcgT3BlbkxJTUUuQ29udHJvbGxlclBhblpvb20odmlld2VyLmNhbWVyYSwge1xuICogICAgIHByaW9yaXR5OiAtMTAwMCxcbiAqICAgICBhY3RpdmVNb2RpZmllcnM6IFswLCAxXVxuICogfSk7XG4gKiB2aWV3ZXIucG9pbnRlck1hbmFnZXIub25FdmVudChwYW56b29tKTtcbiAqIGBgYFx0XG4gKi9cbmNsYXNzIENvbnRyb2xsZXIge1xuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgQ29udHJvbGxlciBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBjb250cm9sbGVyIHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnBhbkRlbGF5PTUwIEluZXJ0aWFsIHZhbHVlIG9mIHRoZSBtb3ZlbWVudCBpbiBtcyBmb3IgcGFubmluZyBtb3ZlbWVudHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb21EZWxheT0yMDAgQSB6b29tIGV2ZW50IGlzIHNtb290aGVkIG92ZXIgdGhpcyBkZWxheSBpbiBtcyxcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucHJpb3JpdHk9MCBIaWdoZXIgcHJpb3JpdHkgY29udHJvbGxlcnMgYXJlIGludm9rZWQgZmlyc3QuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XG5cdFx0XHRhY3RpdmU6IHRydWUsXG5cdFx0XHRkZWJ1ZzogZmFsc2UsXG5cdFx0XHRwYW5EZWxheTogNTAsXG5cdFx0XHR6b29tRGVsYXk6IDIwMCxcblx0XHRcdHByaW9yaXR5OiAwLFxuXHRcdFx0YWN0aXZlTW9kaWZpZXJzOiBbMF1cblx0XHR9KTtcblxuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtb2RpZmllciBzdGF0ZSBvZiB0aGUgZXZlbnQgYGVgLiBNb2RpZmllcnMgYXJlIGtleWJvYXJkIGV2ZW50cyB0aGF0IGhhcHBlbnMgc2ltdWx0YW5lb3VzbHkgXG5cdCAqIHdpdGggYSBkZXZpY2UgZXZlbnQgKGUuZy4gc2hpZnQgKyBsZWZ0IG1vdXNlIGJ1dHRvbikuXG5cdCAqIFRoZSBtb2RpZmllcnMgaGFuZGxlZCBieSBhIGNvbnRyb2xsZXIgYXJlOlxuXHQgKiAqIE5vTW9kaWZpZXJzID0gMFxuXHQgKiAqIENydGxNb2RpZmllciA9IDFcblx0ICogKiBTaGlmdE1vZGlmaWVyID0gMlxuXHQgKiAqIEFsdE1vZGlmaWVyID0gNFxuXHQgKiBcblx0ICogVGhlIG1vZGlmaWVyIHN0YXRlIGlzIHRoZSBzdW0gb2YgdmFsdWVzIGFib3ZlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleSBwcmVzc2VkIChDVFJMLCBTSElGVCBvciBBTFQpLlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlIFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbW9kaWZpZXIgc3RhdGUuXG5cdCAqL1xuXHRtb2RpZmllclN0YXRlKGUpIHtcblx0XHRsZXQgc3RhdGUgPSAwO1xuXHRcdGlmKGUuY3RybEtleSkgc3RhdGUgKz0gMTtcblx0XHRpZihlLnNoaWZ0S2V5KSBzdGF0ZSArPSAyO1xuXHRcdGlmKGUuYWx0S2V5KSBzdGF0ZSArPSA0O1xuXHRcdFxuXHRcdHJldHVybiBzdGF0ZTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGNhcHR1cmVFdmVudHMoKSB7XG5cdFx0dGhpcy5jYXB0dXJlID0gdHJ1ZTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHJlbGVhc2VFdmVudHMoKSB7XG5cdFx0dGhpcy5jYXB0dXJlID0gZmFsc2U7XG5cdH1cbn1cblxuZXhwb3J0IHsgQ29udHJvbGxlciB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Controller.js\n");

/***/ }),

/***/ "./src/Controller2D.js":
/*!*****************************!*\
  !*** ./src/Controller2D.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Controller2D\": () => (/* binding */ Controller2D)\n/* harmony export */ });\n/* harmony import */ var _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox.js */ \"./src/BoundingBox.js\");\n/* harmony import */ var _Controller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Controller.js */ \"./src/Controller.js\");\n\n\n\n/**\n * Callback invoked when the position (x, y) is updated.\n * @callback updatePosition\n * @param {number} x The x coordinate.\n * @param {number} y The y coordinate.\n */\n\nfunction clamp(value, min, max) {\n\treturn Math.max(min, Math.min(max, value));\n}\n\n/** **Controller2D** intercepts pan and single-tap events in the canvas and updates a 2D position (x, y) of the device pointer.\n * If `options.relative` is false the coordinates are both mapped between [-1, 1] with origin in the bottom left corner of the canvas, \n * otherwise the coordinates have origin in the initial position of the panning and ranges both between [-1, 1] according to the distance\n * from the local origin (multiplied by a `options.speed` value).\n * When updated, the (x, y) position is passed to a `callback` for further custom computations.\n */\nclass Controller2D extends _Controller_js__WEBPACK_IMPORTED_MODULE_1__.Controller {\n\t/**\n\t * Instantiates a Controller2D object.\n\t * @param {updatePosition} callback The callback invoked when the postion (x, y) is updated.\n\t * @param {Object} [options] An object literal with controller parameters.\n\t * @param {bool} options.relative=false Whether the coordinate system is local.\n\t * @param {number} options.speed=2.0 Enhancement factor for computation of local coordinates.\n\t */\n\tconstructor(callback, options) {\n\t\tsuper(options);\n\t\tObject.assign(this, { \n\t\t\trelative: false, \n\t\t\tspeed: 2.0, \n\t\t\tstart_x: 0, \n\t\t\tstart_y: 0, \n\t\t\tcurrent_x: 0, \n\t\t\tcurrent_y: 0,\n\t\t\tonPanStart: null,\n\t\t\tonPanEnd: null\n\t\t}, options);\n\n\t\t//By default the controller is active only with no modifiers.\n\t\t//you can select which subsets of the modifiers are active.\n\t\tthis.callback = callback;\n\t\t\n\t\tif(!this.box) { //FIXME What is that? Is it used?\n\t\t\tthis.box = new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({xLow:-0.99, yLow: -0.99, xHigh: 0.99, yHigh: 0.99});\n\t\t}\n\n\t\tthis.panning = false;\n\t}\n\n\t/**\n\t * Stores the final position for local coordinate system. This is a convenience function to be used in callback.\n\t * @param {number} x The x-axis coordinate.\n\t * @param {number} y The y-axis coordinate.\n\t */\n\tsetPosition(x, y) {\n\t\tthis.current_x = x;\n\t\tthis.current_y = y;\n\t\tthis.callback(x, y);\n\t}\n\n\t/*\n\t * Computes the mapping between the canvas pixel coordinates to [-1, 1].\n\t * @param {event} e The device event. \n\t * @returns {{x, y}} The projected position.\n\t */\n\t/** @ignore */\n\tproject(e) {\n\t\tlet rect = e.target.getBoundingClientRect();\n\t\tlet x = 2*e.offsetX/rect.width - 1;\n\t\tlet y = 2*(1 - e.offsetY/rect.height) -1;\n\t\treturn [x, y]\n\t}\n\n\t/** @ignore */\n\trangeCoords(e) {\n\t\tlet [x, y] = this.project(e);\n\n\t\tif(this.relative) {\n\t\t\tx = clamp(this.speed*(x - this.start_x) + this.current_x, -1, 1);\n\t\t\ty = clamp(this.speed*(y - this.start_y) + this.current_y, -1, 1);\n\t\t}\n\t\treturn [x, y];\n\t}\n\n\t/** @ignore */\n\tpanStart(e) {\n\t\tif(!this.active || !this.activeModifiers.includes(this.modifierState(e)))\n\t\t\treturn;\n\n\t\tif(this.relative) {\n\t\t\tlet [x, y] = this.project(e);\n\t\t\tthis.start_x = x;\n\t\t\tthis.start_y = y;\n\t\t}\n\t\tif(this.onPanStart)\n\t\t\tthis.onPanStart(...this.rangeCoords(e));\n\t\tthis.callback(...this.rangeCoords(e));\n\t\tthis.panning = true;\n\t\te.preventDefault();\n\t}\n\n\t/** @ignore */\n\tpanMove(e) {\n\t\tif(!this.panning)\n\t\t\treturn false;\n\t\tthis.callback(...this.rangeCoords(e));\n\t}\n\n\t/** @ignore */\n\tpanEnd(e) {\n\t\tif(!this.panning)\n\t\t\treturn false;\n\t\tthis.panning = false;\n\t\tif(this.relative) {\n\t\t\tlet [x, y] = this.project(e);\n\t\t\tthis.current_x = clamp(this.speed*(x - this.start_x) + this.current_x, -1, 1);\n\t\t\tthis.current_y = clamp(this.speed*(y - this.start_y) + this.current_y, -1, 1);\n\t\t}\n\t\tif(this.onPanEnd)\n\t\t\tthis.onPanEnd(...this.rangeCoords(e));\n\t}\n\n\t/** @ignore */\n\tfingerSingleTap(e) {\n\t\tif(!this.active || !this.activeModifiers.includes(this.modifierState(e)))\n\t\t\treturn;\n\t\tif(this.relative)\n\t\t\treturn;\n\t\tthis.update(e);\n\t\te.preventDefault();\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29udHJvbGxlcjJELmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNIOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQVU7QUFDckM7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCLHdEQUFXLEVBQUUsa0RBQWtEO0FBQ2pGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvQ29udHJvbGxlcjJELmpzP2YzMjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICcuL0JvdW5kaW5nQm94LmpzJztcbmltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICcuL0NvbnRyb2xsZXIuanMnXG5cbi8qKlxuICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSBwb3NpdGlvbiAoeCwgeSkgaXMgdXBkYXRlZC5cbiAqIEBjYWxsYmFjayB1cGRhdGVQb3NpdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUuXG4gKi9cblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG5cdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cblxuLyoqICoqQ29udHJvbGxlcjJEKiogaW50ZXJjZXB0cyBwYW4gYW5kIHNpbmdsZS10YXAgZXZlbnRzIGluIHRoZSBjYW52YXMgYW5kIHVwZGF0ZXMgYSAyRCBwb3NpdGlvbiAoeCwgeSkgb2YgdGhlIGRldmljZSBwb2ludGVyLlxuICogSWYgYG9wdGlvbnMucmVsYXRpdmVgIGlzIGZhbHNlIHRoZSBjb29yZGluYXRlcyBhcmUgYm90aCBtYXBwZWQgYmV0d2VlbiBbLTEsIDFdIHdpdGggb3JpZ2luIGluIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcywgXG4gKiBvdGhlcndpc2UgdGhlIGNvb3JkaW5hdGVzIGhhdmUgb3JpZ2luIGluIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwYW5uaW5nIGFuZCByYW5nZXMgYm90aCBiZXR3ZWVuIFstMSwgMV0gYWNjb3JkaW5nIHRvIHRoZSBkaXN0YW5jZVxuICogZnJvbSB0aGUgbG9jYWwgb3JpZ2luIChtdWx0aXBsaWVkIGJ5IGEgYG9wdGlvbnMuc3BlZWRgIHZhbHVlKS5cbiAqIFdoZW4gdXBkYXRlZCwgdGhlICh4LCB5KSBwb3NpdGlvbiBpcyBwYXNzZWQgdG8gYSBgY2FsbGJhY2tgIGZvciBmdXJ0aGVyIGN1c3RvbSBjb21wdXRhdGlvbnMuXG4gKi9cbmNsYXNzIENvbnRyb2xsZXIyRCBleHRlbmRzIENvbnRyb2xsZXIge1xuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgQ29udHJvbGxlcjJEIG9iamVjdC5cblx0ICogQHBhcmFtIHt1cGRhdGVQb3NpdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgcG9zdGlvbiAoeCwgeSkgaXMgdXBkYXRlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGNvbnRyb2xsZXIgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtib29sfSBvcHRpb25zLnJlbGF0aXZlPWZhbHNlIFdoZXRoZXIgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGlzIGxvY2FsLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zcGVlZD0yLjAgRW5oYW5jZW1lbnQgZmFjdG9yIGZvciBjb21wdXRhdGlvbiBvZiBsb2NhbCBjb29yZGluYXRlcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7IFxuXHRcdFx0cmVsYXRpdmU6IGZhbHNlLCBcblx0XHRcdHNwZWVkOiAyLjAsIFxuXHRcdFx0c3RhcnRfeDogMCwgXG5cdFx0XHRzdGFydF95OiAwLCBcblx0XHRcdGN1cnJlbnRfeDogMCwgXG5cdFx0XHRjdXJyZW50X3k6IDAsXG5cdFx0XHRvblBhblN0YXJ0OiBudWxsLFxuXHRcdFx0b25QYW5FbmQ6IG51bGxcblx0XHR9LCBvcHRpb25zKTtcblxuXHRcdC8vQnkgZGVmYXVsdCB0aGUgY29udHJvbGxlciBpcyBhY3RpdmUgb25seSB3aXRoIG5vIG1vZGlmaWVycy5cblx0XHQvL3lvdSBjYW4gc2VsZWN0IHdoaWNoIHN1YnNldHMgb2YgdGhlIG1vZGlmaWVycyBhcmUgYWN0aXZlLlxuXHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcblx0XHRpZighdGhpcy5ib3gpIHsgLy9GSVhNRSBXaGF0IGlzIHRoYXQ/IElzIGl0IHVzZWQ/XG5cdFx0XHR0aGlzLmJveCA9IG5ldyBCb3VuZGluZ0JveCh7eExvdzotMC45OSwgeUxvdzogLTAuOTksIHhIaWdoOiAwLjk5LCB5SGlnaDogMC45OX0pO1xuXHRcdH1cblxuXHRcdHRoaXMucGFubmluZyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgZmluYWwgcG9zaXRpb24gZm9yIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtLiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYmUgdXNlZCBpbiBjYWxsYmFjay5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHgtYXhpcyBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeS1heGlzIGNvb3JkaW5hdGUuXG5cdCAqL1xuXHRzZXRQb3NpdGlvbih4LCB5KSB7XG5cdFx0dGhpcy5jdXJyZW50X3ggPSB4O1xuXHRcdHRoaXMuY3VycmVudF95ID0geTtcblx0XHR0aGlzLmNhbGxiYWNrKHgsIHkpO1xuXHR9XG5cblx0Lypcblx0ICogQ29tcHV0ZXMgdGhlIG1hcHBpbmcgYmV0d2VlbiB0aGUgY2FudmFzIHBpeGVsIGNvb3JkaW5hdGVzIHRvIFstMSwgMV0uXG5cdCAqIEBwYXJhbSB7ZXZlbnR9IGUgVGhlIGRldmljZSBldmVudC4gXG5cdCAqIEByZXR1cm5zIHt7eCwgeX19IFRoZSBwcm9qZWN0ZWQgcG9zaXRpb24uXG5cdCAqL1xuXHQvKiogQGlnbm9yZSAqL1xuXHRwcm9qZWN0KGUpIHtcblx0XHRsZXQgcmVjdCA9IGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGxldCB4ID0gMiplLm9mZnNldFgvcmVjdC53aWR0aCAtIDE7XG5cdFx0bGV0IHkgPSAyKigxIC0gZS5vZmZzZXRZL3JlY3QuaGVpZ2h0KSAtMTtcblx0XHRyZXR1cm4gW3gsIHldXG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRyYW5nZUNvb3JkcyhlKSB7XG5cdFx0bGV0IFt4LCB5XSA9IHRoaXMucHJvamVjdChlKTtcblxuXHRcdGlmKHRoaXMucmVsYXRpdmUpIHtcblx0XHRcdHggPSBjbGFtcCh0aGlzLnNwZWVkKih4IC0gdGhpcy5zdGFydF94KSArIHRoaXMuY3VycmVudF94LCAtMSwgMSk7XG5cdFx0XHR5ID0gY2xhbXAodGhpcy5zcGVlZCooeSAtIHRoaXMuc3RhcnRfeSkgKyB0aGlzLmN1cnJlbnRfeSwgLTEsIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gW3gsIHldO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cGFuU3RhcnQoZSkge1xuXHRcdGlmKCF0aGlzLmFjdGl2ZSB8fCAhdGhpcy5hY3RpdmVNb2RpZmllcnMuaW5jbHVkZXModGhpcy5tb2RpZmllclN0YXRlKGUpKSlcblx0XHRcdHJldHVybjtcblxuXHRcdGlmKHRoaXMucmVsYXRpdmUpIHtcblx0XHRcdGxldCBbeCwgeV0gPSB0aGlzLnByb2plY3QoZSk7XG5cdFx0XHR0aGlzLnN0YXJ0X3ggPSB4O1xuXHRcdFx0dGhpcy5zdGFydF95ID0geTtcblx0XHR9XG5cdFx0aWYodGhpcy5vblBhblN0YXJ0KVxuXHRcdFx0dGhpcy5vblBhblN0YXJ0KC4uLnRoaXMucmFuZ2VDb29yZHMoZSkpO1xuXHRcdHRoaXMuY2FsbGJhY2soLi4udGhpcy5yYW5nZUNvb3JkcyhlKSk7XG5cdFx0dGhpcy5wYW5uaW5nID0gdHJ1ZTtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRwYW5Nb3ZlKGUpIHtcblx0XHRpZighdGhpcy5wYW5uaW5nKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHRoaXMuY2FsbGJhY2soLi4udGhpcy5yYW5nZUNvb3JkcyhlKSk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRwYW5FbmQoZSkge1xuXHRcdGlmKCF0aGlzLnBhbm5pbmcpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dGhpcy5wYW5uaW5nID0gZmFsc2U7XG5cdFx0aWYodGhpcy5yZWxhdGl2ZSkge1xuXHRcdFx0bGV0IFt4LCB5XSA9IHRoaXMucHJvamVjdChlKTtcblx0XHRcdHRoaXMuY3VycmVudF94ID0gY2xhbXAodGhpcy5zcGVlZCooeCAtIHRoaXMuc3RhcnRfeCkgKyB0aGlzLmN1cnJlbnRfeCwgLTEsIDEpO1xuXHRcdFx0dGhpcy5jdXJyZW50X3kgPSBjbGFtcCh0aGlzLnNwZWVkKih5IC0gdGhpcy5zdGFydF95KSArIHRoaXMuY3VycmVudF95LCAtMSwgMSk7XG5cdFx0fVxuXHRcdGlmKHRoaXMub25QYW5FbmQpXG5cdFx0XHR0aGlzLm9uUGFuRW5kKC4uLnRoaXMucmFuZ2VDb29yZHMoZSkpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0ZmluZ2VyU2luZ2xlVGFwKGUpIHtcblx0XHRpZighdGhpcy5hY3RpdmUgfHwgIXRoaXMuYWN0aXZlTW9kaWZpZXJzLmluY2x1ZGVzKHRoaXMubW9kaWZpZXJTdGF0ZShlKSkpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYodGhpcy5yZWxhdGl2ZSlcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLnVwZGF0ZShlKTtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdH1cblxufVxuXG5leHBvcnQgeyBDb250cm9sbGVyMkQgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Controller2D.js\n");

/***/ }),

/***/ "./src/ControllerPanZoom.js":
/*!**********************************!*\
  !*** ./src/ControllerPanZoom.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ControllerPanZoom\": () => (/* binding */ ControllerPanZoom)\n/* harmony export */ });\n/* harmony import */ var _Controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Controller.js */ \"./src/Controller.js\");\n/* harmony import */ var _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CoordinateSystem.js */ \"./src/CoordinateSystem.js\");\n/* harmony import */ var _Signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Signals.js */ \"./src/Signals.js\");\n\n\n\n\n\n/** **ControllerPanZoom** intercepts pan, zoom, single tap, and wheel events in the canvas and updates the scene camera parameters.\n*/\n\nclass ControllerPanZoom extends _Controller_js__WEBPACK_IMPORTED_MODULE_0__.Controller {\n\t/**\n\t * Instantiates a ControllerPanZoom object.\n\t * @param {Camera} camera The scene camera.\n\t * @param {Object} [options] An object literal with controller parameters.\n\t * @param {number} options.zoomAmount=1.2 The incremental value for zoom in/out.\n\t */\n\tconstructor(camera, options) {\n\t\tsuper(options);\n\n\t\tthis.camera = camera;\n\t\tthis.zoomAmount = 1.2;          //for wheel or double tap event\n\t\tthis.controlZoom = false;       //require control+wheel to zoom\n\t\t\n\t\tthis.panning = false;           //true if in the middle of a pan\n\t\tthis.initialTransform = null;\n\t\tthis.startMouse = null;\n\n\t\tthis.zooming = false;           //true if in the middle of a pinch\n\t\tthis.initialDistance = 0.0;\n\t\tthis.useGLcoords = false;\n\n\t\tif(options)\n\t\t\tObject.assign(this, options);\n\t}\n\n\t/** @ignore */\n\tpanStart(e) {\n\t\tif(!this.active || this.panning || !this.activeModifiers.includes(this.modifierState(e)))\n\t\t\treturn;\n\t\tthis.panning = true;\n\n\t\tthis.startMouse = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_1__.CoordinateSystem.fromCanvasHtmlToViewport({ x: e.offsetX, y: e.offsetY }, this.camera, this.useGLcoords);\n\n\t\tlet now = performance.now();\n\t\tthis.initialTransform = this.camera.getCurrentTransform(now);\n\t\tthis.camera.target = this.initialTransform.copy(); //stop animation.\n\t\te.preventDefault();\n\t}\n\n\t/** @ignore */\n\tpanMove(e) {\n\t\tif (!this.panning)\n\t\t\treturn;\n\n\t\tlet m = this.initialTransform;\n\t\tconst p = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_1__.CoordinateSystem.fromCanvasHtmlToViewport({ x: e.offsetX, y: e.offsetY }, this.camera, this.useGLcoords);\n\t\tlet dx = (p.x - this.startMouse.x);\n\t\tlet dy = (p.y - this.startMouse.y);\n\t\t\n\t\tthis.camera.setPosition(this.panDelay, m.x + dx, m.y + dy, m.z, m.a);\n\t}\n\n\t/** @ignore */\n\tpanEnd(e) {\n\t\tthis.panning = false;\n\t}\n\n\t/** @ignore */\n\tdistance(e1, e2) {\n\t\treturn Math.sqrt(Math.pow(e1.x - e2.x, 2) + Math.pow(e1.y - e2.y, 2));\n\t}\n\n\t/** @ignore */\n\tpinchStart(e1, e2) {\n\t\tthis.zooming = true;\n\t\tthis.initialDistance = Math.max(30, this.distance(e1, e2));\n\t\te1.preventDefault();\n\t\t//e2.preventDefault(); //TODO this is optional?\n\t}\n\n\t/** @ignore */\n\tpinchMove(e1, e2) {\n\t\tif (!this.zooming)\n\t\t\treturn;\n\t\tlet rect1 = e1.target.getBoundingClientRect();\n\t\tlet offsetX1 = e1.clientX - rect1.left;\n\t\tlet offsetY1 = e1.clientY - rect1.top;\n\t\tlet rect2 = e2.target.getBoundingClientRect();\n\t\tlet offsetX2 = e2.clientX - rect2.left;\n\t\tlet offsetY2 = e2.clientY - rect2.top;\n\t\tconst scale = this.distance(e1, e2);\n\t\t// FIXME CHECK ON TOUCH SCREEN\n\t\t//const pos = this.camera.mapToScene((offsetX1 + offsetX2)/2, (offsetY1 + offsetY2)/2, this.camera.getCurrentTransform(performance.now()));\n\t\tconst pos = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_1__.CoordinateSystem.fromCanvasHtmlToScene({ x: (offsetX1 + offsetX2)/2, y: (offsetY1 + offsetY2)/2 }, this.camera, this.useGLcoords);\n\n\t\tconst dz = scale/this.initialDistance;\n\t\tthis.camera.deltaZoom(this.zoomDelay, dz, pos.x, pos.y);\n\t\tthis.initialDistance = scale;\n\t\te1.preventDefault();\n\t}\n\n\t/** @ignore */\n\tpinchEnd(e, x, y, scale) {\n\t\tthis.zooming = false;\n\t\te.preventDefault();\n\t}\n\n\t/** @ignore */\n\tmouseWheel(e) {\n\t\tif(this.controlZoom && !e.ctrlKey) {\n\t\t\tthis.emit('nowheel');\n\t\t\treturn;\n\t\t}\n\t\tlet delta = -e.deltaY/53;\n\t\t//const pos = this.camera.mapToScene(e.offsetX, e.offsetY, this.camera.getCurrentTransform(performance.now()));\n\t\tconst pos = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_1__.CoordinateSystem.fromCanvasHtmlToScene({ x: e.offsetX, y: e.offsetY }, this.camera, this.useGLcoords);\n\t\tconst dz = Math.pow(this.zoomAmount, delta);\t\t\n\t\tthis.camera.deltaZoom(this.zoomDelay, dz, pos.x, pos.y);\n\t\te.preventDefault();\n\t}\n\n\t/** @ignore */\n\tfingerDoubleTap(e) {\n\t\tif(!this.active || !this.activeModifiers.includes(this.modifierState(e)))\n\t\t\treturn;\n\t\t//const pos = this.camera.mapToScene(e.offsetX, e.offsetY, this.camera.getCurrentTransform(performance.now()));\n\t\tconst pos = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_1__.CoordinateSystem.fromCanvasHtmlToScene({ x: e.offsetX, y: e.offsetY }, this.camera, this.useGLcoords);\n\n\t\tconst dz = this.zoomAmount;\n\t\tthis.camera.deltaZoom(this.zoomDelay, dz, pos.x, pos.y);\n\t}\n\n}\n(0,_Signals_js__WEBPACK_IMPORTED_MODULE_2__.addSignals)(ControllerPanZoom, 'nowheel');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29udHJvbGxlclBhblpvb20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNhO0FBQ2hCOzs7QUFHekM7QUFDQTs7QUFFQSxnQ0FBZ0Msc0RBQVU7QUFDMUM7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMkZBQXlDLEdBQUcsNEJBQTRCOztBQUU1RjtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDJGQUF5QyxHQUFHLDRCQUE0QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdGQUFzQyxHQUFHLHdEQUF3RDs7QUFFL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdGQUFzQyxHQUFHLDRCQUE0QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3RkFBc0MsR0FBRyw0QkFBNEI7O0FBRW5GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUFVOztBQUVrQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL0NvbnRyb2xsZXJQYW5ab29tLmpzPzI5ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJy4vQ29udHJvbGxlci5qcydcbmltcG9ydCB7IENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuL0Nvb3JkaW5hdGVTeXN0ZW0uanMnO1xuaW1wb3J0IHsgYWRkU2lnbmFscyB9IGZyb20gJy4vU2lnbmFscy5qcydcblxuXG4vKiogKipDb250cm9sbGVyUGFuWm9vbSoqIGludGVyY2VwdHMgcGFuLCB6b29tLCBzaW5nbGUgdGFwLCBhbmQgd2hlZWwgZXZlbnRzIGluIHRoZSBjYW52YXMgYW5kIHVwZGF0ZXMgdGhlIHNjZW5lIGNhbWVyYSBwYXJhbWV0ZXJzLlxuKi9cblxuY2xhc3MgQ29udHJvbGxlclBhblpvb20gZXh0ZW5kcyBDb250cm9sbGVyIHtcblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIENvbnRyb2xsZXJQYW5ab29tIG9iamVjdC5cblx0ICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBUaGUgc2NlbmUgY2FtZXJhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggY29udHJvbGxlciBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy56b29tQW1vdW50PTEuMiBUaGUgaW5jcmVtZW50YWwgdmFsdWUgZm9yIHpvb20gaW4vb3V0LlxuXHQgKi9cblx0Y29uc3RydWN0b3IoY2FtZXJhLCBvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cblx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblx0XHR0aGlzLnpvb21BbW91bnQgPSAxLjI7ICAgICAgICAgIC8vZm9yIHdoZWVsIG9yIGRvdWJsZSB0YXAgZXZlbnRcblx0XHR0aGlzLmNvbnRyb2xab29tID0gZmFsc2U7ICAgICAgIC8vcmVxdWlyZSBjb250cm9sK3doZWVsIHRvIHpvb21cblx0XHRcblx0XHR0aGlzLnBhbm5pbmcgPSBmYWxzZTsgICAgICAgICAgIC8vdHJ1ZSBpZiBpbiB0aGUgbWlkZGxlIG9mIGEgcGFuXG5cdFx0dGhpcy5pbml0aWFsVHJhbnNmb3JtID0gbnVsbDtcblx0XHR0aGlzLnN0YXJ0TW91c2UgPSBudWxsO1xuXG5cdFx0dGhpcy56b29taW5nID0gZmFsc2U7ICAgICAgICAgICAvL3RydWUgaWYgaW4gdGhlIG1pZGRsZSBvZiBhIHBpbmNoXG5cdFx0dGhpcy5pbml0aWFsRGlzdGFuY2UgPSAwLjA7XG5cdFx0dGhpcy51c2VHTGNvb3JkcyA9IGZhbHNlO1xuXG5cdFx0aWYob3B0aW9ucylcblx0XHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRwYW5TdGFydChlKSB7XG5cdFx0aWYoIXRoaXMuYWN0aXZlIHx8IHRoaXMucGFubmluZyB8fCAhdGhpcy5hY3RpdmVNb2RpZmllcnMuaW5jbHVkZXModGhpcy5tb2RpZmllclN0YXRlKGUpKSlcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLnBhbm5pbmcgPSB0cnVlO1xuXG5cdFx0dGhpcy5zdGFydE1vdXNlID0gQ29vcmRpbmF0ZVN5c3RlbS5mcm9tQ2FudmFzSHRtbFRvVmlld3BvcnQoeyB4OiBlLm9mZnNldFgsIHk6IGUub2Zmc2V0WSB9LCB0aGlzLmNhbWVyYSwgdGhpcy51c2VHTGNvb3Jkcyk7XG5cblx0XHRsZXQgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0dGhpcy5pbml0aWFsVHJhbnNmb3JtID0gdGhpcy5jYW1lcmEuZ2V0Q3VycmVudFRyYW5zZm9ybShub3cpO1xuXHRcdHRoaXMuY2FtZXJhLnRhcmdldCA9IHRoaXMuaW5pdGlhbFRyYW5zZm9ybS5jb3B5KCk7IC8vc3RvcCBhbmltYXRpb24uXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cGFuTW92ZShlKSB7XG5cdFx0aWYgKCF0aGlzLnBhbm5pbmcpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRsZXQgbSA9IHRoaXMuaW5pdGlhbFRyYW5zZm9ybTtcblx0XHRjb25zdCBwID0gQ29vcmRpbmF0ZVN5c3RlbS5mcm9tQ2FudmFzSHRtbFRvVmlld3BvcnQoeyB4OiBlLm9mZnNldFgsIHk6IGUub2Zmc2V0WSB9LCB0aGlzLmNhbWVyYSwgdGhpcy51c2VHTGNvb3Jkcyk7XG5cdFx0bGV0IGR4ID0gKHAueCAtIHRoaXMuc3RhcnRNb3VzZS54KTtcblx0XHRsZXQgZHkgPSAocC55IC0gdGhpcy5zdGFydE1vdXNlLnkpO1xuXHRcdFxuXHRcdHRoaXMuY2FtZXJhLnNldFBvc2l0aW9uKHRoaXMucGFuRGVsYXksIG0ueCArIGR4LCBtLnkgKyBkeSwgbS56LCBtLmEpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cGFuRW5kKGUpIHtcblx0XHR0aGlzLnBhbm5pbmcgPSBmYWxzZTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGRpc3RhbmNlKGUxLCBlMikge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZTEueCAtIGUyLngsIDIpICsgTWF0aC5wb3coZTEueSAtIGUyLnksIDIpKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHBpbmNoU3RhcnQoZTEsIGUyKSB7XG5cdFx0dGhpcy56b29taW5nID0gdHJ1ZTtcblx0XHR0aGlzLmluaXRpYWxEaXN0YW5jZSA9IE1hdGgubWF4KDMwLCB0aGlzLmRpc3RhbmNlKGUxLCBlMikpO1xuXHRcdGUxLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly9lMi5wcmV2ZW50RGVmYXVsdCgpOyAvL1RPRE8gdGhpcyBpcyBvcHRpb25hbD9cblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHBpbmNoTW92ZShlMSwgZTIpIHtcblx0XHRpZiAoIXRoaXMuem9vbWluZylcblx0XHRcdHJldHVybjtcblx0XHRsZXQgcmVjdDEgPSBlMS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0bGV0IG9mZnNldFgxID0gZTEuY2xpZW50WCAtIHJlY3QxLmxlZnQ7XG5cdFx0bGV0IG9mZnNldFkxID0gZTEuY2xpZW50WSAtIHJlY3QxLnRvcDtcblx0XHRsZXQgcmVjdDIgPSBlMi50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0bGV0IG9mZnNldFgyID0gZTIuY2xpZW50WCAtIHJlY3QyLmxlZnQ7XG5cdFx0bGV0IG9mZnNldFkyID0gZTIuY2xpZW50WSAtIHJlY3QyLnRvcDtcblx0XHRjb25zdCBzY2FsZSA9IHRoaXMuZGlzdGFuY2UoZTEsIGUyKTtcblx0XHQvLyBGSVhNRSBDSEVDSyBPTiBUT1VDSCBTQ1JFRU5cblx0XHQvL2NvbnN0IHBvcyA9IHRoaXMuY2FtZXJhLm1hcFRvU2NlbmUoKG9mZnNldFgxICsgb2Zmc2V0WDIpLzIsIChvZmZzZXRZMSArIG9mZnNldFkyKS8yLCB0aGlzLmNhbWVyYS5nZXRDdXJyZW50VHJhbnNmb3JtKHBlcmZvcm1hbmNlLm5vdygpKSk7XG5cdFx0Y29uc3QgcG9zID0gQ29vcmRpbmF0ZVN5c3RlbS5mcm9tQ2FudmFzSHRtbFRvU2NlbmUoeyB4OiAob2Zmc2V0WDEgKyBvZmZzZXRYMikvMiwgeTogKG9mZnNldFkxICsgb2Zmc2V0WTIpLzIgfSwgdGhpcy5jYW1lcmEsIHRoaXMudXNlR0xjb29yZHMpO1xuXG5cdFx0Y29uc3QgZHogPSBzY2FsZS90aGlzLmluaXRpYWxEaXN0YW5jZTtcblx0XHR0aGlzLmNhbWVyYS5kZWx0YVpvb20odGhpcy56b29tRGVsYXksIGR6LCBwb3MueCwgcG9zLnkpO1xuXHRcdHRoaXMuaW5pdGlhbERpc3RhbmNlID0gc2NhbGU7XG5cdFx0ZTEucHJldmVudERlZmF1bHQoKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHBpbmNoRW5kKGUsIHgsIHksIHNjYWxlKSB7XG5cdFx0dGhpcy56b29taW5nID0gZmFsc2U7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0bW91c2VXaGVlbChlKSB7XG5cdFx0aWYodGhpcy5jb250cm9sWm9vbSAmJiAhZS5jdHJsS2V5KSB7XG5cdFx0XHR0aGlzLmVtaXQoJ25vd2hlZWwnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IGRlbHRhID0gLWUuZGVsdGFZLzUzO1xuXHRcdC8vY29uc3QgcG9zID0gdGhpcy5jYW1lcmEubWFwVG9TY2VuZShlLm9mZnNldFgsIGUub2Zmc2V0WSwgdGhpcy5jYW1lcmEuZ2V0Q3VycmVudFRyYW5zZm9ybShwZXJmb3JtYW5jZS5ub3coKSkpO1xuXHRcdGNvbnN0IHBvcyA9IENvb3JkaW5hdGVTeXN0ZW0uZnJvbUNhbnZhc0h0bWxUb1NjZW5lKHsgeDogZS5vZmZzZXRYLCB5OiBlLm9mZnNldFkgfSwgdGhpcy5jYW1lcmEsIHRoaXMudXNlR0xjb29yZHMpO1xuXHRcdGNvbnN0IGR6ID0gTWF0aC5wb3codGhpcy56b29tQW1vdW50LCBkZWx0YSk7XHRcdFxuXHRcdHRoaXMuY2FtZXJhLmRlbHRhWm9vbSh0aGlzLnpvb21EZWxheSwgZHosIHBvcy54LCBwb3MueSk7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0ZmluZ2VyRG91YmxlVGFwKGUpIHtcblx0XHRpZighdGhpcy5hY3RpdmUgfHwgIXRoaXMuYWN0aXZlTW9kaWZpZXJzLmluY2x1ZGVzKHRoaXMubW9kaWZpZXJTdGF0ZShlKSkpXG5cdFx0XHRyZXR1cm47XG5cdFx0Ly9jb25zdCBwb3MgPSB0aGlzLmNhbWVyYS5tYXBUb1NjZW5lKGUub2Zmc2V0WCwgZS5vZmZzZXRZLCB0aGlzLmNhbWVyYS5nZXRDdXJyZW50VHJhbnNmb3JtKHBlcmZvcm1hbmNlLm5vdygpKSk7XG5cdFx0Y29uc3QgcG9zID0gQ29vcmRpbmF0ZVN5c3RlbS5mcm9tQ2FudmFzSHRtbFRvU2NlbmUoeyB4OiBlLm9mZnNldFgsIHk6IGUub2Zmc2V0WSB9LCB0aGlzLmNhbWVyYSwgdGhpcy51c2VHTGNvb3Jkcyk7XG5cblx0XHRjb25zdCBkeiA9IHRoaXMuem9vbUFtb3VudDtcblx0XHR0aGlzLmNhbWVyYS5kZWx0YVpvb20odGhpcy56b29tRGVsYXksIGR6LCBwb3MueCwgcG9zLnkpO1xuXHR9XG5cbn1cbmFkZFNpZ25hbHMoQ29udHJvbGxlclBhblpvb20sICdub3doZWVsJyk7XG5cbmV4cG9ydCB7IENvbnRyb2xsZXJQYW5ab29tIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/ControllerPanZoom.js\n");

/***/ }),

/***/ "./src/CoordinateSystem.js":
/*!*********************************!*\
  !*** ./src/CoordinateSystem.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CoordinateSystem\": () => (/* binding */ CoordinateSystem)\n/* harmony export */ });\n/* harmony import */ var _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox.js */ \"./src/BoundingBox.js\");\n/* harmony import */ var _Transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transform.js */ \"./src/Transform.js\");\n\n\n\n/**\n * Contain functions to pass between different coordinate system.\n * Here described the coordinate system in sequence\n * - CanvasHTML: Html coordinates: 0,0 left,top to width height at bottom right (y Down)\n * - CanvasContext: Same as Html, but scaled by devicePixelRatio (y Down) (required for WebGL, not for SVG)\n * - Viewport: 0,0 left,bottom to (width,height) at top right (y Up)\n * - Center: 0,0 at viewport center (y Up)\n * - Scene: 0,0 at dataset center (y Up). The dataset is placed here through the camera transform \n * - Layer: 0,0 at Layer center (y Up). Layer is placed over the dataset by the layer transform\n * - Image: 0,0 at left,top (y Down)\n * - Layout: 0,0 at left,top (y Down). Depends on layout\n */\nclass CoordinateSystem {\n    \n    /**\n     * Transform point from Viewport to CanvasHTML\n     * @param {*} p point in Viewport: 0,0 at left,bottom\n     * @param {Camera} camera Camera which contains viewport information\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns  point in CanvasHtml: 0,0 left,top\n     */\n     static fromViewportToCanvasHtml(p, camera, useGL) {\n        const viewport = this.getViewport(camera, useGL);\n        let result = this.invertY(p, viewport);\n        return useGL ? this.scale(result, 1/window.devicePixelRatio) : result;\n    }\n\n    /**\n     * Transform point from CanvasHTML to GLViewport\n     * @param {*} p point in CanvasHtml: 0,0 left,top y Down\n     * @param {Camera} camera Camera\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns  point in GLViewport: 0,0 left,bottom, scaled by devicePixelRatio\n     */\n     static fromCanvasHtmlToViewport(p, camera, useGL) {\n        let result = useGL ? this.scale(p, window.devicePixelRatio) : p;\n        const viewport = this.getViewport(camera, useGL);\n        return this.invertY(result, viewport);\n    }\n\n    \n    /**\n     * Transform a point from Viewport to Layer coordinates\n     * @param {*} p point {x,y} in Viewport (0,0 left,bottom, y Up)\n     * @param {Camera} camera camera\n     * @param {Transform} layerT layer transform\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns point in Layer coordinates (0, 0 at layer center, y Up)\n     */\n     static fromViewportToLayer(p, camera, layerT, useGL) {\n       // M = InvLayerT * InvCameraT  * Tr(-Vw/2, -Vh/2)\n       const cameraT = this.getCurrentTransform(camera, useGL);\n       const invCameraT = cameraT.inverse();\n       const invLayerT = layerT.inverse();\n       const v2c = this.getFromViewportToCenterTransform(camera, useGL);\n       const M = v2c.compose(invCameraT.compose(invLayerT)); // First apply v2c, then invCamera, then invLayer\n        \n       return M.apply(p.x, p.y);\n    }\n\n    /**\n     * Transform a point from Layer to Viewport coordinates\n     * @param {*} p point {x,y} Layer (0,0 at Layer center y Up)\n     * @param {Camera} camera \n     * @param {Transform} layerT layer transform\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns point in viewport coordinates (0,0 at left,bottom y Up)\n     */\n     static fromLayerToViewport(p, camera, layerT, useGL) {\n        const M = this.getFromLayerToViewportTransform(camera, layerT, useGL);\n        return M.apply(p.x, p.y);\n     }\n\n    /**\n     * Transform a point from Layer to Center \n     * @param {*} p point {x,y} in Layer coordinates (0,0 at Layer center)\n     * @param {Camera} camera camera\n     * @param {Transform} layerT layer transform\n     * @returns point in Center (0, 0 at glViewport center) coordinates.\n     */\n     static fromLayerToCenter(p, camera, layerT, useGL) {\n        // M = cameraT * layerT\n        const cameraT = this.getCurrentTransform(camera, useGL);\n        const M = layerT.compose(cameraT);\n\n        return  M.apply(p.x, p.y);\n    }\n\n    ////////////// CHECKED UP TO HERE ////////////////////\n\n    /**\n     * Transform a point from Layer to Image coordinates\n     * @param {*} p point {x, y} Layer coordinates (0,0 at Layer center)\n     * @param {*} layerSize {w, h} Size in pixel of the Layer\n     * @returns  Point in Image coordinates (0,0 at left,top, y Down)\n     */\n     static fromLayerToImage(p, layerSize) {\n        // InvertY * Tr(Lw/2, Lh/2)\n        let result  = {x: p.x + layerSize.w/2, y: p.y + layerSize.h/2};\n        return this.invertY(result, layerSize);\n    }\n    \n    /**\n     * Transform a point from CanvasHtml to Scene\n     * @param {*} p point {x, y} in CanvasHtml (0,0 left,top, y Down)\n     * @param {Camera} camera camera\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns Point in Scene coordinates (0,0 at scene center, y Up)\n     */\n     static fromCanvasHtmlToScene(p, camera, useGL) {\n        // invCameraT * Tr(-Vw/2, -Vh/2) * InvertY  * [Scale(devPixRatio)]\n        let result = this.fromCanvasHtmlToViewport(p, camera, useGL);\n        const v2c = this.getFromViewportToCenterTransform(camera, useGL);\n        const invCameraT = this.getCurrentTransform(camera, useGL).inverse();\n        const M = v2c.compose(invCameraT);\n\n        return  M.apply(result.x, result.y);\n    }\n\n    /**\n     * Transform a point from Scene to CanvasHtml\n     * @param {*} p point {x, y} Scene coordinates (0,0 at scene center, y Up)\n     * @param {Camera} camera camera\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns Point in CanvasHtml (0,0 left,top, y Down)\n     */\n    static fromSceneToCanvasHtml(p, camera, useGL) {\n        // invCameraT * Tr(-Vw/2, -Vh/2) * InvertY  * [Scale(devPixRatio)]\n        let result = this.fromSceneToViewport(p, camera, useGL)\n        return this.fromViewportToCanvasHtml(result, camera, useGL);\n    }\n\n    /**\n     * Transform a point from Scene to Viewport\n     * @param {*} p point {x, y} Scene coordinates (0,0 at scene center, y Up)\n     * @param {Camera} camera camera\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns Point in Viewport (0,0 left,bottom, y Up)\n     */\n    static fromSceneToViewport(p, camera, useGL) {\n        // FromCenterToViewport * CamT\n        const c2v = this.getFromViewportToCenterTransform(camera, useGL).inverse();\n        const CameraT = this.getCurrentTransform(camera, useGL);\n        const M = CameraT.compose(c2v);\n\n        return  M.apply(p.x, p.y);\n    }\n    \n    /**\n     * Transform a point from Scene to Viewport, using given transform and viewport\n     * @param {*} p point {x, y} Scene coordinates (0,0 at scene center, y Up)\n     * @param {Transform} cameraT camera transform\n     * @param {*} viewport viewport {x,y,dx,dy,w,h}\n     * @returns Point in Viewport (0,0 left,bottom, y Up)\n     */\n    static fromSceneToViewportNoCamera(p, cameraT, viewport) {\n        // invCameraT * Tr(-Vw/2, -Vh/2) * InvertY  * [Scale(devPixRatio)]\n        const c2v = this.getFromViewportToCenterTransformNoCamera(viewport).inverse();\n        const M = cameraT.compose(c2v);\n\n        return  M.apply(p.x, p.y);\n    }\n        \n    /**\n     * Transform a point from Viewport to Scene.\n     * @param {*} p point {x, y} Viewport coordinates (0,0 at left,bottom, y Up)\n     * @param {Camera} camera camera\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns Point in Viewport (0,0 at scene center, y Up)\n     */\n     static fromViewportToScene(p, camera, useGL) {\n        // invCamT * FromViewportToCenter \n        const v2c = this.getFromViewportToCenterTransform(camera, useGL);\n        const invCameraT = this.getCurrentTransform(camera, useGL).inverse();\n        const M = v2c.compose(invCameraT);\n\n        return  M.apply(p.x, p.y);\n    }\n\n    /**\n     * Transform a point from Viewport to Scene, using given transform and viewport\n     * @param {*} p point {x, y} Viewport coordinates (0,0 at left,bottom, y Up)\n     * @param {Transform} cameraT camera transform\n     * @param {*} viewport viewport {x,y,dx,dy,w,h}\n     * @returns Point in Viewport (0,0 at scene center, y Up)\n     */\n    static fromViewportToSceneNoCamera(p, cameraT, viewport) {\n        // invCamT * FromViewportToCenter \n        const v2c = this.getFromViewportToCenterTransformNoCamera(viewport);\n        const invCameraT = cameraT.inverse();\n        const M = v2c.compose(invCameraT);\n\n        return  M.apply(p.x, p.y);\n    }\n    \n    /**\n     * Transform a point from CanvasHtml to Image\n     * @param {*} p  point {x, y} in CanvasHtml (0,0 left,top, y Down)\n     * @param {Camera} camera camera \n     * @param {Transform} layerT layer transform \n     * @param {*} layerSize  {w, h} Size in pixel of the Layer\n     * @param {bool} applyGLScale if true apply devPixelRatio scale. Keep it false when working with SVG\n     * @returns Point in Image space (0,0 left,top of the image, y Down)\n     */\n     static fromCanvasHtmlToImage(p, camera, layerT, layerSize, useGL) {\n        // Translate(Lw/2, Lh/2) * InvLayerT * InvCameraT *  Translate(-Vw/2, -Vh/2) * invertY * [Scale(devicePixelRatio)]\n        // in other words... fromLayerToImage * invLayerT * fromCanvasHtmlToScene\n        let result = this.fromCanvasHtmlToScene(p, camera, useGL);\n        const invLayerT = layerT.inverse();\n        result = invLayerT.apply(result.x, result.y);\n        result = this.fromLayerToImage(result, layerSize);\n\n        return result;\n    }\n\n    /**\n     * Transform a box from Viewport to Image coordinates\n     * @param {BoundingBox} box in Viewport coordinates (0,0 at left,bottom, y Up)\n     * @param {Transform} cameraT camera Transform\n     * @param {*} viewport {x,y,dx,dy,w,h}\n     * @param {Transform} layerT layer transform\n     * @param {*} layerSize {w,h} layer pixel size\n     * @returns box in Image coordinates (0,0 left,top, y Dowm)\n     */\n     static fromViewportBoxToImageBox(box, cameraT, viewport, layerT, layerSize) {\n        // InvertYonImage * T(Lw/2, Lh/2) * InvL * InvCam * T(-Vw/2,-Vh/2) \n        let V2C = new _Transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform({x:-viewport.w/2, y:-viewport.h/2});\n        let C2S = cameraT.inverse();\n        let S2L = layerT.inverse();\n        let L2I = new _Transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform({x:layerSize.w/2, y:layerSize.h/2});\n        let M = V2C.compose(C2S.compose(S2L.compose(L2I)));\n        let resultBox = new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\n\t\tfor(let i = 0; i < 4; ++i) {\n            let p = box.corner(i);\n            p = M.apply(p.x, p.y);\n            p = CoordinateSystem.invertY(p, layerSize);\n\t\t\tresultBox.mergePoint(p);\n\t\t}\n        return resultBox;\n    }\n\n    /**\n     * Transform a box from Layer to Scene \n     * @param {BoundingBox} box  box in Layer coordinates (0,0 at layer center)\n     * @param {Transform} layerT layer transform\n     * @returns box in Scene coordinates (0,0 at scene center)\n     */\n     static fromLayerBoxToSceneBox(box, layerT) {\n         return layerT.transformBox(box); \n    }\n  \n    /**\n     * Transform a box from Scene to Layer \n     * @param {BoundingBox} box  box in Layer coordinates (0,0 at layer center)\n     * @param {Transform} layerT layer transform\n     * @returns box in Scene coordinates (0,0 at scene center)\n     */\n     static fromSceneBoxToLayerBox(box, layerT) {\n        return layerT.inverse().transformBox(box); \n   }\n\n    /**\n     * Transform a box from Layer to Viewport coordinates\n     * @param {BoundingBox} box box in Layer coordinates (0,0 at Layer center y Up)\n     * @param {Camera} camera \n     * @param {Transform} layerT layer transform\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns Box in Viewport coordinates (0,0 at left, bottom y Up)\n     */\n     static fromLayerBoxToViewportBox(box, camera, layerT, useGL) {\n        const M = this.getFromLayerToViewportTransform(camera, layerT, useGL);\n        return M.transformBox(box);  \n    }\n\n    /**\n     * Transform a box from Layer to Viewport coordinates\n     * @param {BoundingBox} box box in Layer coordinates (0,0 at Layer center y Up)\n     * @param {Camera} camera \n     * @param {Transform} layerT layer transform\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns Box in Viewport coordinates (0,0 at left, bottom y Up)\n     */\n     static fromViewportBoxToLayerBox(box, camera, layerT, useGL) {\n        const M = this.getFromLayerToViewportTransform(camera, layerT, useGL).inverse();\n        return M.transformBox(box);  \n    }\n\n    /**\n     * Get a transform to go from viewport 0,0 at left, bottom y Up, to Center 0,0 at viewport center\n     * @param {Camera} camera camera\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns transform from Viewport to Center\n     */\n     static getFromViewportToCenterTransform(camera, useGL) {\n        const viewport = this.getViewport(camera, useGL);\n        return this.getFromViewportToCenterTransformNoCamera(viewport);\n    }\n\n    /**\n     * Get a transform to go from viewport 0,0 at left, bottom y Up, to Center 0,0 at viewport center\n     * from explicit viewport param. (Not using camera parameter here)\n     * @param {*} viewport viewport\n     * @returns transform from Viewport to Center\n     */\n    static getFromViewportToCenterTransformNoCamera(viewport) {\n        return new _Transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform({x:viewport.x-viewport.w/2, y:viewport.y-viewport.h/2, z:1, a:0, t:0});\n    }\n\n    /**\n     * Return transform with y reflected wrt origin (y=-y)\n     * @param {Transform} t  \n     * @returns {Transform} transform, with y reflected (around 0)\n     */\n    static reflectY(t) {\n        return new _Transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform({x:t.x, y:-t.y, z:t.z, a:t.a, t:t.t});\n    }\n\n    /**\n     * Get a transform to go from Layer (0,0 at Layer center y Up) to Viewport (0,0 at left,bottom y Up)\n     * @param {Camera} camera \n     * @param {Transform} layerT layer transform\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true, it uses devPixelRatio scale\n     * @returns transform from Layer to Viewport\n     */\n     static getFromLayerToViewportTransform(camera, layerT, useGL) {\n        // M =  Center2Viewport * CameraT  * LayerT\n        const cameraT = this.getCurrentTransform(camera, useGL);\n        const c2v = this.getFromViewportToCenterTransform(camera, useGL).inverse();\n        const M = layerT.compose(cameraT.compose(c2v));\n        return M;\n    }\n\n    /**\n     * Get a transform to go from Layer (0,0 at Layer center y Up) to Viewport (0,0 at left,bottom y Up)\n     * @param {Transform} CameraT camera transform\n     * @param {viewport} viewport {x,y,dx,dy,w,h} viewport\n     * @param {Transform} layerT layer transform\n     * @returns transform from Layer to Viewport\n     */\n    static getFromLayerToViewportTransformNoCamera(cameraT, viewport, layerT) {\n        // M =  Center2Viewport * CameraT  * LayerT\n        const c2v =  this.getFromViewportToCenterTransformNoCamera(viewport).inverse();\n        const M = layerT.compose(cameraT.compose(c2v));\n        return M;\n    }\n    \n\n    /**\n     * Scale x applying f scale factor\n     * @param {*} p Point to be scaled\n     * @param {Number} f Scale factor\n     * @returns Point in CanvasContext (Scaled by devicePixelRation)\n     */\n    static scale(p, f) {\n        return { x:p.x * f, y:p.y * f};\n    }\n\n    /**\n     * Invert y with respect to viewport.h\n     * @param {*} p Point to be transformed \n     * @param {*} viewport current viewport\n     * @returns Point with y inverted with respect to viewport.h\n     */\n    static invertY(p, viewport) {\n        return {x:p.x, y:viewport.h - p.y};\n    }\n\n    /**\n     * Return the camera viewport: scaled by devicePixelRatio if useGL is true.\n     * @param {bool} useGL True to work with WebGL, false for SVG. When true viewport scaled by devPixelRatio \n     * @returns Viewport \n     */\n    static getViewport(camera, useGL) {\n        return useGL ? camera.glViewport() : camera.viewport;\n    }\n\n    static getCurrentTransform(camera, useGL) {\n        let cameraT = useGL ?\n                        camera.getGlCurrentTransform(performance.now()) :\n                        camera.getCurrentTransform(performance.now());\n       \n        return cameraT;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29vcmRpbmF0ZVN5c3RlbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDTDs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHLFNBQVMsS0FBSztBQUNoQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHLFNBQVMsS0FBSztBQUNoQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRyxTQUFTLEtBQUs7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHLFNBQVMsTUFBTTtBQUNqQyxlQUFlLEdBQUcsV0FBVyxNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUcsU0FBUyxNQUFNO0FBQ2pDLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEdBQUcsU0FBUyxNQUFNO0FBQ2pDLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRyxTQUFTLE1BQU07QUFDakMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHLFNBQVMsTUFBTTtBQUNqQyxlQUFlLFdBQVc7QUFDMUIsZUFBZSxHQUFHLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRyxTQUFTLE1BQU07QUFDakMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEdBQUcsU0FBUyxNQUFNO0FBQ2pDLGVBQWUsV0FBVztBQUMxQixlQUFlLEdBQUcsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUcsVUFBVSxNQUFNO0FBQ2xDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxHQUFHLFlBQVksTUFBTTtBQUNwQyxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxHQUFHLFVBQVU7QUFDNUIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsR0FBRyxXQUFXLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQVMsRUFBRSxpQ0FBaUM7QUFDbEU7QUFDQTtBQUNBLHNCQUFzQixvREFBUyxFQUFFLGlDQUFpQztBQUNsRTtBQUNBLDRCQUE0Qix3REFBVztBQUN2QyxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFTLEVBQUUsb0VBQW9FO0FBQ2xHOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBLG1CQUFtQixvREFBUyxFQUFFLG1DQUFtQztBQUNqRTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVLFVBQVUsZUFBZTtBQUNsRCxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9Db29yZGluYXRlU3lzdGVtLmpzP2Y2ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICcuL0JvdW5kaW5nQm94LmpzJztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJy4vVHJhbnNmb3JtLmpzJ1xuXG4vKipcbiAqIENvbnRhaW4gZnVuY3Rpb25zIHRvIHBhc3MgYmV0d2VlbiBkaWZmZXJlbnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBIZXJlIGRlc2NyaWJlZCB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gaW4gc2VxdWVuY2VcbiAqIC0gQ2FudmFzSFRNTDogSHRtbCBjb29yZGluYXRlczogMCwwIGxlZnQsdG9wIHRvIHdpZHRoIGhlaWdodCBhdCBib3R0b20gcmlnaHQgKHkgRG93bilcbiAqIC0gQ2FudmFzQ29udGV4dDogU2FtZSBhcyBIdG1sLCBidXQgc2NhbGVkIGJ5IGRldmljZVBpeGVsUmF0aW8gKHkgRG93bikgKHJlcXVpcmVkIGZvciBXZWJHTCwgbm90IGZvciBTVkcpXG4gKiAtIFZpZXdwb3J0OiAwLDAgbGVmdCxib3R0b20gdG8gKHdpZHRoLGhlaWdodCkgYXQgdG9wIHJpZ2h0ICh5IFVwKVxuICogLSBDZW50ZXI6IDAsMCBhdCB2aWV3cG9ydCBjZW50ZXIgKHkgVXApXG4gKiAtIFNjZW5lOiAwLDAgYXQgZGF0YXNldCBjZW50ZXIgKHkgVXApLiBUaGUgZGF0YXNldCBpcyBwbGFjZWQgaGVyZSB0aHJvdWdoIHRoZSBjYW1lcmEgdHJhbnNmb3JtIFxuICogLSBMYXllcjogMCwwIGF0IExheWVyIGNlbnRlciAoeSBVcCkuIExheWVyIGlzIHBsYWNlZCBvdmVyIHRoZSBkYXRhc2V0IGJ5IHRoZSBsYXllciB0cmFuc2Zvcm1cbiAqIC0gSW1hZ2U6IDAsMCBhdCBsZWZ0LHRvcCAoeSBEb3duKVxuICogLSBMYXlvdXQ6IDAsMCBhdCBsZWZ0LHRvcCAoeSBEb3duKS4gRGVwZW5kcyBvbiBsYXlvdXRcbiAqL1xuY2xhc3MgQ29vcmRpbmF0ZVN5c3RlbSB7XG4gICAgXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHBvaW50IGZyb20gVmlld3BvcnQgdG8gQ2FudmFzSFRNTFxuICAgICAqIEBwYXJhbSB7Kn0gcCBwb2ludCBpbiBWaWV3cG9ydDogMCwwIGF0IGxlZnQsYm90dG9tXG4gICAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBDYW1lcmEgd2hpY2ggY29udGFpbnMgdmlld3BvcnQgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2x9IHVzZUdMIFRydWUgdG8gd29yayB3aXRoIFdlYkdMLCBmYWxzZSBmb3IgU1ZHLiBXaGVuIHRydWUsIGl0IHVzZXMgZGV2UGl4ZWxSYXRpbyBzY2FsZVxuICAgICAqIEByZXR1cm5zICBwb2ludCBpbiBDYW52YXNIdG1sOiAwLDAgbGVmdCx0b3BcbiAgICAgKi9cbiAgICAgc3RhdGljIGZyb21WaWV3cG9ydFRvQ2FudmFzSHRtbChwLCBjYW1lcmEsIHVzZUdMKSB7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydChjYW1lcmEsIHVzZUdMKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuaW52ZXJ0WShwLCB2aWV3cG9ydCk7XG4gICAgICAgIHJldHVybiB1c2VHTCA/IHRoaXMuc2NhbGUocmVzdWx0LCAxL3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gcG9pbnQgZnJvbSBDYW52YXNIVE1MIHRvIEdMVmlld3BvcnRcbiAgICAgKiBAcGFyYW0geyp9IHAgcG9pbnQgaW4gQ2FudmFzSHRtbDogMCwwIGxlZnQsdG9wIHkgRG93blxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgQ2FtZXJhXG4gICAgICogQHBhcmFtIHtib29sfSB1c2VHTCBUcnVlIHRvIHdvcmsgd2l0aCBXZWJHTCwgZmFsc2UgZm9yIFNWRy4gV2hlbiB0cnVlLCBpdCB1c2VzIGRldlBpeGVsUmF0aW8gc2NhbGVcbiAgICAgKiBAcmV0dXJucyAgcG9pbnQgaW4gR0xWaWV3cG9ydDogMCwwIGxlZnQsYm90dG9tLCBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAqL1xuICAgICBzdGF0aWMgZnJvbUNhbnZhc0h0bWxUb1ZpZXdwb3J0KHAsIGNhbWVyYSwgdXNlR0wpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHVzZUdMID8gdGhpcy5zY2FsZShwLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgOiBwO1xuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoY2FtZXJhLCB1c2VHTCk7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVydFkocmVzdWx0LCB2aWV3cG9ydCk7XG4gICAgfVxuXG4gICAgXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgcG9pbnQgZnJvbSBWaWV3cG9ydCB0byBMYXllciBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7Kn0gcCBwb2ludCB7eCx5fSBpbiBWaWV3cG9ydCAoMCwwIGxlZnQsYm90dG9tLCB5IFVwKVxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgY2FtZXJhXG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IGxheWVyVCBsYXllciB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge2Jvb2x9IHVzZUdMIFRydWUgdG8gd29yayB3aXRoIFdlYkdMLCBmYWxzZSBmb3IgU1ZHLiBXaGVuIHRydWUsIGl0IHVzZXMgZGV2UGl4ZWxSYXRpbyBzY2FsZVxuICAgICAqIEByZXR1cm5zIHBvaW50IGluIExheWVyIGNvb3JkaW5hdGVzICgwLCAwIGF0IGxheWVyIGNlbnRlciwgeSBVcClcbiAgICAgKi9cbiAgICAgc3RhdGljIGZyb21WaWV3cG9ydFRvTGF5ZXIocCwgY2FtZXJhLCBsYXllclQsIHVzZUdMKSB7XG4gICAgICAgLy8gTSA9IEludkxheWVyVCAqIEludkNhbWVyYVQgICogVHIoLVZ3LzIsIC1WaC8yKVxuICAgICAgIGNvbnN0IGNhbWVyYVQgPSB0aGlzLmdldEN1cnJlbnRUcmFuc2Zvcm0oY2FtZXJhLCB1c2VHTCk7XG4gICAgICAgY29uc3QgaW52Q2FtZXJhVCA9IGNhbWVyYVQuaW52ZXJzZSgpO1xuICAgICAgIGNvbnN0IGludkxheWVyVCA9IGxheWVyVC5pbnZlcnNlKCk7XG4gICAgICAgY29uc3QgdjJjID0gdGhpcy5nZXRGcm9tVmlld3BvcnRUb0NlbnRlclRyYW5zZm9ybShjYW1lcmEsIHVzZUdMKTtcbiAgICAgICBjb25zdCBNID0gdjJjLmNvbXBvc2UoaW52Q2FtZXJhVC5jb21wb3NlKGludkxheWVyVCkpOyAvLyBGaXJzdCBhcHBseSB2MmMsIHRoZW4gaW52Q2FtZXJhLCB0aGVuIGludkxheWVyXG4gICAgICAgIFxuICAgICAgIHJldHVybiBNLmFwcGx5KHAueCwgcC55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBmcm9tIExheWVyIHRvIFZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHsqfSBwIHBvaW50IHt4LHl9IExheWVyICgwLDAgYXQgTGF5ZXIgY2VudGVyIHkgVXApXG4gICAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBcbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gbGF5ZXJUIGxheWVyIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gdXNlR0wgVHJ1ZSB0byB3b3JrIHdpdGggV2ViR0wsIGZhbHNlIGZvciBTVkcuIFdoZW4gdHJ1ZSwgaXQgdXNlcyBkZXZQaXhlbFJhdGlvIHNjYWxlXG4gICAgICogQHJldHVybnMgcG9pbnQgaW4gdmlld3BvcnQgY29vcmRpbmF0ZXMgKDAsMCBhdCBsZWZ0LGJvdHRvbSB5IFVwKVxuICAgICAqL1xuICAgICBzdGF0aWMgZnJvbUxheWVyVG9WaWV3cG9ydChwLCBjYW1lcmEsIGxheWVyVCwgdXNlR0wpIHtcbiAgICAgICAgY29uc3QgTSA9IHRoaXMuZ2V0RnJvbUxheWVyVG9WaWV3cG9ydFRyYW5zZm9ybShjYW1lcmEsIGxheWVyVCwgdXNlR0wpO1xuICAgICAgICByZXR1cm4gTS5hcHBseShwLngsIHAueSk7XG4gICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIHBvaW50IGZyb20gTGF5ZXIgdG8gQ2VudGVyIFxuICAgICAqIEBwYXJhbSB7Kn0gcCBwb2ludCB7eCx5fSBpbiBMYXllciBjb29yZGluYXRlcyAoMCwwIGF0IExheWVyIGNlbnRlcilcbiAgICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIGNhbWVyYVxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtfSBsYXllclQgbGF5ZXIgdHJhbnNmb3JtXG4gICAgICogQHJldHVybnMgcG9pbnQgaW4gQ2VudGVyICgwLCAwIGF0IGdsVmlld3BvcnQgY2VudGVyKSBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICAgc3RhdGljIGZyb21MYXllclRvQ2VudGVyKHAsIGNhbWVyYSwgbGF5ZXJULCB1c2VHTCkge1xuICAgICAgICAvLyBNID0gY2FtZXJhVCAqIGxheWVyVFxuICAgICAgICBjb25zdCBjYW1lcmFUID0gdGhpcy5nZXRDdXJyZW50VHJhbnNmb3JtKGNhbWVyYSwgdXNlR0wpO1xuICAgICAgICBjb25zdCBNID0gbGF5ZXJULmNvbXBvc2UoY2FtZXJhVCk7XG5cbiAgICAgICAgcmV0dXJuICBNLmFwcGx5KHAueCwgcC55KTtcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLyBDSEVDS0VEIFVQIFRPIEhFUkUgLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIHBvaW50IGZyb20gTGF5ZXIgdG8gSW1hZ2UgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0geyp9IHAgcG9pbnQge3gsIHl9IExheWVyIGNvb3JkaW5hdGVzICgwLDAgYXQgTGF5ZXIgY2VudGVyKVxuICAgICAqIEBwYXJhbSB7Kn0gbGF5ZXJTaXplIHt3LCBofSBTaXplIGluIHBpeGVsIG9mIHRoZSBMYXllclxuICAgICAqIEByZXR1cm5zICBQb2ludCBpbiBJbWFnZSBjb29yZGluYXRlcyAoMCwwIGF0IGxlZnQsdG9wLCB5IERvd24pXG4gICAgICovXG4gICAgIHN0YXRpYyBmcm9tTGF5ZXJUb0ltYWdlKHAsIGxheWVyU2l6ZSkge1xuICAgICAgICAvLyBJbnZlcnRZICogVHIoTHcvMiwgTGgvMilcbiAgICAgICAgbGV0IHJlc3VsdCAgPSB7eDogcC54ICsgbGF5ZXJTaXplLncvMiwgeTogcC55ICsgbGF5ZXJTaXplLmgvMn07XG4gICAgICAgIHJldHVybiB0aGlzLmludmVydFkocmVzdWx0LCBsYXllclNpemUpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBmcm9tIENhbnZhc0h0bWwgdG8gU2NlbmVcbiAgICAgKiBAcGFyYW0geyp9IHAgcG9pbnQge3gsIHl9IGluIENhbnZhc0h0bWwgKDAsMCBsZWZ0LHRvcCwgeSBEb3duKVxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgY2FtZXJhXG4gICAgICogQHBhcmFtIHtib29sfSB1c2VHTCBUcnVlIHRvIHdvcmsgd2l0aCBXZWJHTCwgZmFsc2UgZm9yIFNWRy4gV2hlbiB0cnVlLCBpdCB1c2VzIGRldlBpeGVsUmF0aW8gc2NhbGVcbiAgICAgKiBAcmV0dXJucyBQb2ludCBpbiBTY2VuZSBjb29yZGluYXRlcyAoMCwwIGF0IHNjZW5lIGNlbnRlciwgeSBVcClcbiAgICAgKi9cbiAgICAgc3RhdGljIGZyb21DYW52YXNIdG1sVG9TY2VuZShwLCBjYW1lcmEsIHVzZUdMKSB7XG4gICAgICAgIC8vIGludkNhbWVyYVQgKiBUcigtVncvMiwgLVZoLzIpICogSW52ZXJ0WSAgKiBbU2NhbGUoZGV2UGl4UmF0aW8pXVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5mcm9tQ2FudmFzSHRtbFRvVmlld3BvcnQocCwgY2FtZXJhLCB1c2VHTCk7XG4gICAgICAgIGNvbnN0IHYyYyA9IHRoaXMuZ2V0RnJvbVZpZXdwb3J0VG9DZW50ZXJUcmFuc2Zvcm0oY2FtZXJhLCB1c2VHTCk7XG4gICAgICAgIGNvbnN0IGludkNhbWVyYVQgPSB0aGlzLmdldEN1cnJlbnRUcmFuc2Zvcm0oY2FtZXJhLCB1c2VHTCkuaW52ZXJzZSgpO1xuICAgICAgICBjb25zdCBNID0gdjJjLmNvbXBvc2UoaW52Q2FtZXJhVCk7XG5cbiAgICAgICAgcmV0dXJuICBNLmFwcGx5KHJlc3VsdC54LCByZXN1bHQueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgcG9pbnQgZnJvbSBTY2VuZSB0byBDYW52YXNIdG1sXG4gICAgICogQHBhcmFtIHsqfSBwIHBvaW50IHt4LCB5fSBTY2VuZSBjb29yZGluYXRlcyAoMCwwIGF0IHNjZW5lIGNlbnRlciwgeSBVcClcbiAgICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIGNhbWVyYVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gdXNlR0wgVHJ1ZSB0byB3b3JrIHdpdGggV2ViR0wsIGZhbHNlIGZvciBTVkcuIFdoZW4gdHJ1ZSwgaXQgdXNlcyBkZXZQaXhlbFJhdGlvIHNjYWxlXG4gICAgICogQHJldHVybnMgUG9pbnQgaW4gQ2FudmFzSHRtbCAoMCwwIGxlZnQsdG9wLCB5IERvd24pXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TY2VuZVRvQ2FudmFzSHRtbChwLCBjYW1lcmEsIHVzZUdMKSB7XG4gICAgICAgIC8vIGludkNhbWVyYVQgKiBUcigtVncvMiwgLVZoLzIpICogSW52ZXJ0WSAgKiBbU2NhbGUoZGV2UGl4UmF0aW8pXVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5mcm9tU2NlbmVUb1ZpZXdwb3J0KHAsIGNhbWVyYSwgdXNlR0wpXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21WaWV3cG9ydFRvQ2FudmFzSHRtbChyZXN1bHQsIGNhbWVyYSwgdXNlR0wpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIHBvaW50IGZyb20gU2NlbmUgdG8gVmlld3BvcnRcbiAgICAgKiBAcGFyYW0geyp9IHAgcG9pbnQge3gsIHl9IFNjZW5lIGNvb3JkaW5hdGVzICgwLDAgYXQgc2NlbmUgY2VudGVyLCB5IFVwKVxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgY2FtZXJhXG4gICAgICogQHBhcmFtIHtib29sfSB1c2VHTCBUcnVlIHRvIHdvcmsgd2l0aCBXZWJHTCwgZmFsc2UgZm9yIFNWRy4gV2hlbiB0cnVlLCBpdCB1c2VzIGRldlBpeGVsUmF0aW8gc2NhbGVcbiAgICAgKiBAcmV0dXJucyBQb2ludCBpbiBWaWV3cG9ydCAoMCwwIGxlZnQsYm90dG9tLCB5IFVwKVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NlbmVUb1ZpZXdwb3J0KHAsIGNhbWVyYSwgdXNlR0wpIHtcbiAgICAgICAgLy8gRnJvbUNlbnRlclRvVmlld3BvcnQgKiBDYW1UXG4gICAgICAgIGNvbnN0IGMydiA9IHRoaXMuZ2V0RnJvbVZpZXdwb3J0VG9DZW50ZXJUcmFuc2Zvcm0oY2FtZXJhLCB1c2VHTCkuaW52ZXJzZSgpO1xuICAgICAgICBjb25zdCBDYW1lcmFUID0gdGhpcy5nZXRDdXJyZW50VHJhbnNmb3JtKGNhbWVyYSwgdXNlR0wpO1xuICAgICAgICBjb25zdCBNID0gQ2FtZXJhVC5jb21wb3NlKGMydik7XG5cbiAgICAgICAgcmV0dXJuICBNLmFwcGx5KHAueCwgcC55KTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgcG9pbnQgZnJvbSBTY2VuZSB0byBWaWV3cG9ydCwgdXNpbmcgZ2l2ZW4gdHJhbnNmb3JtIGFuZCB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7Kn0gcCBwb2ludCB7eCwgeX0gU2NlbmUgY29vcmRpbmF0ZXMgKDAsMCBhdCBzY2VuZSBjZW50ZXIsIHkgVXApXG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IGNhbWVyYVQgY2FtZXJhIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Kn0gdmlld3BvcnQgdmlld3BvcnQge3gseSxkeCxkeSx3LGh9XG4gICAgICogQHJldHVybnMgUG9pbnQgaW4gVmlld3BvcnQgKDAsMCBsZWZ0LGJvdHRvbSwgeSBVcClcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjZW5lVG9WaWV3cG9ydE5vQ2FtZXJhKHAsIGNhbWVyYVQsIHZpZXdwb3J0KSB7XG4gICAgICAgIC8vIGludkNhbWVyYVQgKiBUcigtVncvMiwgLVZoLzIpICogSW52ZXJ0WSAgKiBbU2NhbGUoZGV2UGl4UmF0aW8pXVxuICAgICAgICBjb25zdCBjMnYgPSB0aGlzLmdldEZyb21WaWV3cG9ydFRvQ2VudGVyVHJhbnNmb3JtTm9DYW1lcmEodmlld3BvcnQpLmludmVyc2UoKTtcbiAgICAgICAgY29uc3QgTSA9IGNhbWVyYVQuY29tcG9zZShjMnYpO1xuXG4gICAgICAgIHJldHVybiAgTS5hcHBseShwLngsIHAueSk7XG4gICAgfVxuICAgICAgICBcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBmcm9tIFZpZXdwb3J0IHRvIFNjZW5lLlxuICAgICAqIEBwYXJhbSB7Kn0gcCBwb2ludCB7eCwgeX0gVmlld3BvcnQgY29vcmRpbmF0ZXMgKDAsMCBhdCBsZWZ0LGJvdHRvbSwgeSBVcClcbiAgICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIGNhbWVyYVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gdXNlR0wgVHJ1ZSB0byB3b3JrIHdpdGggV2ViR0wsIGZhbHNlIGZvciBTVkcuIFdoZW4gdHJ1ZSwgaXQgdXNlcyBkZXZQaXhlbFJhdGlvIHNjYWxlXG4gICAgICogQHJldHVybnMgUG9pbnQgaW4gVmlld3BvcnQgKDAsMCBhdCBzY2VuZSBjZW50ZXIsIHkgVXApXG4gICAgICovXG4gICAgIHN0YXRpYyBmcm9tVmlld3BvcnRUb1NjZW5lKHAsIGNhbWVyYSwgdXNlR0wpIHtcbiAgICAgICAgLy8gaW52Q2FtVCAqIEZyb21WaWV3cG9ydFRvQ2VudGVyIFxuICAgICAgICBjb25zdCB2MmMgPSB0aGlzLmdldEZyb21WaWV3cG9ydFRvQ2VudGVyVHJhbnNmb3JtKGNhbWVyYSwgdXNlR0wpO1xuICAgICAgICBjb25zdCBpbnZDYW1lcmFUID0gdGhpcy5nZXRDdXJyZW50VHJhbnNmb3JtKGNhbWVyYSwgdXNlR0wpLmludmVyc2UoKTtcbiAgICAgICAgY29uc3QgTSA9IHYyYy5jb21wb3NlKGludkNhbWVyYVQpO1xuXG4gICAgICAgIHJldHVybiAgTS5hcHBseShwLngsIHAueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgcG9pbnQgZnJvbSBWaWV3cG9ydCB0byBTY2VuZSwgdXNpbmcgZ2l2ZW4gdHJhbnNmb3JtIGFuZCB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7Kn0gcCBwb2ludCB7eCwgeX0gVmlld3BvcnQgY29vcmRpbmF0ZXMgKDAsMCBhdCBsZWZ0LGJvdHRvbSwgeSBVcClcbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gY2FtZXJhVCBjYW1lcmEgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHsqfSB2aWV3cG9ydCB2aWV3cG9ydCB7eCx5LGR4LGR5LHcsaH1cbiAgICAgKiBAcmV0dXJucyBQb2ludCBpbiBWaWV3cG9ydCAoMCwwIGF0IHNjZW5lIGNlbnRlciwgeSBVcClcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVZpZXdwb3J0VG9TY2VuZU5vQ2FtZXJhKHAsIGNhbWVyYVQsIHZpZXdwb3J0KSB7XG4gICAgICAgIC8vIGludkNhbVQgKiBGcm9tVmlld3BvcnRUb0NlbnRlciBcbiAgICAgICAgY29uc3QgdjJjID0gdGhpcy5nZXRGcm9tVmlld3BvcnRUb0NlbnRlclRyYW5zZm9ybU5vQ2FtZXJhKHZpZXdwb3J0KTtcbiAgICAgICAgY29uc3QgaW52Q2FtZXJhVCA9IGNhbWVyYVQuaW52ZXJzZSgpO1xuICAgICAgICBjb25zdCBNID0gdjJjLmNvbXBvc2UoaW52Q2FtZXJhVCk7XG5cbiAgICAgICAgcmV0dXJuICBNLmFwcGx5KHAueCwgcC55KTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgcG9pbnQgZnJvbSBDYW52YXNIdG1sIHRvIEltYWdlXG4gICAgICogQHBhcmFtIHsqfSBwICBwb2ludCB7eCwgeX0gaW4gQ2FudmFzSHRtbCAoMCwwIGxlZnQsdG9wLCB5IERvd24pXG4gICAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBjYW1lcmEgXG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IGxheWVyVCBsYXllciB0cmFuc2Zvcm0gXG4gICAgICogQHBhcmFtIHsqfSBsYXllclNpemUgIHt3LCBofSBTaXplIGluIHBpeGVsIG9mIHRoZSBMYXllclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gYXBwbHlHTFNjYWxlIGlmIHRydWUgYXBwbHkgZGV2UGl4ZWxSYXRpbyBzY2FsZS4gS2VlcCBpdCBmYWxzZSB3aGVuIHdvcmtpbmcgd2l0aCBTVkdcbiAgICAgKiBAcmV0dXJucyBQb2ludCBpbiBJbWFnZSBzcGFjZSAoMCwwIGxlZnQsdG9wIG9mIHRoZSBpbWFnZSwgeSBEb3duKVxuICAgICAqL1xuICAgICBzdGF0aWMgZnJvbUNhbnZhc0h0bWxUb0ltYWdlKHAsIGNhbWVyYSwgbGF5ZXJULCBsYXllclNpemUsIHVzZUdMKSB7XG4gICAgICAgIC8vIFRyYW5zbGF0ZShMdy8yLCBMaC8yKSAqIEludkxheWVyVCAqIEludkNhbWVyYVQgKiAgVHJhbnNsYXRlKC1Wdy8yLCAtVmgvMikgKiBpbnZlcnRZICogW1NjYWxlKGRldmljZVBpeGVsUmF0aW8pXVxuICAgICAgICAvLyBpbiBvdGhlciB3b3Jkcy4uLiBmcm9tTGF5ZXJUb0ltYWdlICogaW52TGF5ZXJUICogZnJvbUNhbnZhc0h0bWxUb1NjZW5lXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmZyb21DYW52YXNIdG1sVG9TY2VuZShwLCBjYW1lcmEsIHVzZUdMKTtcbiAgICAgICAgY29uc3QgaW52TGF5ZXJUID0gbGF5ZXJULmludmVyc2UoKTtcbiAgICAgICAgcmVzdWx0ID0gaW52TGF5ZXJULmFwcGx5KHJlc3VsdC54LCByZXN1bHQueSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZnJvbUxheWVyVG9JbWFnZShyZXN1bHQsIGxheWVyU2l6ZSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSBib3ggZnJvbSBWaWV3cG9ydCB0byBJbWFnZSBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7Qm91bmRpbmdCb3h9IGJveCBpbiBWaWV3cG9ydCBjb29yZGluYXRlcyAoMCwwIGF0IGxlZnQsYm90dG9tLCB5IFVwKVxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtfSBjYW1lcmFUIGNhbWVyYSBUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0geyp9IHZpZXdwb3J0IHt4LHksZHgsZHksdyxofVxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtfSBsYXllclQgbGF5ZXIgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHsqfSBsYXllclNpemUge3csaH0gbGF5ZXIgcGl4ZWwgc2l6ZVxuICAgICAqIEByZXR1cm5zIGJveCBpbiBJbWFnZSBjb29yZGluYXRlcyAoMCwwIGxlZnQsdG9wLCB5IERvd20pXG4gICAgICovXG4gICAgIHN0YXRpYyBmcm9tVmlld3BvcnRCb3hUb0ltYWdlQm94KGJveCwgY2FtZXJhVCwgdmlld3BvcnQsIGxheWVyVCwgbGF5ZXJTaXplKSB7XG4gICAgICAgIC8vIEludmVydFlvbkltYWdlICogVChMdy8yLCBMaC8yKSAqIEludkwgKiBJbnZDYW0gKiBUKC1Wdy8yLC1WaC8yKSBcbiAgICAgICAgbGV0IFYyQyA9IG5ldyBUcmFuc2Zvcm0oe3g6LXZpZXdwb3J0LncvMiwgeTotdmlld3BvcnQuaC8yfSk7XG4gICAgICAgIGxldCBDMlMgPSBjYW1lcmFULmludmVyc2UoKTtcbiAgICAgICAgbGV0IFMyTCA9IGxheWVyVC5pbnZlcnNlKCk7XG4gICAgICAgIGxldCBMMkkgPSBuZXcgVHJhbnNmb3JtKHt4OmxheWVyU2l6ZS53LzIsIHk6bGF5ZXJTaXplLmgvMn0pO1xuICAgICAgICBsZXQgTSA9IFYyQy5jb21wb3NlKEMyUy5jb21wb3NlKFMyTC5jb21wb3NlKEwySSkpKTtcbiAgICAgICAgbGV0IHJlc3VsdEJveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIGxldCBwID0gYm94LmNvcm5lcihpKTtcbiAgICAgICAgICAgIHAgPSBNLmFwcGx5KHAueCwgcC55KTtcbiAgICAgICAgICAgIHAgPSBDb29yZGluYXRlU3lzdGVtLmludmVydFkocCwgbGF5ZXJTaXplKTtcblx0XHRcdHJlc3VsdEJveC5tZXJnZVBvaW50KHApO1xuXHRcdH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdEJveDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSBib3ggZnJvbSBMYXllciB0byBTY2VuZSBcbiAgICAgKiBAcGFyYW0ge0JvdW5kaW5nQm94fSBib3ggIGJveCBpbiBMYXllciBjb29yZGluYXRlcyAoMCwwIGF0IGxheWVyIGNlbnRlcilcbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gbGF5ZXJUIGxheWVyIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm5zIGJveCBpbiBTY2VuZSBjb29yZGluYXRlcyAoMCwwIGF0IHNjZW5lIGNlbnRlcilcbiAgICAgKi9cbiAgICAgc3RhdGljIGZyb21MYXllckJveFRvU2NlbmVCb3goYm94LCBsYXllclQpIHtcbiAgICAgICAgIHJldHVybiBsYXllclQudHJhbnNmb3JtQm94KGJveCk7IFxuICAgIH1cbiAgXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgYm94IGZyb20gU2NlbmUgdG8gTGF5ZXIgXG4gICAgICogQHBhcmFtIHtCb3VuZGluZ0JveH0gYm94ICBib3ggaW4gTGF5ZXIgY29vcmRpbmF0ZXMgKDAsMCBhdCBsYXllciBjZW50ZXIpXG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IGxheWVyVCBsYXllciB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyBib3ggaW4gU2NlbmUgY29vcmRpbmF0ZXMgKDAsMCBhdCBzY2VuZSBjZW50ZXIpXG4gICAgICovXG4gICAgIHN0YXRpYyBmcm9tU2NlbmVCb3hUb0xheWVyQm94KGJveCwgbGF5ZXJUKSB7XG4gICAgICAgIHJldHVybiBsYXllclQuaW52ZXJzZSgpLnRyYW5zZm9ybUJveChib3gpOyBcbiAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhIGJveCBmcm9tIExheWVyIHRvIFZpZXdwb3J0IGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtCb3VuZGluZ0JveH0gYm94IGJveCBpbiBMYXllciBjb29yZGluYXRlcyAoMCwwIGF0IExheWVyIGNlbnRlciB5IFVwKVxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgXG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IGxheWVyVCBsYXllciB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge2Jvb2x9IHVzZUdMIFRydWUgdG8gd29yayB3aXRoIFdlYkdMLCBmYWxzZSBmb3IgU1ZHLiBXaGVuIHRydWUsIGl0IHVzZXMgZGV2UGl4ZWxSYXRpbyBzY2FsZVxuICAgICAqIEByZXR1cm5zIEJveCBpbiBWaWV3cG9ydCBjb29yZGluYXRlcyAoMCwwIGF0IGxlZnQsIGJvdHRvbSB5IFVwKVxuICAgICAqL1xuICAgICBzdGF0aWMgZnJvbUxheWVyQm94VG9WaWV3cG9ydEJveChib3gsIGNhbWVyYSwgbGF5ZXJULCB1c2VHTCkge1xuICAgICAgICBjb25zdCBNID0gdGhpcy5nZXRGcm9tTGF5ZXJUb1ZpZXdwb3J0VHJhbnNmb3JtKGNhbWVyYSwgbGF5ZXJULCB1c2VHTCk7XG4gICAgICAgIHJldHVybiBNLnRyYW5zZm9ybUJveChib3gpOyAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgYm94IGZyb20gTGF5ZXIgdG8gVmlld3BvcnQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge0JvdW5kaW5nQm94fSBib3ggYm94IGluIExheWVyIGNvb3JkaW5hdGVzICgwLDAgYXQgTGF5ZXIgY2VudGVyIHkgVXApXG4gICAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBcbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gbGF5ZXJUIGxheWVyIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gdXNlR0wgVHJ1ZSB0byB3b3JrIHdpdGggV2ViR0wsIGZhbHNlIGZvciBTVkcuIFdoZW4gdHJ1ZSwgaXQgdXNlcyBkZXZQaXhlbFJhdGlvIHNjYWxlXG4gICAgICogQHJldHVybnMgQm94IGluIFZpZXdwb3J0IGNvb3JkaW5hdGVzICgwLDAgYXQgbGVmdCwgYm90dG9tIHkgVXApXG4gICAgICovXG4gICAgIHN0YXRpYyBmcm9tVmlld3BvcnRCb3hUb0xheWVyQm94KGJveCwgY2FtZXJhLCBsYXllclQsIHVzZUdMKSB7XG4gICAgICAgIGNvbnN0IE0gPSB0aGlzLmdldEZyb21MYXllclRvVmlld3BvcnRUcmFuc2Zvcm0oY2FtZXJhLCBsYXllclQsIHVzZUdMKS5pbnZlcnNlKCk7XG4gICAgICAgIHJldHVybiBNLnRyYW5zZm9ybUJveChib3gpOyAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgdHJhbnNmb3JtIHRvIGdvIGZyb20gdmlld3BvcnQgMCwwIGF0IGxlZnQsIGJvdHRvbSB5IFVwLCB0byBDZW50ZXIgMCwwIGF0IHZpZXdwb3J0IGNlbnRlclxuICAgICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgY2FtZXJhXG4gICAgICogQHBhcmFtIHtib29sfSB1c2VHTCBUcnVlIHRvIHdvcmsgd2l0aCBXZWJHTCwgZmFsc2UgZm9yIFNWRy4gV2hlbiB0cnVlLCBpdCB1c2VzIGRldlBpeGVsUmF0aW8gc2NhbGVcbiAgICAgKiBAcmV0dXJucyB0cmFuc2Zvcm0gZnJvbSBWaWV3cG9ydCB0byBDZW50ZXJcbiAgICAgKi9cbiAgICAgc3RhdGljIGdldEZyb21WaWV3cG9ydFRvQ2VudGVyVHJhbnNmb3JtKGNhbWVyYSwgdXNlR0wpIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGNhbWVyYSwgdXNlR0wpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGcm9tVmlld3BvcnRUb0NlbnRlclRyYW5zZm9ybU5vQ2FtZXJhKHZpZXdwb3J0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0cmFuc2Zvcm0gdG8gZ28gZnJvbSB2aWV3cG9ydCAwLDAgYXQgbGVmdCwgYm90dG9tIHkgVXAsIHRvIENlbnRlciAwLDAgYXQgdmlld3BvcnQgY2VudGVyXG4gICAgICogZnJvbSBleHBsaWNpdCB2aWV3cG9ydCBwYXJhbS4gKE5vdCB1c2luZyBjYW1lcmEgcGFyYW1ldGVyIGhlcmUpXG4gICAgICogQHBhcmFtIHsqfSB2aWV3cG9ydCB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIHRyYW5zZm9ybSBmcm9tIFZpZXdwb3J0IHRvIENlbnRlclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRGcm9tVmlld3BvcnRUb0NlbnRlclRyYW5zZm9ybU5vQ2FtZXJhKHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHt4OnZpZXdwb3J0Lngtdmlld3BvcnQudy8yLCB5OnZpZXdwb3J0Lnktdmlld3BvcnQuaC8yLCB6OjEsIGE6MCwgdDowfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRyYW5zZm9ybSB3aXRoIHkgcmVmbGVjdGVkIHdydCBvcmlnaW4gKHk9LXkpXG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IHQgIFxuICAgICAqIEByZXR1cm5zIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSwgd2l0aCB5IHJlZmxlY3RlZCAoYXJvdW5kIDApXG4gICAgICovXG4gICAgc3RhdGljIHJlZmxlY3RZKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oe3g6dC54LCB5Oi10LnksIHo6dC56LCBhOnQuYSwgdDp0LnR9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0cmFuc2Zvcm0gdG8gZ28gZnJvbSBMYXllciAoMCwwIGF0IExheWVyIGNlbnRlciB5IFVwKSB0byBWaWV3cG9ydCAoMCwwIGF0IGxlZnQsYm90dG9tIHkgVXApXG4gICAgICogQHBhcmFtIHtDYW1lcmF9IGNhbWVyYSBcbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gbGF5ZXJUIGxheWVyIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gdXNlR0wgVHJ1ZSB0byB3b3JrIHdpdGggV2ViR0wsIGZhbHNlIGZvciBTVkcuIFdoZW4gdHJ1ZSwgaXQgdXNlcyBkZXZQaXhlbFJhdGlvIHNjYWxlXG4gICAgICogQHJldHVybnMgdHJhbnNmb3JtIGZyb20gTGF5ZXIgdG8gVmlld3BvcnRcbiAgICAgKi9cbiAgICAgc3RhdGljIGdldEZyb21MYXllclRvVmlld3BvcnRUcmFuc2Zvcm0oY2FtZXJhLCBsYXllclQsIHVzZUdMKSB7XG4gICAgICAgIC8vIE0gPSAgQ2VudGVyMlZpZXdwb3J0ICogQ2FtZXJhVCAgKiBMYXllclRcbiAgICAgICAgY29uc3QgY2FtZXJhVCA9IHRoaXMuZ2V0Q3VycmVudFRyYW5zZm9ybShjYW1lcmEsIHVzZUdMKTtcbiAgICAgICAgY29uc3QgYzJ2ID0gdGhpcy5nZXRGcm9tVmlld3BvcnRUb0NlbnRlclRyYW5zZm9ybShjYW1lcmEsIHVzZUdMKS5pbnZlcnNlKCk7XG4gICAgICAgIGNvbnN0IE0gPSBsYXllclQuY29tcG9zZShjYW1lcmFULmNvbXBvc2UoYzJ2KSk7XG4gICAgICAgIHJldHVybiBNO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHRyYW5zZm9ybSB0byBnbyBmcm9tIExheWVyICgwLDAgYXQgTGF5ZXIgY2VudGVyIHkgVXApIHRvIFZpZXdwb3J0ICgwLDAgYXQgbGVmdCxib3R0b20geSBVcClcbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gQ2FtZXJhVCBjYW1lcmEgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHt2aWV3cG9ydH0gdmlld3BvcnQge3gseSxkeCxkeSx3LGh9IHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtUcmFuc2Zvcm19IGxheWVyVCBsYXllciB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJucyB0cmFuc2Zvcm0gZnJvbSBMYXllciB0byBWaWV3cG9ydFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRGcm9tTGF5ZXJUb1ZpZXdwb3J0VHJhbnNmb3JtTm9DYW1lcmEoY2FtZXJhVCwgdmlld3BvcnQsIGxheWVyVCkge1xuICAgICAgICAvLyBNID0gIENlbnRlcjJWaWV3cG9ydCAqIENhbWVyYVQgICogTGF5ZXJUXG4gICAgICAgIGNvbnN0IGMydiA9ICB0aGlzLmdldEZyb21WaWV3cG9ydFRvQ2VudGVyVHJhbnNmb3JtTm9DYW1lcmEodmlld3BvcnQpLmludmVyc2UoKTtcbiAgICAgICAgY29uc3QgTSA9IGxheWVyVC5jb21wb3NlKGNhbWVyYVQuY29tcG9zZShjMnYpKTtcbiAgICAgICAgcmV0dXJuIE07XG4gICAgfVxuICAgIFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgeCBhcHBseWluZyBmIHNjYWxlIGZhY3RvclxuICAgICAqIEBwYXJhbSB7Kn0gcCBQb2ludCB0byBiZSBzY2FsZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZiBTY2FsZSBmYWN0b3JcbiAgICAgKiBAcmV0dXJucyBQb2ludCBpbiBDYW52YXNDb250ZXh0IChTY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpb24pXG4gICAgICovXG4gICAgc3RhdGljIHNjYWxlKHAsIGYpIHtcbiAgICAgICAgcmV0dXJuIHsgeDpwLnggKiBmLCB5OnAueSAqIGZ9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludmVydCB5IHdpdGggcmVzcGVjdCB0byB2aWV3cG9ydC5oXG4gICAgICogQHBhcmFtIHsqfSBwIFBvaW50IHRvIGJlIHRyYW5zZm9ybWVkIFxuICAgICAqIEBwYXJhbSB7Kn0gdmlld3BvcnQgY3VycmVudCB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIFBvaW50IHdpdGggeSBpbnZlcnRlZCB3aXRoIHJlc3BlY3QgdG8gdmlld3BvcnQuaFxuICAgICAqL1xuICAgIHN0YXRpYyBpbnZlcnRZKHAsIHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiB7eDpwLngsIHk6dmlld3BvcnQuaCAtIHAueX07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjYW1lcmEgdmlld3BvcnQ6IHNjYWxlZCBieSBkZXZpY2VQaXhlbFJhdGlvIGlmIHVzZUdMIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtib29sfSB1c2VHTCBUcnVlIHRvIHdvcmsgd2l0aCBXZWJHTCwgZmFsc2UgZm9yIFNWRy4gV2hlbiB0cnVlIHZpZXdwb3J0IHNjYWxlZCBieSBkZXZQaXhlbFJhdGlvIFxuICAgICAqIEByZXR1cm5zIFZpZXdwb3J0IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRWaWV3cG9ydChjYW1lcmEsIHVzZUdMKSB7XG4gICAgICAgIHJldHVybiB1c2VHTCA/IGNhbWVyYS5nbFZpZXdwb3J0KCkgOiBjYW1lcmEudmlld3BvcnQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEN1cnJlbnRUcmFuc2Zvcm0oY2FtZXJhLCB1c2VHTCkge1xuICAgICAgICBsZXQgY2FtZXJhVCA9IHVzZUdMID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVyYS5nZXRHbEN1cnJlbnRUcmFuc2Zvcm0ocGVyZm9ybWFuY2Uubm93KCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVyYS5nZXRDdXJyZW50VHJhbnNmb3JtKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhbWVyYVQ7XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb29yZGluYXRlU3lzdGVtIH0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/CoordinateSystem.js\n");

/***/ }),

/***/ "./src/EditorSvgAnnotation.js":
/*!************************************!*\
  !*** ./src/EditorSvgAnnotation.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorSvgAnnotation\": () => (/* binding */ EditorSvgAnnotation)\n/* harmony export */ });\n/* harmony import */ var _Skin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Skin.js */ \"./src/Skin.js\");\n/* harmony import */ var _Util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util.js */ \"./src/Util.js\");\n/* harmony import */ var _Simplify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Simplify.js */ \"./src/Simplify.js\");\n/* harmony import */ var _LayerSvgAnnotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LayerSvgAnnotation.js */ \"./src/LayerSvgAnnotation.js\");\n/* harmony import */ var _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CoordinateSystem.js */ \"./src/CoordinateSystem.js\");\n\n\n\n\n\n\n/**\n * Callback for create/update/delete annotations.\n * @function crudCallback\n * @param {Annotation} anno The current annotation entry.\n */\n\n/**\n * Callback implementing custom state annotations.\n * @function customStateCallback\n * @param {Annotation} anno The current annotation entry.\n */\n\n/**\n * Callback to customize the annotation data object.\n * @function customDataCallback\n * @param {Annotation} anno The current annotation entry.\n */\n\n/**\n * Callback executed when an annotation is selcted on the user interface.\n * @function selectedCallback\n * @param {Annotation} anno The current annotation entry.\n */\n\n/**\n * **EditorSvgAnnotation** enables the {@link UIBasic} interface to edit (create/update/delete) SVG annotations.\n * This class is a mere utility that acts as an adapter between the annotation database and the OpenLIME system.\n * \n * Here you will find a tutorial to learn how to use the SVG annotation editor. //FIXME\n * \n * For the experienced developer this class can be used as an example to design more complex editors.\n * \n * In the following example an **EditorSvgAnnotation** is instatiated and connected to the annotation database\n * through three callbacks implementing database operations (create/update/delete).\n * ``` \n * // Creates an annotation layer and add it to the canvans\n * const anno = new OpenLIME.Layer(aOptions);\n * lime.addLayer('anno', anno);\n *\n * // Creates a SVG annotation Editor\n * const editor = new OpenLIME.EditorSvgAnnotation(lime, anno, {\n *          viewer: lime,\n *          classes: classParam\n * });\n * editor.createCallback = (anno) => { console.log(\"Created annotation: \", anno); processRequest(anno, 'create'); return true; };\n * editor.updateCallback = (anno) => { console.log(\"Updated annotation: \", anno); processRequest(anno, 'update'); return true; };\n * editor.deleteCallback = (anno) => { console.log(\"Deleted annotation: \", anno); processRequest(anno, 'delete'); return true; };\n * ```\n */\nclass EditorSvgAnnotation {\n\t/**\n\t * Instatiates a EditorSvgAnnotation object.\n\t * @param {Viewer} viewer The OpenLIME viewer.\n\t * @param {LayerSvgAnnotation} layer The annotation layer on which to operate.\n\t * @param {Object} [options] An object literal with SVG editor parameters.\n\t * @param {AnnotationClasses} options.classes An object literal definying colors and labels of the annotation classes.\n\t * @param {crudCallback} options.createCallback The callback to implement annotation creation.\n\t * @param {crudCallback} options.updateCallback The callback to implement annotation update.\n\t * @param {crudCallback} options.deleteCallback The callback to implement annotation deletion.\n\t * @param {bool} options.enableState=false Whether to enable custom annotation state. This allows to include some state variables into an annotation item (such as camera, light or lens position).\n\t * @param {customStateCallback} options.customState The callback implementing custom state annotations.\n\t * @param {customDataCallback} options.customData The callback to customize the annotation data object.\n\t * @param {selectedCallback} options.selectedCallback The callback executed when an annotation is selcted on the user interface.\n\t */\n\tconstructor(viewer, layer, options) {\n\t\tthis.layer = layer;\n\t\tObject.assign(this, {\n\t\t\tviewer: viewer,\n\t\t\tpanning: false,\n\t\t\ttool: null, //doing nothing, could: ['line', 'polygon', 'point', 'box', 'circle']\n\t\t\tstartPoint: null, //starting point for box and  circle\n\t\t\tcurrentLine: [],\n\t\t\tannotation: null,\n\t\t\tpriority: 20000,\n\t\t\tclasses: {\n\t\t\t\t'': { stroke: '#000', label: '' },\n\t\t\t\t'class1': { stroke: '#770', label: '' },\n\t\t\t\t'class2': { stroke: '#707', label: '' },\n\t\t\t\t'class3': { stroke: '#777', label: '' },\n\t\t\t\t'class4': { stroke: '#070', label: '' },\n\t\t\t\t'class5': { stroke: '#007', label: '' },\n\t\t\t\t'class6': { stroke: '#077', label: '' },\n\t\t\t},\n\t\t\ttools: {\n\t\t\t\tpoint: {\n\t\t\t\t\timg: '<svg width=24 height=24><circle cx=12 cy=12 r=3 fill=\"red\" stroke=\"gray\"/></svg>',\n\t\t\t\t\ttooltip: 'New point',\n\t\t\t\t\ttool: Point,\n\t\t\t\t},\n\t\t\t\tpin: {\n\t\t\t\t\ttemplate: (x,y) => {\n\t\t\t\t\t\treturn `<svg xmlns='http://www.w3.org/2000/svg' x='${x}' y='${y}' width='4%' height='4%' class='pin'\n\t\t\t\t\t\tviewBox='0 0 18 18'><path d='M 0,0 C 0,0 4,0 8,0 12,0 16,4 16,8 16,12 12,16 8,16 4,16 0,12 0,8 0,4 0,0 0,0 Z'/><text class='pin-text' x='7' y='8'>${this.annotation.idx}</text></svg>`;\n\t\t\t\t\t}, //pin di alcazar  1. url a svg 2. txt (stringa con svg) 3. funzione(x,y) ritorna svg 4. dom (da skin).\n\t\t\t\t\ttooltip: 'New pin',\n\t\t\t\t\ttool: Pin\n\t\t\t\t},\n\t\t\t\tpen: {\n\t\t\t\t\timg: '<svg width=24 height=24><circle cx=12 cy=12 r=3 fill=\"red\" stroke=\"gray\"/></svg>',\n\t\t\t\t\ttooltip: 'New polyline',\n\t\t\t\t\ttool: Pen,\n\t\t\t\t},\n\t\t\t\tline: {\n\t\t\t\t\timg: `<svg width=24 height=24>\n\t\t\t\t\t\t<path d=\"m 4.7,4.5 c 0.5,4.8 0.8,8.5 3.1,11 2.4,2.6 4.2,-4.8 6.3,-5 2.7,-0.3 5.1,9.3 5.1,9.3\" stroke-width=\"3\" fill=\"none\" stroke=\"grey\"/>\n\t\t\t\t\t\t<path d=\"m 4.7,4.5 c 0.5,4.8 0.8,8.5 3.1,11 2.4,2.6 4.2,-4.8 6.3,-5 2.7,-0.3 5.1,9.3 5.1,9.3\" stroke-width=\"1\" fill=\"none\" stroke=\"red\"/></svg>`,\n\t\t\t\t\ttooltip: 'New line',\n\t\t\t\t\ttool: Line,\n\t\t\t\t},\n\t\t\t\terase: {\n\t\t\t\t\timg: '',\n\t\t\t\t\ttooltip: 'Erase lines',\n\t\t\t\t\ttool: Erase,\n\t\t\t\t},\n\t\t\t\tbox: {\n\t\t\t\t\timg: '<svg width=24 height=24><rect x=5 y=5 width=14 height=14 fill=\"red\" stroke=\"gray\"/></svg>',\n\t\t\t\t\ttooltip: 'New box',\n\t\t\t\t\ttool: Box,\n\t\t\t\t},\n\t\t\t\tcircle: {\n\t\t\t\t\timg: '<svg width=24 height=24><circle cx=12 cy=12 r=7 fill=\"red\" stroke=\"gray\"/></svg>',\n\t\t\t\t\ttooltip: 'New circle',\n\t\t\t\t\ttool: Circle,\n\t\t\t\t},\n\t\t\t\t/*\t\t\t\tcolorpick: {\n\t\t\t\t\t\t\t\t\timg: '',\n\t\t\t\t\t\t\t\t\ttooltip: 'Pick a color',\n\t\t\t\t\t\t\t\t\ttool: Colorpick,\n\t\t\t\t\t\t\t\t} */\n\t\t\t},\n\t\t\tannotation: null, //not null only when editWidget is shown.\n\t\t\tenableState: false,\n\t\t\tcustomState: null,\n\t\t\tcustomData: null,\n\t\t\teditWidget: null,\n\t\t\tselectedCallback: null,\n\t\t\tcreateCallback: null, //callbacks for backend\n\t\t\tupdateCallback: null,\n\t\t\tdeleteCallback: null\n\t\t}, options);\n\n\t\tlayer.style += Object.entries(this.classes).map((g) => `[data-class=${g[0]}] { stroke:${g[1].style.stroke}; }`).join('\\n');\n\t\t//at the moment is not really possible to unregister the events registered here.\n\t\tviewer.pointerManager.onEvent(this);\n\t\tdocument.addEventListener('keyup', (e) => this.keyUp(e), false);\n\t\tlayer.addEvent('selected', (anno) => {\n\t\t\tif (!anno || anno == this.annotation)\n\t\t\t\treturn;\n\t\t\tif(this.selectedCallback) this.selectedCallback(anno);\n\t\t\tthis.showEditWidget(anno);\n\t\t});\n\n\t\tlayer.annotationsEntry = () => {\n\n\t\t\tlet entry = {\n\t\t\t\thtml: `<div class=\"openlime-tools\"></div>`,\n\t\t\t\tlist: [], //will be filled later.\n\t\t\t\tclasses: 'openlime-annotations',\n\t\t\t\tstatus: () => 'active',\n\t\t\t\toncreate: () => {\n\t\t\t\t\tif (Array.isArray(layer.annotations))\n\t\t\t\t\t\tlayer.createAnnotationsList();\n\n\t\t\t\t\tlet tools = {\n\t\t\t\t\t\t'add': { action: () => { this.createAnnotation(); }, title: \"New annotation\" },\n\t\t\t\t\t\t'edit': { action: () => { this.toggleEditWidget(); }, title: \"Edit annotations\" },\n\t\t\t\t\t\t'export': { action: () => { this.exportAnnotations(); }, title: \"Export annotations\" },\n\t\t\t\t\t\t'trash': { action: () => { this.deleteSelected(); }, title: \"Delete selected annotations\" },\n\t\t\t\t\t};\n\t\t\t\t\t(async () => {\n\n\t\t\t\t\t\tfor (const [label, tool] of Object.entries(tools)) {\n\t\t\t\t\t\t\tlet icon = await _Skin_js__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(entry.element.firstChild, '.openlime-' + label); // TODO pass entry.element.firstChild as parameter in onCreate\n\t\t\t\t\t\t\ticon.setAttribute('title', tool.title);\n\t\t\t\t\t\t\ticon.addEventListener('click', tool.action);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\t\t\t}\n\t\t\tlayer.annotationsListEntry = entry;\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\t/** @ignore */\n\tcreateAnnotation() {\n\t\tlet anno = this.layer.newAnnotation();\n\t\tif(this.customData) this.customData(anno);\n\t\tif(this.enableState) this.setAnnotationCurrentState(anno);\n\t\tanno.idx = this.layer.annotations.length;\n\t\tanno.publish = 1;\n\t\tanno.label = anno.description = anno.class = '';\n\t\tlet post = {\n\t\t\tid: anno.id, idx: anno.idx, label: anno.label, description: anno.description, 'class': anno.class, svg: null,\n\t\t\tpublish: anno.publish, data: anno.data\n\t\t};\n\t\tif (this.enableState) post = { ...post, state: anno.state };\n\t\tif (this.createCallback) {\n\t\t\tlet result = this.createCallback(post);\n\t\t\tif (!result)\n\t\t\t\talert(\"Failed to create annotation!\");\n\t\t}\n\t\tthis.layer.setSelected(anno);\n\t}\n\n\t/** @ignore */\n\ttoggleEditWidget() {\n\t\tif (this.annotation)\n\t\t\treturn this.hideEditWidget();\n\n\t\tlet id = this.layer.selected.values().next().value;\n\t\tif (!id)\n\t\t\treturn;\n\n\t\tlet anno = this.layer.getAnnotationById(id);\n\t\tthis.showEditWidget(anno);\n\t}\n\n\t/** @ignore */\n\tupdateEditWidget() {\n\t\tlet anno = this.annotation;\n\t\tlet edit = this.editWidget;\n\t\tif (!anno.class)\n\t\t\tanno.class = '';\n\t\tedit.querySelector('[name=label]').value = anno.label || '';\n\t\tedit.querySelector('[name=description]').value = anno.description || '';\n\t\tedit.querySelector('[name=idx]').value = anno.idx || '';\n\t\tObject.entries(anno.data).map(k => {\n\t\t\tedit.querySelector(`[name=data-data-${k[0]}]`).value = k[1] || '';\n\t\t});\n\n\t\tedit.querySelector('[name=classes]').value = anno.class;\n\t\tedit.querySelector('[name=publish]').checked = anno.publish == 1;\n\t\tedit.classList.remove('hidden');\n\t\tlet button = edit.querySelector('.openlime-select-button');\n\t\tbutton.textContent = this.classes[anno.class].label;\n\t\tbutton.style.background = this.classes[anno.class].style.stroke;\n\t}\n\n\t/** @ignore */\n\tshowEditWidget(anno) {\n\t\tthis.annotation = anno;\n\t\tthis.setTool(null);\n\t\tthis.setActiveTool();\n\t\tthis.layer.annotationsListEntry.element.querySelector('.openlime-edit').classList.add('active');\n\t\t(async () => {\n\t\t\tawait this.createEditWidget();\n\t\t\tthis.updateEditWidget();\n\t\t})();\n\t}\n\n\t/** @ignore */\n\thideEditWidget() {\n\t\tthis.annotation = null;\n\t\tthis.setTool(null);\n\t\tthis.editWidget.classList.add('hidden');\n\t\tthis.layer.annotationsListEntry.element.querySelector('.openlime-edit').classList.remove('active');\n\t}\n\n\t//TODO this should actually be in the html.\n\t/** @ignore */\n\tasync createEditWidget() {\n\t\tif (this.editWidget)\n\t\t\treturn;\t\t\n\t\tlet html = `\n\t\t\t\t<div class=\"openlime-annotation-edit\">\n\t\t\t\t\t<label for=\"label\">Title:</label> <input name=\"label\" type=\"text\"><br>\n\t\t\t\t\t<label for=\"description\">Description:</label><br>\n\t\t\t\t\t<textarea name=\"description\" cols=\"30\" rows=\"5\"></textarea><br>\n\t\t\t\t\t<span>Class:</span> \n\t\t\t\t\t<div class=\"openlime-select\">\n\t\t\t\t\t\t<input type=\"hidden\" name=\"classes\" value=\"\"/>\n\t\t\t\t\t\t<div class=\"openlime-select-button\"></div>\n\t\t\t\t\t\t<ul class=\"openlime-select-menu\">\n\t\t\t\t\t\t${Object.entries(this.classes).map((c) =>\n\t\t\t`<li data-class=\"${c[0]}\" style=\"background:${c[1].style.stroke};\">${c[1].label}</li>`).join('\\n')}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t<label for=\"idx\">Index:</label> <input name=\"idx\" type=\"text\"><br>\t\n\t\t\t\t\t${Object.entries(this.annotation.data).map(k => {\n\t\t\t\t\t\tlet label = k[0];\n\t\t\t\t\t\tlet str = `<label for=\"data-data-${k[0]}\">${label}:</label> <input name=\"data-data-${k[0]}\" type=\"text\"><br>`\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('\\n')}\n\t\t\t\t\t<br>\n\t\t\t\t\t<span><button class=\"openlime-state\">SAVE</button></span>\n\t\t\t\t\t<span><input type=\"checkbox\" name=\"publish\" value=\"\"> Publish</span><br>\n\t\t\t\t\t<div class=\"openlime-annotation-edit-tools\"></div>\n\t\t\t\t</div>`;\n\t\tlet template = document.createElement('template');\n\t\ttemplate.innerHTML = html.trim();\n\t\tlet edit = template.content.firstChild;\n\n\t\tlet select = edit.querySelector('.openlime-select');\n\t\tlet button = edit.querySelector('.openlime-select-button');\n\t\tlet ul = edit.querySelector('ul');\n\t\tlet options = edit.querySelectorAll('li');\n\t\tlet input = edit.querySelector('[name=classes]');\n\n\t\tlet state = edit.querySelector('.openlime-state');\n\t\t\n\t\tstate.addEventListener('click', (e) => {\n\t\t\tif(this.enableState) this.setAnnotationCurrentState(this.annotation);\n\t\t\tthis.saveCurrent();\n\t\t\tthis.saveAnnotation(); \n\t\t});\n\n\t\tbutton.addEventListener('click', (e) => {\n\t\t\te.stopPropagation();\n\t\t\tfor (let o of options)\n\t\t\t\to.classList.remove('selected');\n\t\t\tselect.classList.toggle('active');\n\n\t\t});\n\n\t\tul.addEventListener('click', (e) => {\n\t\t\te.stopPropagation();\n\n\t\t\tinput.value = e.srcElement.getAttribute('data-class');\n\t\t\tinput.dispatchEvent(new Event('change'));\n\t\t\tbutton.style.background = this.classes[input.value].style.stroke;\n\t\t\tbutton.textContent = e.srcElement.textContent;\n\n\t\t\tselect.classList.toggle('active');\n\t\t});\n\n\t\tdocument.addEventListener('click', (e) => {\n\t\t\tselect.classList.remove('active');\n\t\t});\n\n\t\tdocument.querySelector('.openlime-layers-menu').appendChild(edit);\n\n\t\tlet tools = edit.querySelector('.openlime-annotation-edit-tools');\n\n\t\tlet pin = await _Skin_js__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(tools, '.openlime-pin');\n\t\tpin.addEventListener('click', (e) => { this.setTool('pin'); this.setActiveTool(pin); });\n\n\t\tlet draw = await _Skin_js__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(tools, '.openlime-draw');\n\t\tdraw.addEventListener('click', (e) => { this.setTool('line'); this.setActiveTool(draw); });\n\n\n\t\t//\t\tlet pen = await Skin.appendIcon(tools, '.openlime-pen'); \n\t\t//\t\tpen.addEventListener('click', (e) => { this.setTool('pen'); setActive(pen); });\n\n\t\tlet erase = await _Skin_js__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(tools, '.openlime-erase');\n\t\terase.addEventListener('click', (e) => { this.setTool('erase'); this.setActiveTool(erase); });\n\n\t\tlet undo = await _Skin_js__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(tools, '.openlime-undo');\n\t\tundo.addEventListener('click', (e) => { this.undo(); });\n\n\t\tlet redo = await _Skin_js__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(tools, '.openlime-redo');\n\t\tredo.addEventListener('click', (e) => { this.redo(); });\n\n\t\t/*\t\tlet colorpick = await Skin.appendIcon(tools, '.openlime-colorpick'); \n\t\t\t\tundo.addEventListener('click', (e) => { this.pickColor(); }); */\n\n\t\tlet label = edit.querySelector('[name=label]');\n\t\tlabel.addEventListener('blur', (e) => { if (this.annotation.label != label.value) this.saveCurrent(); this.saveAnnotation(); });\n\n\t\tlet descr = edit.querySelector('[name=description]');\n\t\tdescr.addEventListener('blur', (e) => { if (this.annotation.description != descr.value) this.saveCurrent(); this.saveAnnotation(); });\n\n\t\tlet idx = edit.querySelector('[name=idx]');\n\t\tidx.addEventListener('blur', (e) => { \n\t\t\tif (this.annotation.idx != idx.value) {\n\t\t\t\tconst svgPinIdx = this.annotation.elements[0];\n\t\t\t\tif(svgPinIdx) {\n\t\t\t\t\tconst txt = svgPinIdx.querySelector(\".pin-text\");\n\t\t\t\t\tif(txt) {\n\t\t\t\t\t\ttxt.textContent = idx.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.saveCurrent();\n\t\t\t} \n\t\t\tthis.saveAnnotation(); \n\t\t});\n\n\t\tObject.entries(this.annotation.data).map(k => {\n\t\t\tlet dataElm = edit.querySelector(`[name=data-data-${k[0]}]`);\n\t\t\tdataElm.addEventListener('blur', (e) => { if (this.annotation.data[k[0]] != dataElm.value) this.saveCurrent(); this.saveAnnotation(); });\n\t\t});\n\n\t\tlet classes = edit.querySelector('[name=classes]');\n\t\tclasses.addEventListener('change', (e) => { if (this.annotation.class != classes.value) this.saveCurrent(); this.saveAnnotation(); });\n\n\t\tlet publish = edit.querySelector('[name=publish]');\n\t\tpublish.addEventListener('change', (e) => { if (this.annotation.publish != publish.value) this.saveCurrent(); this.saveAnnotation(); });\n\n\t\tedit.classList.add('hidden');\n\t\tthis.editWidget = edit;\n\t}\n\n\t/** @ignore */\n\tsetAnnotationCurrentState(anno) {\n\t\tanno.state = window.structuredClone(this.viewer.canvas.getState());\n\t\t// Callback to add  light/lens params or other data\n\t\tif(this.customState) this.customState(anno);\n\t}\n\n\t/** @ignore */\n\tsaveAnnotation() {\n\t\tlet edit = this.editWidget;\n\t\tlet anno = this.annotation;\n\n\t\tanno.label = edit.querySelector('[name=label]').value || '';\n\t\tanno.description = edit.querySelector('[name=description]').value || '';\n\t\tanno.idx = edit.querySelector('[name=idx]').value || '0';\n\t\tObject.entries(anno.data).map(k => {\n\t\t\tanno.data[k[0]] = edit.querySelector(`[name=data-data-${k[0]}]`).value || '';\n\t\t});\t\t\n\t\tanno.publish = edit.querySelector('[name=publish]').checked ? 1 : 0;\n\t\tlet select = edit.querySelector('[name=classes]');\n\t\tanno.class = select.value || '';\n\n\t\tlet button = edit.querySelector('.openlime-select-button');\n\t\tbutton.style.background = this.classes[anno.class].style.stroke;\n\n\t\tfor (let e of this.annotation.elements)\n\t\t\te.setAttribute('data-class', anno.class);\n\n\t\tlet post = {\n\t\t\tid: anno.id, idx: anno.idx, label: anno.label, description: anno.description, class: anno.class,\n\t\t\tpublish: anno.publish, data: anno.data\n\t\t};\n\t\tif (this.enableState) post = { ...post, state: anno.state };\n\t\t// if (anno.light) post = { ...post, light: anno.light }; FIXME\n\t\t// if (anno.lens) post = { ...post, lens: anno.lens };\n\n\t\t//anno.bbox = anno.getBBoxFromElements();\n\t\tlet serializer = new XMLSerializer();\n\t\tpost.svg = `<svg xmlns=\"http://www.w3.org/2000/svg\">\n\t\t\t\t${anno.elements.map((s) => { s.classList.remove('selected'); return serializer.serializeToString(s) }).join(\"\\n\")}  \n\t\t\t\t</svg>`;\n\n\t\tif (this.updateCallback) {\n\t\t\tlet result = this.updateCallback(post);\n\t\t\tif (!result) {\n\t\t\t\talert(\"Failed to update annotation\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\t\t\t\t//for (let c of element.children)\n\t\t//\t\ta.elements.push(c);\n\n\t\t//update the entry\n\t\tlet template = document.createElement('template');\n\t\ttemplate.innerHTML = this.layer.createAnnotationEntry(anno);\n\t\tlet entry = template.content.firstChild;\n\t\t//TODO find a better way to locate the entry!\n\t\tthis.layer.annotationsListEntry.element.parentElement.querySelector(`[data-annotation=\"${anno.id}\"]`).replaceWith(entry);\n\t\tthis.layer.setSelected(anno);\n\t}\n\n\t/** @ignore */\n\tdeleteSelected() {\n\t\tlet id = this.layer.selected.values().next().value;\n\t\tif (id)\n\t\t\tthis.deleteAnnotation(id);\n\t}\n\n\t/** @ignore */\n\tdeleteAnnotation(id) {\n\t\tlet anno = this.layer.getAnnotationById(id);\n\t\tif (this.deleteCallback) {\n\t\t\tif (!confirm(`Deleting annotation ${anno.label}, are you sure?`))\n\t\t\t\treturn;\n\t\t\tlet result = this.deleteCallback(anno);\n\t\t\tif (!result) {\n\t\t\t\talert(\"Failed to delete this annotation.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//remove svg elements from the canvas\n\t\tthis.layer.svgGroup.querySelectorAll(`[data-annotation=\"${anno.id}\"]`).forEach(e => e.remove());\n\n\t\t//remove entry from the list\n\t\tlet list = this.layer.annotationsListEntry.element.parentElement.querySelector('.openlime-list');\n\t\tlist.querySelectorAll(`[data-annotation=\"${anno.id}\"]`).forEach(e => e.remove());\n\n\t\tthis.layer.annotations = this.layer.annotations.filter(a => a !== anno);\n\t\tthis.layer.clearSelected();\n\t\tthis.hideEditWidget();\n\t}\n\n\t/** @ignore */\n\texportAnnotations() {\n\t\tlet svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\t\tconst bBox = this.layer.boundingBox();\n\t\tsvgElement.setAttribute('viewBox', `0 0 ${bBox.xHigh-bBox.xLow} ${bBox.yHigh-bBox.yLow}`);\n\t\tlet style = _Util_js__WEBPACK_IMPORTED_MODULE_1__.Util.createSVGElement('style');\n\t\tstyle.textContent = this.layer.style;\n\t\tsvgElement.appendChild(style);\n\t\tlet serializer = new XMLSerializer();\n\t\t//let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\">\n\t\tfor (let anno of this.layer.annotations) {\n\t\t\tfor (let e of anno.elements) {\n\t\t\t\tif (e.tagName == 'path') {\n\t\t\t\t\t//Inkscape nitpicks on the commas in svg path.\n\t\t\t\t\tlet d = e.getAttribute('d');\n\t\t\t\t\te.setAttribute('d', d.replaceAll(',', ' '));\n\t\t\t\t}\n\t\t\t\tsvgElement.appendChild(e.cloneNode());\n\t\t\t}\n\t\t}\n\t\tlet svg = serializer.serializeToString(svgElement);\n\t\t/*(${this.layer.annotations.map(anno => {\n\t\t\treturn `<group id=\"${anno.id}\" title=\"${anno.label}\" data-description=\"${anno.description}\">\n\t\t\t\t${anno.elements.map((s) => { \n\t\t\t\t\ts.classList.remove('selected'); \n\t\t\t\t\treturn serializer.serializeToString(s) \n\t\t\t\t}).join(\"\\n\")}\n\t\t\t\t</group>`;\n\t\t})}\n\t\t</svg>`; */\n\n\t\t///console.log(svg);\n\n\t\tvar e = document.createElement('a');\n\t\te.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(svg));\n\t\te.setAttribute('download', 'annotations.svg');\n\t\te.style.display = 'none';\n\t\tdocument.body.appendChild(e);\n\t\te.click();\n\t\tdocument.body.removeChild(e);\n\t}\n\n\t/** @ignore */\n\tsetActiveTool(e) {\n\t\tif (!this.editWidget) return;\n\t\tlet tools = this.editWidget.querySelector('.openlime-annotation-edit-tools');\n\t\ttools.querySelectorAll('svg').forEach(a =>\n\t\t\ta.classList.remove('active'));\n\t\tif (e)\n\t\t\te.classList.add('active');\n\t}\n\n\t/** @ignore */\n\tsetTool(tool) {\n\t\tthis.tool = tool;\n\t\tif (this.factory && this.factory.quit)\n\t\t\tthis.factory.quit();\n\t\tif (tool) {\n\t\t\tif (!tool in this.tools)\n\t\t\t\tthrow \"Unknown editor tool: \" + tool;\n\n\t\t\tthis.factory = new this.tools[tool].tool(this.tools[tool]);\n\t\t\tthis.factory.annotation = this.annotation;\n\t\t\tthis.factory.layer = this.layer;\n\t\t}\n\t\tdocument.querySelector('.openlime-overlay').classList.toggle('erase', tool == 'erase');\n\t\tdocument.querySelector('.openlime-overlay').classList.toggle('crosshair', tool && tool != 'erase');\n\t}\n\n\n\t// UNDO STUFF\t\n\n\t/** @ignore */\n\tundo() {\n\t\tlet anno = this.annotation; //current annotation.\n\t\tif (!anno)\n\t\t\treturn;\n\t\tif (this.factory && this.factory.undo && this.factory.undo()) {\n\t\t\tanno.needsUpdate = true;\n\t\t\tthis.viewer.redraw();\n\t\t\treturn;\n\t\t}\n\n\t\tif (anno.history && anno.history.length) {\n\t\t\t//FIXME TODO history will be more complicated if it has to manage multiple tools.\n\t\t\tanno.future.push(this.annoToData(anno));\n\n\t\t\tlet data = anno.history.pop();\n\t\t\tthis.dataToAnno(data, anno);\n\n\t\t\tanno.needsUpdate = true;\n\t\t\tthis.viewer.redraw();\n\t\t\tthis.updateEditWidget();\n\t\t}\n\t}\n\n\t/** @ignore */\n\tredo() {\n\t\tlet anno = this.annotation; //current annotation.\n\t\tif (!anno)\n\t\t\treturn;\n\t\tif (this.factory && this.factory.redo && this.factory.redo()) {\n\t\t\tanno.needsUpdate = true;\n\t\t\tthis.viewer.redraw();\n\t\t\treturn;\n\t\t}\n\t\tif (anno.future && anno.future.length) {\n\t\t\tanno.history.push(this.annoToData(anno));\n\n\t\t\tlet data = anno.future.pop();\n\t\t\tthis.dataToAnno(data, anno);\n\n\t\t\tanno.needsUpdate = true;\n\t\t\tthis.viewer.redraw();\n\t\t\tthis.updateEditWidget();\n\t\t}\n\t}\n\n\t/** @ignore */\n\tsaveCurrent() {\n\t\tlet anno = this.annotation; //current annotation.\n\t\tif (!anno.history)\n\t\t\tanno.history = [];\n\n\t\tanno.history.push(this.annoToData(anno));\n\t\tanno.future = [];\n\t}\n\n\t/** @ignore */\n\tannoToData(anno) {\n\t\tlet data = {};\n\t\tfor (let i of ['id', 'label', 'description', 'class', 'publish', 'data'])\n\t\t\tdata[i] = `${anno[i] || ''}`;\n\t\tdata.elements = anno.elements.map(e => { let n = e.cloneNode(); n.points = e.points; return n; });\n\t\treturn data;\n\t}\n\n\t/** @ignore */\n\tdataToAnno(data, anno) {\n\t\tfor (let i of ['id', 'label', 'description', 'class', 'publish', 'data'])\n\t\t\tanno[i] = `${data[i]}`;\n\t\tanno.elements = data.elements.map(e => { let n = e.cloneNode(); n.points = e.points; return n; });\n\t}\n\n\n\t// TOOLS STUFF\n\n\t/** @ignore */\n\tkeyUp(e) {\n\t\tif (e.defaultPrevented) return;\n\t\tswitch (e.key) {\n\t\t\tcase 'Escape':\n\t\t\t\tif (this.tool) {\n\t\t\t\t\tthis.setActiveTool();\n\t\t\t\t\tthis.setTool(null);\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Delete':\n\t\t\t\tthis.deleteSelected();\n\t\t\t\tbreak;\n\t\t\tcase 'Backspace':\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tif (e.ctrlKey)\n\t\t\t\t\tthis.undo();\n\t\t\t\tbreak;\n\t\t\tcase 'Z':\n\t\t\t\tif (e.ctrlKey)\n\t\t\t\t\tthis.redo();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/** @ignore */\n\tpanStart(e) {\n\t\tif (e.buttons != 1 || e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)\n\t\t\treturn;\n\t\tif (!['line', 'erase', 'box', 'circle'].includes(this.tool))\n\t\t\treturn;\n\t\tthis.panning = true;\n\t\te.preventDefault();\n\n\t\tthis.saveCurrent();\n\n\t\tconst pos = this.mapToSvg(e);\n\t\tlet shape = this.factory.create(pos, e);\n\n\t\tthis.annotation.needsUpdate = true;\n\n\t\tthis.viewer.redraw();\n\t}\n\n\t/** @ignore */\n\tpanMove(e) {\n\t\tif (!this.panning)\n\t\t\treturn false;\n\n\t\tconst pos = this.mapToSvg(e);\n\t\tthis.factory.adjust(pos, e);\n\t}\n\n\t/** @ignore */\n\tpanEnd(e) {\n\t\tif (!this.panning)\n\t\t\treturn false;\n\t\tthis.panning = false;\n\n\t\tconst pos = this.mapToSvg(e);\n\t\tlet changed = this.factory.finish(pos, e);\n\t\tif (!changed) //nothing changed no need to keep current situation in history.\n\t\t\tthis.annotation.history.pop();\n\t\telse\n\t\t\tthis.saveAnnotation();\n\t\tthis.annotation.needsUpdate = true;\n\t\tthis.viewer.redraw();\n\t}\n\n\t/** @ignore */\n\tfingerHover(e) {\n\t\tif (this.tool != 'line')\n\t\t\treturn;\n\t\te.preventDefault();\n\t\tconst pos = this.mapToSvg(e);\n\t\tlet changed = this.factory.hover(pos, e);\n\t\tthis.annotation.needsUpdate = true;\n\t\tthis.viewer.redraw();\n\t}\n\n\t/** @ignore */\n\tfingerSingleTap(e) {\n\t\tif (!['point', 'pin', 'line', 'erase'].includes(this.tool))\n\t\t\treturn;\n\t\te.preventDefault();\n\n\t\tthis.saveCurrent();\n\n\t\tconst pos = this.mapToSvg(e);\n\t\tlet changed = this.factory.tap(pos, e)\n\t\tif (!changed) //nothing changed no need to keep current situation in history.\n\t\t\tthis.annotation.history.pop();\n\t\telse\n\t\t\tthis.saveAnnotation();\n\t\tthis.annotation.needsUpdate = true;\n\n\t\tthis.viewer.redraw();\n\t}\n\n\t/** @ignore */\n\tfingerDoubleTap(e) {\n\t\tif (!['line'].includes(this.tool))\n\t\t\treturn;\n\t\te.preventDefault();\n\n\t\tthis.saveCurrent();\n\n\t\tconst pos = this.mapToSvg(e);\n\t\tlet changed = this.factory.doubleTap(pos, e)\n\t\tif (!changed) //nothing changed no need to keep current situation in history.\n\t\t\tthis.annotation.history.pop();\n\t\telse\n\t\t\tthis.saveAnnotation();\n\t\tthis.annotation.needsUpdate = true;\n\n\t\tthis.viewer.redraw();\n\t}\n\n\t/** @ignore */\n\tmapToSvg(e) {\n\t\tconst p = {x:e.offsetX, y: e.offsetY};\n\t\tconst layerT = this.layer.transform;\n\t\tconst useGL = false;\n\t\tconsole.log(layerT);\n\t\tconst layerbb = this.layer.boundingBox();\n\t\tconst layerSize = {w:layerbb.width(), h:layerbb.height()};\n\t\tlet pos = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_4__.CoordinateSystem.fromCanvasHtmlToImage(p, this.viewer.camera, layerT, layerSize, useGL);\n\t\t\n\t\treturn pos;\n\t}\n}\n\n\n/** @ignore */\nclass Point {\n\ttap(pos) {\n\t\tlet point = _Util_js__WEBPACK_IMPORTED_MODULE_1__.Util.createSVGElement('circle', { cx: pos.x, cy: pos.y, r: 10, class: 'point' });\n\t\tthis.annotation.elements.push(point);\n\t\treturn true;\n\t}\n}\n\n/** @ignore */\nclass Pin {\n\tconstructor(options) {\n\t\tObject.assign(this, options);\n\t}\n\ttap(pos) {\n\t\tconst str = this.template(pos.x,pos.y);\n\t\tlet parser = new DOMParser();\n\t    let point = parser.parseFromString(str, \"image/svg+xml\").documentElement;\n//\t\tthis.annotation.elements.push(point);\n\t\tthis.annotation.elements[0] = point;\n\t\treturn true;\n\t}\n}\n\n/** @ignore */\nclass Pen {\n\tconstructor() {\n\t\t//TODO Use this.path.points as in line, instead.\n\t\tthis.points = [];\n\t}\n\tcreate(pos) {\n\t\tthis.points.push(pos);\n\t\tif (this.points.length == 1) {\n\t\t\tsaveCurrent\n\n\t\t\tthis.path = _Util_js__WEBPACK_IMPORTED_MODULE_1__.Util.createSVGElement('path', { d: `M${pos.x} ${pos.y}`, class: 'line' });\n\t\t\treturn this.path;\n\t\t}\n\t\tlet p = this.path.getAttribute('d');\n\t\tthis.path.setAttribute('d', p + ` L${pos.x} ${pos.y}`);\n\t\tthis.path.points = this.points;\n\t}\n\tundo() {\n\t\tif (!this.points.length)\n\t\t\treturn;\n\t\tthis.points.pop();\n\t\tlet d = this.points.map((p, i) => `${i == 0 ? 'M' : 'L'}${p.x} ${p.y}`).join(' ');\n\t\tthis.path.setAttribute('d', d);\n\n\t\tif (this.points.length < 2) {\n\t\t\tthis.points = [];\n\t\t\tthis.annotation.elements = this.annotation.elements.filter((e) => e != this.path);\n\t\t}\n\t}\n}\n\n/** @ignore */\nclass Box {\n\tconstructor() {\n\t\tthis.origin = null;\n\t\tthis.box = null;\n\t}\n\n\tcreate(pos) {\n\t\tthis.origin = pos;\n\t\tthis.box = _Util_js__WEBPACK_IMPORTED_MODULE_1__.Util.createSVGElement('rect', { x: pos.x, y: pos.y, width: 0, height: 0, class: 'rect' });\n\t\treturn this.box;\n\t}\n\n\tadjust(pos) {\n\t\tlet p = this.origin;\n\n\t\tthis.box.setAttribute('x', Math.min(p.x, pos.x));\n\t\tthis.box.setAttribute('width', Math.abs(pos.x - p.x));\n\t\tthis.box.setAttribute('y', Math.min(p.y, pos.y));\n\t\tthis.box.setAttribute('height', Math.abs(pos.y - p.y));\n\t}\n\n\tfinish(pos) {\n\t\treturn this.box;\n\t}\n}\n\n/** @ignore */\nclass Circle {\n\tconstructor() {\n\t\tthis.origin = null;\n\t\tthis.circle = null;\n\t}\n\tcreate(pos) {\n\t\tthis.origin = pos;\n\t\tthis.circle = _Util_js__WEBPACK_IMPORTED_MODULE_1__.Util.createSVGElement('circle', { cx: pos.x, cy: pos.y, r: 0, class: 'circle' });\n\t\treturn this.circle;\n\t}\n\tadjust(pos) {\n\t\tlet p = this.origin;\n\t\tlet r = Math.hypot(pos.x - p.x, pos.y - p.y);\n\t\tthis.circle.setAttribute('r', r);\n\t}\n\tfinish() {\n\t\treturn this.circle;\n\t}\n}\n\n/** @ignore */\nclass Line {\n\tconstructor() {\n\t\tthis.history = []\n\t}\n\tcreate(pos) {\n\t\t/*if(this.segment) {\n\t\t\tthis.layer.svgGroup.removeChild(this.segment);\n\t\t\tthis.segment = null;\n\t\t}*/\n\t\tfor (let e of this.annotation.elements) {\n\t\t\tif (!e.points || e.points.length < 2)\n\t\t\t\tcontinue;\n\t\t\tif (Line.distance(e.points[0], pos) * pos.z < 5) {\n\t\t\t\te.points.reverse();\n\t\t\t\tthis.path = e;\n\t\t\t\tthis.path.setAttribute('d', Line.svgPath(e.points));\n\t\t\t\t//reverse points!\n\t\t\t\tthis.history = [this.path.points.length];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Line.distanceToLast(e.points, pos) < 5) {\n\t\t\t\tthis.path = e;\n\t\t\t\tthis.adjust(pos);\n\t\t\t\tthis.history = [this.path.points.length];\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.path = _Util_js__WEBPACK_IMPORTED_MODULE_1__.Util.createSVGElement('path', { d: `M${pos.x} ${pos.y}`, class: 'line' });\n\t\tthis.path.points = [pos];\n\t\tthis.history = [this.path.points.length];\n\t\tthis.annotation.elements.push(this.path);\n\t}\n\n\ttap(pos) {\n\t\tif (!this.path) {\n\t\t\tthis.create(pos);\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (this.adjust(pos))\n\t\t\t\tthis.history = [this.path.points.length - 1];\n\t\t\treturn true;\n\t\t}\n\t}\n\tdoubleTap(pos) {\n\t\tif (!this.path)\n\t\t\treturn false;\n\t\tif (this.adjust(pos)) {\n\t\t\tthis.history = [this.path.points.length - 1];\n\t\t\tthis.path = null;\n\t\t}\n\t\treturn false;\n\t}\n\n\thover(pos, event) {\n\t\treturn;\n\t\tif (!this.path)\n\t\t\treturn false;\n\t\tlet s = this.path.points[this.path.points.length - 1];\n\t\tif (!this.segment) {\n\t\t\tthis.segment = _Util_js__WEBPACK_IMPORTED_MODULE_1__.Util.createSVGElement('path', { class: 'line' });\n\t\t\tthis.layer.svgGroup.appendChild(this.segment);\n\t\t}\n\t\tpos.x = pos.x - s.x;\n\t\tpos.y = pos.y - s.y;\n\t\tlet len = Math.sqrt(pos.x * pos.x + pos.y * pos.y);\n\t\tif (len > 30) {\n\t\t\tpos.x *= 30 / len;\n\t\t\tpos.y *= 30 / len;\n\t\t}\n\t\tthis.segment.setAttribute('d', `M${s.x} ${s.y} l${pos.x} ${pos.y}`);\n\t\treturn true;\n\t}\n\tquit() {\n\t\treturn;\n\t\tif (this.segment) {\n\t\t\tthis.layer.svgGroup.removeChild(this.segment);\n\t\t\tthis.segment = null;\n\t\t}\n\t}\n\n\tadjust(pos) {\n\t\tlet gap = Line.distanceToLast(this.path.points, pos);\n\t\tif (gap * pos.z < 4) return false;\n\n\t\tthis.path.points.push(pos);\n\n\t\tlet d = this.path.getAttribute('d');\n\t\tthis.path.setAttribute('d', Line.svgPath(this.path.points));//d + `L${pos.x} ${pos.y}`);\n\t\treturn true;\n\t}\n\n\tfinish() {\n\t\tthis.path.setAttribute('d', Line.svgPath(this.path.points));\n\t\treturn true; //some changes where made!\n\t}\n\n\tundo() {\n\t\tif (!this.path || !this.history.length)\n\t\t\treturn false;\n\t\tthis.path.points = this.path.points.slice(0, this.history.pop());\n\t\tthis.path.setAttribute('d', Line.svgPath(this.path.points));\n\t\treturn true;\n\t}\n\tredo() {\n\t\treturn false;\n\t}\n\t//TODO: smooth should be STABLE, if possible.\n\tstatic svgPath(points) {\n\t\t//return points.map((p, i) =>  `${(i == 0? \"M\" : \"L\")}${p.x} ${p.y}`).join(' '); \n\n\t\tlet tolerance = 1.5 / points[0].z;\n\t\tlet tmp = (0,_Simplify_js__WEBPACK_IMPORTED_MODULE_2__.simplify)(points, tolerance);\n\n\t\tlet smoothed = (0,_Simplify_js__WEBPACK_IMPORTED_MODULE_2__.smooth)(tmp, 90, true);\n\t\treturn (0,_Simplify_js__WEBPACK_IMPORTED_MODULE_2__.smoothToPath)(smoothed);\n\t\t\n\t}\n\tstatic distanceToLast(line, point) {\n\t\tlet last = line[line.length - 1];\n\t\treturn Line.distance(last, point);\n\t}\n\tstatic distance(a, b) {\n\t\tlet dx = a.x - b.x;\n\t\tlet dy = a.y - b.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n}\n\n/** @ignore */\nclass Erase {\n\tcreate(pos, event) { this.erased = false; this.erase(pos, event); }\n\tadjust(pos, event) { this.erase(pos, event); }\n\tfinish(pos, event) { return this.erase(pos, event); } //true if some points where removed.\n\ttap(pos, event) { return this.erase(pos, event); }\n\terase(pos, event) {\n\t\tfor (let e of this.annotation.elements) {\n\t\t\tif (e == event.originSrc) {\n\t\t\t\te.points = [];\n\t\t\t\tthis.erased = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet points = e.points;\n\t\t\tif (!points || !points.length)\n\t\t\t\tcontinue;\n\n\t\t\tif (Line.distanceToLast(points, pos) < 10)\n\t\t\t\tthis.erased = true, points.pop();\n\t\t\telse if (Line.distance(points[0], pos) < 10)\n\t\t\t\tthis.erased = true, points.shift();\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\tif (points.length <= 2) {\n\t\t\t\te.points = [];\n\t\t\t\te.setAttribute('d', '');\n\t\t\t\tthis.annotation.needsUpdate = true;\n\t\t\t\tthis.erased = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\te.setAttribute('d', Line.svgPath(points));\n\t\t}\n\t\tthis.annotation.elements = this.annotation.elements.filter(e => { return !e.points || e.points.length > 2; });\n\t\treturn this.erased;\n\t}\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CLEVBQUUsS0FBSyxFQUFFLElBQUk7O0FBRXJFO0FBQ0EsWUFBWSxzREFBUTs7QUFFcEIsaUJBQWlCLG9EQUFNO0FBQ3ZCLFNBQVMsMERBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDLHNCQUFzQjtBQUN0QixzQkFBc0IsaUNBQWlDO0FBQ3ZELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0UsMENBQTBDO0FBQzlHO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL0VkaXRvclN2Z0Fubm90YXRpb24uanM/YjUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTa2luIH0gZnJvbSAnLi9Ta2luLmpzJztcbmltcG9ydCB7IFV0aWwgfSBmcm9tICcuL1V0aWwuanMnO1xuaW1wb3J0IHsgc2ltcGxpZnksIHNtb290aCwgc21vb3RoVG9QYXRoIH0gZnJvbSAnLi9TaW1wbGlmeS5qcydcbmltcG9ydCB7IExheWVyU3ZnQW5ub3RhdGlvbiB9IGZyb20gJy4vTGF5ZXJTdmdBbm5vdGF0aW9uLmpzJ1xuaW1wb3J0IHsgQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4vQ29vcmRpbmF0ZVN5c3RlbS5qcydcblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgY3JlYXRlL3VwZGF0ZS9kZWxldGUgYW5ub3RhdGlvbnMuXG4gKiBAZnVuY3Rpb24gY3J1ZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Fubm90YXRpb259IGFubm8gVGhlIGN1cnJlbnQgYW5ub3RhdGlvbiBlbnRyeS5cbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGltcGxlbWVudGluZyBjdXN0b20gc3RhdGUgYW5ub3RhdGlvbnMuXG4gKiBAZnVuY3Rpb24gY3VzdG9tU3RhdGVDYWxsYmFja1xuICogQHBhcmFtIHtBbm5vdGF0aW9ufSBhbm5vIFRoZSBjdXJyZW50IGFubm90YXRpb24gZW50cnkuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayB0byBjdXN0b21pemUgdGhlIGFubm90YXRpb24gZGF0YSBvYmplY3QuXG4gKiBAZnVuY3Rpb24gY3VzdG9tRGF0YUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Fubm90YXRpb259IGFubm8gVGhlIGN1cnJlbnQgYW5ub3RhdGlvbiBlbnRyeS5cbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gYW4gYW5ub3RhdGlvbiBpcyBzZWxjdGVkIG9uIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqIEBmdW5jdGlvbiBzZWxlY3RlZENhbGxiYWNrXG4gKiBAcGFyYW0ge0Fubm90YXRpb259IGFubm8gVGhlIGN1cnJlbnQgYW5ub3RhdGlvbiBlbnRyeS5cbiAqL1xuXG4vKipcbiAqICoqRWRpdG9yU3ZnQW5ub3RhdGlvbioqIGVuYWJsZXMgdGhlIHtAbGluayBVSUJhc2ljfSBpbnRlcmZhY2UgdG8gZWRpdCAoY3JlYXRlL3VwZGF0ZS9kZWxldGUpIFNWRyBhbm5vdGF0aW9ucy5cbiAqIFRoaXMgY2xhc3MgaXMgYSBtZXJlIHV0aWxpdHkgdGhhdCBhY3RzIGFzIGFuIGFkYXB0ZXIgYmV0d2VlbiB0aGUgYW5ub3RhdGlvbiBkYXRhYmFzZSBhbmQgdGhlIE9wZW5MSU1FIHN5c3RlbS5cbiAqIFxuICogSGVyZSB5b3Ugd2lsbCBmaW5kIGEgdHV0b3JpYWwgdG8gbGVhcm4gaG93IHRvIHVzZSB0aGUgU1ZHIGFubm90YXRpb24gZWRpdG9yLiAvL0ZJWE1FXG4gKiBcbiAqIEZvciB0aGUgZXhwZXJpZW5jZWQgZGV2ZWxvcGVyIHRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgYXMgYW4gZXhhbXBsZSB0byBkZXNpZ24gbW9yZSBjb21wbGV4IGVkaXRvcnMuXG4gKiBcbiAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSBhbiAqKkVkaXRvclN2Z0Fubm90YXRpb24qKiBpcyBpbnN0YXRpYXRlZCBhbmQgY29ubmVjdGVkIHRvIHRoZSBhbm5vdGF0aW9uIGRhdGFiYXNlXG4gKiB0aHJvdWdoIHRocmVlIGNhbGxiYWNrcyBpbXBsZW1lbnRpbmcgZGF0YWJhc2Ugb3BlcmF0aW9ucyAoY3JlYXRlL3VwZGF0ZS9kZWxldGUpLlxuICogYGBgIFxuICogLy8gQ3JlYXRlcyBhbiBhbm5vdGF0aW9uIGxheWVyIGFuZCBhZGQgaXQgdG8gdGhlIGNhbnZhbnNcbiAqIGNvbnN0IGFubm8gPSBuZXcgT3BlbkxJTUUuTGF5ZXIoYU9wdGlvbnMpO1xuICogbGltZS5hZGRMYXllcignYW5ubycsIGFubm8pO1xuICpcbiAqIC8vIENyZWF0ZXMgYSBTVkcgYW5ub3RhdGlvbiBFZGl0b3JcbiAqIGNvbnN0IGVkaXRvciA9IG5ldyBPcGVuTElNRS5FZGl0b3JTdmdBbm5vdGF0aW9uKGxpbWUsIGFubm8sIHtcbiAqICAgICAgICAgIHZpZXdlcjogbGltZSxcbiAqICAgICAgICAgIGNsYXNzZXM6IGNsYXNzUGFyYW1cbiAqIH0pO1xuICogZWRpdG9yLmNyZWF0ZUNhbGxiYWNrID0gKGFubm8pID0+IHsgY29uc29sZS5sb2coXCJDcmVhdGVkIGFubm90YXRpb246IFwiLCBhbm5vKTsgcHJvY2Vzc1JlcXVlc3QoYW5ubywgJ2NyZWF0ZScpOyByZXR1cm4gdHJ1ZTsgfTtcbiAqIGVkaXRvci51cGRhdGVDYWxsYmFjayA9IChhbm5vKSA9PiB7IGNvbnNvbGUubG9nKFwiVXBkYXRlZCBhbm5vdGF0aW9uOiBcIiwgYW5ubyk7IHByb2Nlc3NSZXF1ZXN0KGFubm8sICd1cGRhdGUnKTsgcmV0dXJuIHRydWU7IH07XG4gKiBlZGl0b3IuZGVsZXRlQ2FsbGJhY2sgPSAoYW5ubykgPT4geyBjb25zb2xlLmxvZyhcIkRlbGV0ZWQgYW5ub3RhdGlvbjogXCIsIGFubm8pOyBwcm9jZXNzUmVxdWVzdChhbm5vLCAnZGVsZXRlJyk7IHJldHVybiB0cnVlOyB9O1xuICogYGBgXG4gKi9cbmNsYXNzIEVkaXRvclN2Z0Fubm90YXRpb24ge1xuXHQvKipcblx0ICogSW5zdGF0aWF0ZXMgYSBFZGl0b3JTdmdBbm5vdGF0aW9uIG9iamVjdC5cblx0ICogQHBhcmFtIHtWaWV3ZXJ9IHZpZXdlciBUaGUgT3BlbkxJTUUgdmlld2VyLlxuXHQgKiBAcGFyYW0ge0xheWVyU3ZnQW5ub3RhdGlvbn0gbGF5ZXIgVGhlIGFubm90YXRpb24gbGF5ZXIgb24gd2hpY2ggdG8gb3BlcmF0ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIFNWRyBlZGl0b3IgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtBbm5vdGF0aW9uQ2xhc3Nlc30gb3B0aW9ucy5jbGFzc2VzIEFuIG9iamVjdCBsaXRlcmFsIGRlZmlueWluZyBjb2xvcnMgYW5kIGxhYmVscyBvZiB0aGUgYW5ub3RhdGlvbiBjbGFzc2VzLlxuXHQgKiBAcGFyYW0ge2NydWRDYWxsYmFja30gb3B0aW9ucy5jcmVhdGVDYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW1wbGVtZW50IGFubm90YXRpb24gY3JlYXRpb24uXG5cdCAqIEBwYXJhbSB7Y3J1ZENhbGxiYWNrfSBvcHRpb25zLnVwZGF0ZUNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbXBsZW1lbnQgYW5ub3RhdGlvbiB1cGRhdGUuXG5cdCAqIEBwYXJhbSB7Y3J1ZENhbGxiYWNrfSBvcHRpb25zLmRlbGV0ZUNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbXBsZW1lbnQgYW5ub3RhdGlvbiBkZWxldGlvbi5cblx0ICogQHBhcmFtIHtib29sfSBvcHRpb25zLmVuYWJsZVN0YXRlPWZhbHNlIFdoZXRoZXIgdG8gZW5hYmxlIGN1c3RvbSBhbm5vdGF0aW9uIHN0YXRlLiBUaGlzIGFsbG93cyB0byBpbmNsdWRlIHNvbWUgc3RhdGUgdmFyaWFibGVzIGludG8gYW4gYW5ub3RhdGlvbiBpdGVtIChzdWNoIGFzIGNhbWVyYSwgbGlnaHQgb3IgbGVucyBwb3NpdGlvbikuXG5cdCAqIEBwYXJhbSB7Y3VzdG9tU3RhdGVDYWxsYmFja30gb3B0aW9ucy5jdXN0b21TdGF0ZSBUaGUgY2FsbGJhY2sgaW1wbGVtZW50aW5nIGN1c3RvbSBzdGF0ZSBhbm5vdGF0aW9ucy5cblx0ICogQHBhcmFtIHtjdXN0b21EYXRhQ2FsbGJhY2t9IG9wdGlvbnMuY3VzdG9tRGF0YSBUaGUgY2FsbGJhY2sgdG8gY3VzdG9taXplIHRoZSBhbm5vdGF0aW9uIGRhdGEgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3NlbGVjdGVkQ2FsbGJhY2t9IG9wdGlvbnMuc2VsZWN0ZWRDYWxsYmFjayBUaGUgY2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBhbiBhbm5vdGF0aW9uIGlzIHNlbGN0ZWQgb24gdGhlIHVzZXIgaW50ZXJmYWNlLlxuXHQgKi9cblx0Y29uc3RydWN0b3Iodmlld2VyLCBsYXllciwgb3B0aW9ucykge1xuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHtcblx0XHRcdHZpZXdlcjogdmlld2VyLFxuXHRcdFx0cGFubmluZzogZmFsc2UsXG5cdFx0XHR0b29sOiBudWxsLCAvL2RvaW5nIG5vdGhpbmcsIGNvdWxkOiBbJ2xpbmUnLCAncG9seWdvbicsICdwb2ludCcsICdib3gnLCAnY2lyY2xlJ11cblx0XHRcdHN0YXJ0UG9pbnQ6IG51bGwsIC8vc3RhcnRpbmcgcG9pbnQgZm9yIGJveCBhbmQgIGNpcmNsZVxuXHRcdFx0Y3VycmVudExpbmU6IFtdLFxuXHRcdFx0YW5ub3RhdGlvbjogbnVsbCxcblx0XHRcdHByaW9yaXR5OiAyMDAwMCxcblx0XHRcdGNsYXNzZXM6IHtcblx0XHRcdFx0Jyc6IHsgc3Ryb2tlOiAnIzAwMCcsIGxhYmVsOiAnJyB9LFxuXHRcdFx0XHQnY2xhc3MxJzogeyBzdHJva2U6ICcjNzcwJywgbGFiZWw6ICcnIH0sXG5cdFx0XHRcdCdjbGFzczInOiB7IHN0cm9rZTogJyM3MDcnLCBsYWJlbDogJycgfSxcblx0XHRcdFx0J2NsYXNzMyc6IHsgc3Ryb2tlOiAnIzc3NycsIGxhYmVsOiAnJyB9LFxuXHRcdFx0XHQnY2xhc3M0JzogeyBzdHJva2U6ICcjMDcwJywgbGFiZWw6ICcnIH0sXG5cdFx0XHRcdCdjbGFzczUnOiB7IHN0cm9rZTogJyMwMDcnLCBsYWJlbDogJycgfSxcblx0XHRcdFx0J2NsYXNzNic6IHsgc3Ryb2tlOiAnIzA3NycsIGxhYmVsOiAnJyB9LFxuXHRcdFx0fSxcblx0XHRcdHRvb2xzOiB7XG5cdFx0XHRcdHBvaW50OiB7XG5cdFx0XHRcdFx0aW1nOiAnPHN2ZyB3aWR0aD0yNCBoZWlnaHQ9MjQ+PGNpcmNsZSBjeD0xMiBjeT0xMiByPTMgZmlsbD1cInJlZFwiIHN0cm9rZT1cImdyYXlcIi8+PC9zdmc+Jyxcblx0XHRcdFx0XHR0b29sdGlwOiAnTmV3IHBvaW50Jyxcblx0XHRcdFx0XHR0b29sOiBQb2ludCxcblx0XHRcdFx0fSxcblx0XHRcdFx0cGluOiB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6ICh4LHkpID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiBgPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHg9JyR7eH0nIHk9JyR7eX0nIHdpZHRoPSc0JScgaGVpZ2h0PSc0JScgY2xhc3M9J3Bpbidcblx0XHRcdFx0XHRcdHZpZXdCb3g9JzAgMCAxOCAxOCc+PHBhdGggZD0nTSAwLDAgQyAwLDAgNCwwIDgsMCAxMiwwIDE2LDQgMTYsOCAxNiwxMiAxMiwxNiA4LDE2IDQsMTYgMCwxMiAwLDggMCw0IDAsMCAwLDAgWicvPjx0ZXh0IGNsYXNzPSdwaW4tdGV4dCcgeD0nNycgeT0nOCc+JHt0aGlzLmFubm90YXRpb24uaWR4fTwvdGV4dD48L3N2Zz5gO1xuXHRcdFx0XHRcdH0sIC8vcGluIGRpIGFsY2F6YXIgIDEuIHVybCBhIHN2ZyAyLiB0eHQgKHN0cmluZ2EgY29uIHN2ZykgMy4gZnVuemlvbmUoeCx5KSByaXRvcm5hIHN2ZyA0LiBkb20gKGRhIHNraW4pLlxuXHRcdFx0XHRcdHRvb2x0aXA6ICdOZXcgcGluJyxcblx0XHRcdFx0XHR0b29sOiBQaW5cblx0XHRcdFx0fSxcblx0XHRcdFx0cGVuOiB7XG5cdFx0XHRcdFx0aW1nOiAnPHN2ZyB3aWR0aD0yNCBoZWlnaHQ9MjQ+PGNpcmNsZSBjeD0xMiBjeT0xMiByPTMgZmlsbD1cInJlZFwiIHN0cm9rZT1cImdyYXlcIi8+PC9zdmc+Jyxcblx0XHRcdFx0XHR0b29sdGlwOiAnTmV3IHBvbHlsaW5lJyxcblx0XHRcdFx0XHR0b29sOiBQZW4sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxpbmU6IHtcblx0XHRcdFx0XHRpbWc6IGA8c3ZnIHdpZHRoPTI0IGhlaWdodD0yND5cblx0XHRcdFx0XHRcdDxwYXRoIGQ9XCJtIDQuNyw0LjUgYyAwLjUsNC44IDAuOCw4LjUgMy4xLDExIDIuNCwyLjYgNC4yLC00LjggNi4zLC01IDIuNywtMC4zIDUuMSw5LjMgNS4xLDkuM1wiIHN0cm9rZS13aWR0aD1cIjNcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImdyZXlcIi8+XG5cdFx0XHRcdFx0XHQ8cGF0aCBkPVwibSA0LjcsNC41IGMgMC41LDQuOCAwLjgsOC41IDMuMSwxMSAyLjQsMi42IDQuMiwtNC44IDYuMywtNSAyLjcsLTAuMyA1LjEsOS4zIDUuMSw5LjNcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJyZWRcIi8+PC9zdmc+YCxcblx0XHRcdFx0XHR0b29sdGlwOiAnTmV3IGxpbmUnLFxuXHRcdFx0XHRcdHRvb2w6IExpbmUsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVyYXNlOiB7XG5cdFx0XHRcdFx0aW1nOiAnJyxcblx0XHRcdFx0XHR0b29sdGlwOiAnRXJhc2UgbGluZXMnLFxuXHRcdFx0XHRcdHRvb2w6IEVyYXNlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRib3g6IHtcblx0XHRcdFx0XHRpbWc6ICc8c3ZnIHdpZHRoPTI0IGhlaWdodD0yND48cmVjdCB4PTUgeT01IHdpZHRoPTE0IGhlaWdodD0xNCBmaWxsPVwicmVkXCIgc3Ryb2tlPVwiZ3JheVwiLz48L3N2Zz4nLFxuXHRcdFx0XHRcdHRvb2x0aXA6ICdOZXcgYm94Jyxcblx0XHRcdFx0XHR0b29sOiBCb3gsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNpcmNsZToge1xuXHRcdFx0XHRcdGltZzogJzxzdmcgd2lkdGg9MjQgaGVpZ2h0PTI0PjxjaXJjbGUgY3g9MTIgY3k9MTIgcj03IGZpbGw9XCJyZWRcIiBzdHJva2U9XCJncmF5XCIvPjwvc3ZnPicsXG5cdFx0XHRcdFx0dG9vbHRpcDogJ05ldyBjaXJjbGUnLFxuXHRcdFx0XHRcdHRvb2w6IENpcmNsZSxcblx0XHRcdFx0fSxcblx0XHRcdFx0LypcdFx0XHRcdGNvbG9ycGljazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW1nOiAnJyxcblx0XHRcdFx0XHRcdFx0XHRcdHRvb2x0aXA6ICdQaWNrIGEgY29sb3InLFxuXHRcdFx0XHRcdFx0XHRcdFx0dG9vbDogQ29sb3JwaWNrLFxuXHRcdFx0XHRcdFx0XHRcdH0gKi9cblx0XHRcdH0sXG5cdFx0XHRhbm5vdGF0aW9uOiBudWxsLCAvL25vdCBudWxsIG9ubHkgd2hlbiBlZGl0V2lkZ2V0IGlzIHNob3duLlxuXHRcdFx0ZW5hYmxlU3RhdGU6IGZhbHNlLFxuXHRcdFx0Y3VzdG9tU3RhdGU6IG51bGwsXG5cdFx0XHRjdXN0b21EYXRhOiBudWxsLFxuXHRcdFx0ZWRpdFdpZGdldDogbnVsbCxcblx0XHRcdHNlbGVjdGVkQ2FsbGJhY2s6IG51bGwsXG5cdFx0XHRjcmVhdGVDYWxsYmFjazogbnVsbCwgLy9jYWxsYmFja3MgZm9yIGJhY2tlbmRcblx0XHRcdHVwZGF0ZUNhbGxiYWNrOiBudWxsLFxuXHRcdFx0ZGVsZXRlQ2FsbGJhY2s6IG51bGxcblx0XHR9LCBvcHRpb25zKTtcblxuXHRcdGxheWVyLnN0eWxlICs9IE9iamVjdC5lbnRyaWVzKHRoaXMuY2xhc3NlcykubWFwKChnKSA9PiBgW2RhdGEtY2xhc3M9JHtnWzBdfV0geyBzdHJva2U6JHtnWzFdLnN0eWxlLnN0cm9rZX07IH1gKS5qb2luKCdcXG4nKTtcblx0XHQvL2F0IHRoZSBtb21lbnQgaXMgbm90IHJlYWxseSBwb3NzaWJsZSB0byB1bnJlZ2lzdGVyIHRoZSBldmVudHMgcmVnaXN0ZXJlZCBoZXJlLlxuXHRcdHZpZXdlci5wb2ludGVyTWFuYWdlci5vbkV2ZW50KHRoaXMpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHRoaXMua2V5VXAoZSksIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudCgnc2VsZWN0ZWQnLCAoYW5ubykgPT4ge1xuXHRcdFx0aWYgKCFhbm5vIHx8IGFubm8gPT0gdGhpcy5hbm5vdGF0aW9uKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZih0aGlzLnNlbGVjdGVkQ2FsbGJhY2spIHRoaXMuc2VsZWN0ZWRDYWxsYmFjayhhbm5vKTtcblx0XHRcdHRoaXMuc2hvd0VkaXRXaWRnZXQoYW5ubyk7XG5cdFx0fSk7XG5cblx0XHRsYXllci5hbm5vdGF0aW9uc0VudHJ5ID0gKCkgPT4ge1xuXG5cdFx0XHRsZXQgZW50cnkgPSB7XG5cdFx0XHRcdGh0bWw6IGA8ZGl2IGNsYXNzPVwib3BlbmxpbWUtdG9vbHNcIj48L2Rpdj5gLFxuXHRcdFx0XHRsaXN0OiBbXSwgLy93aWxsIGJlIGZpbGxlZCBsYXRlci5cblx0XHRcdFx0Y2xhc3NlczogJ29wZW5saW1lLWFubm90YXRpb25zJyxcblx0XHRcdFx0c3RhdHVzOiAoKSA9PiAnYWN0aXZlJyxcblx0XHRcdFx0b25jcmVhdGU6ICgpID0+IHtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShsYXllci5hbm5vdGF0aW9ucykpXG5cdFx0XHRcdFx0XHRsYXllci5jcmVhdGVBbm5vdGF0aW9uc0xpc3QoKTtcblxuXHRcdFx0XHRcdGxldCB0b29scyA9IHtcblx0XHRcdFx0XHRcdCdhZGQnOiB7IGFjdGlvbjogKCkgPT4geyB0aGlzLmNyZWF0ZUFubm90YXRpb24oKTsgfSwgdGl0bGU6IFwiTmV3IGFubm90YXRpb25cIiB9LFxuXHRcdFx0XHRcdFx0J2VkaXQnOiB7IGFjdGlvbjogKCkgPT4geyB0aGlzLnRvZ2dsZUVkaXRXaWRnZXQoKTsgfSwgdGl0bGU6IFwiRWRpdCBhbm5vdGF0aW9uc1wiIH0sXG5cdFx0XHRcdFx0XHQnZXhwb3J0JzogeyBhY3Rpb246ICgpID0+IHsgdGhpcy5leHBvcnRBbm5vdGF0aW9ucygpOyB9LCB0aXRsZTogXCJFeHBvcnQgYW5ub3RhdGlvbnNcIiB9LFxuXHRcdFx0XHRcdFx0J3RyYXNoJzogeyBhY3Rpb246ICgpID0+IHsgdGhpcy5kZWxldGVTZWxlY3RlZCgpOyB9LCB0aXRsZTogXCJEZWxldGUgc2VsZWN0ZWQgYW5ub3RhdGlvbnNcIiB9LFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0KGFzeW5jICgpID0+IHtcblxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBbbGFiZWwsIHRvb2xdIG9mIE9iamVjdC5lbnRyaWVzKHRvb2xzKSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgaWNvbiA9IGF3YWl0IFNraW4uYXBwZW5kSWNvbihlbnRyeS5lbGVtZW50LmZpcnN0Q2hpbGQsICcub3BlbmxpbWUtJyArIGxhYmVsKTsgLy8gVE9ETyBwYXNzIGVudHJ5LmVsZW1lbnQuZmlyc3RDaGlsZCBhcyBwYXJhbWV0ZXIgaW4gb25DcmVhdGVcblx0XHRcdFx0XHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdG9vbC50aXRsZSk7XG5cdFx0XHRcdFx0XHRcdGljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0b29sLmFjdGlvbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGF5ZXIuYW5ub3RhdGlvbnNMaXN0RW50cnkgPSBlbnRyeTtcblx0XHRcdHJldHVybiBlbnRyeTtcblx0XHR9XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRjcmVhdGVBbm5vdGF0aW9uKCkge1xuXHRcdGxldCBhbm5vID0gdGhpcy5sYXllci5uZXdBbm5vdGF0aW9uKCk7XG5cdFx0aWYodGhpcy5jdXN0b21EYXRhKSB0aGlzLmN1c3RvbURhdGEoYW5ubyk7XG5cdFx0aWYodGhpcy5lbmFibGVTdGF0ZSkgdGhpcy5zZXRBbm5vdGF0aW9uQ3VycmVudFN0YXRlKGFubm8pO1xuXHRcdGFubm8uaWR4ID0gdGhpcy5sYXllci5hbm5vdGF0aW9ucy5sZW5ndGg7XG5cdFx0YW5uby5wdWJsaXNoID0gMTtcblx0XHRhbm5vLmxhYmVsID0gYW5uby5kZXNjcmlwdGlvbiA9IGFubm8uY2xhc3MgPSAnJztcblx0XHRsZXQgcG9zdCA9IHtcblx0XHRcdGlkOiBhbm5vLmlkLCBpZHg6IGFubm8uaWR4LCBsYWJlbDogYW5uby5sYWJlbCwgZGVzY3JpcHRpb246IGFubm8uZGVzY3JpcHRpb24sICdjbGFzcyc6IGFubm8uY2xhc3MsIHN2ZzogbnVsbCxcblx0XHRcdHB1Ymxpc2g6IGFubm8ucHVibGlzaCwgZGF0YTogYW5uby5kYXRhXG5cdFx0fTtcblx0XHRpZiAodGhpcy5lbmFibGVTdGF0ZSkgcG9zdCA9IHsgLi4ucG9zdCwgc3RhdGU6IGFubm8uc3RhdGUgfTtcblx0XHRpZiAodGhpcy5jcmVhdGVDYWxsYmFjaykge1xuXHRcdFx0bGV0IHJlc3VsdCA9IHRoaXMuY3JlYXRlQ2FsbGJhY2socG9zdCk7XG5cdFx0XHRpZiAoIXJlc3VsdClcblx0XHRcdFx0YWxlcnQoXCJGYWlsZWQgdG8gY3JlYXRlIGFubm90YXRpb24hXCIpO1xuXHRcdH1cblx0XHR0aGlzLmxheWVyLnNldFNlbGVjdGVkKGFubm8pO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0dG9nZ2xlRWRpdFdpZGdldCgpIHtcblx0XHRpZiAodGhpcy5hbm5vdGF0aW9uKVxuXHRcdFx0cmV0dXJuIHRoaXMuaGlkZUVkaXRXaWRnZXQoKTtcblxuXHRcdGxldCBpZCA9IHRoaXMubGF5ZXIuc2VsZWN0ZWQudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXHRcdGlmICghaWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRsZXQgYW5ubyA9IHRoaXMubGF5ZXIuZ2V0QW5ub3RhdGlvbkJ5SWQoaWQpO1xuXHRcdHRoaXMuc2hvd0VkaXRXaWRnZXQoYW5ubyk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR1cGRhdGVFZGl0V2lkZ2V0KCkge1xuXHRcdGxldCBhbm5vID0gdGhpcy5hbm5vdGF0aW9uO1xuXHRcdGxldCBlZGl0ID0gdGhpcy5lZGl0V2lkZ2V0O1xuXHRcdGlmICghYW5uby5jbGFzcylcblx0XHRcdGFubm8uY2xhc3MgPSAnJztcblx0XHRlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWxhYmVsXScpLnZhbHVlID0gYW5uby5sYWJlbCB8fCAnJztcblx0XHRlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWRlc2NyaXB0aW9uXScpLnZhbHVlID0gYW5uby5kZXNjcmlwdGlvbiB8fCAnJztcblx0XHRlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWlkeF0nKS52YWx1ZSA9IGFubm8uaWR4IHx8ICcnO1xuXHRcdE9iamVjdC5lbnRyaWVzKGFubm8uZGF0YSkubWFwKGsgPT4ge1xuXHRcdFx0ZWRpdC5xdWVyeVNlbGVjdG9yKGBbbmFtZT1kYXRhLWRhdGEtJHtrWzBdfV1gKS52YWx1ZSA9IGtbMV0gfHwgJyc7XG5cdFx0fSk7XG5cblx0XHRlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWNsYXNzZXNdJykudmFsdWUgPSBhbm5vLmNsYXNzO1xuXHRcdGVkaXQucXVlcnlTZWxlY3RvcignW25hbWU9cHVibGlzaF0nKS5jaGVja2VkID0gYW5uby5wdWJsaXNoID09IDE7XG5cdFx0ZWRpdC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcblx0XHRsZXQgYnV0dG9uID0gZWRpdC5xdWVyeVNlbGVjdG9yKCcub3BlbmxpbWUtc2VsZWN0LWJ1dHRvbicpO1xuXHRcdGJ1dHRvbi50ZXh0Q29udGVudCA9IHRoaXMuY2xhc3Nlc1thbm5vLmNsYXNzXS5sYWJlbDtcblx0XHRidXR0b24uc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMuY2xhc3Nlc1thbm5vLmNsYXNzXS5zdHlsZS5zdHJva2U7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRzaG93RWRpdFdpZGdldChhbm5vKSB7XG5cdFx0dGhpcy5hbm5vdGF0aW9uID0gYW5ubztcblx0XHR0aGlzLnNldFRvb2wobnVsbCk7XG5cdFx0dGhpcy5zZXRBY3RpdmVUb29sKCk7XG5cdFx0dGhpcy5sYXllci5hbm5vdGF0aW9uc0xpc3RFbnRyeS5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcGVubGltZS1lZGl0JykuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cdFx0KGFzeW5jICgpID0+IHtcblx0XHRcdGF3YWl0IHRoaXMuY3JlYXRlRWRpdFdpZGdldCgpO1xuXHRcdFx0dGhpcy51cGRhdGVFZGl0V2lkZ2V0KCk7XG5cdFx0fSkoKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGhpZGVFZGl0V2lkZ2V0KCkge1xuXHRcdHRoaXMuYW5ub3RhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5zZXRUb29sKG51bGwpO1xuXHRcdHRoaXMuZWRpdFdpZGdldC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcblx0XHR0aGlzLmxheWVyLmFubm90YXRpb25zTGlzdEVudHJ5LmVsZW1lbnQucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLWVkaXQnKS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcblx0fVxuXG5cdC8vVE9ETyB0aGlzIHNob3VsZCBhY3R1YWxseSBiZSBpbiB0aGUgaHRtbC5cblx0LyoqIEBpZ25vcmUgKi9cblx0YXN5bmMgY3JlYXRlRWRpdFdpZGdldCgpIHtcblx0XHRpZiAodGhpcy5lZGl0V2lkZ2V0KVxuXHRcdFx0cmV0dXJuO1x0XHRcblx0XHRsZXQgaHRtbCA9IGBcblx0XHRcdFx0PGRpdiBjbGFzcz1cIm9wZW5saW1lLWFubm90YXRpb24tZWRpdFwiPlxuXHRcdFx0XHRcdDxsYWJlbCBmb3I9XCJsYWJlbFwiPlRpdGxlOjwvbGFiZWw+IDxpbnB1dCBuYW1lPVwibGFiZWxcIiB0eXBlPVwidGV4dFwiPjxicj5cblx0XHRcdFx0XHQ8bGFiZWwgZm9yPVwiZGVzY3JpcHRpb25cIj5EZXNjcmlwdGlvbjo8L2xhYmVsPjxicj5cblx0XHRcdFx0XHQ8dGV4dGFyZWEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29scz1cIjMwXCIgcm93cz1cIjVcIj48L3RleHRhcmVhPjxicj5cblx0XHRcdFx0XHQ8c3Bhbj5DbGFzczo8L3NwYW4+IFxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJvcGVubGltZS1zZWxlY3RcIj5cblx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cImNsYXNzZXNcIiB2YWx1ZT1cIlwiLz5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJvcGVubGltZS1zZWxlY3QtYnV0dG9uXCI+PC9kaXY+XG5cdFx0XHRcdFx0XHQ8dWwgY2xhc3M9XCJvcGVubGltZS1zZWxlY3QtbWVudVwiPlxuXHRcdFx0XHRcdFx0JHtPYmplY3QuZW50cmllcyh0aGlzLmNsYXNzZXMpLm1hcCgoYykgPT5cblx0XHRcdGA8bGkgZGF0YS1jbGFzcz1cIiR7Y1swXX1cIiBzdHlsZT1cImJhY2tncm91bmQ6JHtjWzFdLnN0eWxlLnN0cm9rZX07XCI+JHtjWzFdLmxhYmVsfTwvbGk+YCkuam9pbignXFxuJyl9XG5cdFx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxsYWJlbCBmb3I9XCJpZHhcIj5JbmRleDo8L2xhYmVsPiA8aW5wdXQgbmFtZT1cImlkeFwiIHR5cGU9XCJ0ZXh0XCI+PGJyPlx0XG5cdFx0XHRcdFx0JHtPYmplY3QuZW50cmllcyh0aGlzLmFubm90YXRpb24uZGF0YSkubWFwKGsgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IGxhYmVsID0ga1swXTtcblx0XHRcdFx0XHRcdGxldCBzdHIgPSBgPGxhYmVsIGZvcj1cImRhdGEtZGF0YS0ke2tbMF19XCI+JHtsYWJlbH06PC9sYWJlbD4gPGlucHV0IG5hbWU9XCJkYXRhLWRhdGEtJHtrWzBdfVwiIHR5cGU9XCJ0ZXh0XCI+PGJyPmBcblx0XHRcdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHRcdFx0fSkuam9pbignXFxuJyl9XG5cdFx0XHRcdFx0PGJyPlxuXHRcdFx0XHRcdDxzcGFuPjxidXR0b24gY2xhc3M9XCJvcGVubGltZS1zdGF0ZVwiPlNBVkU8L2J1dHRvbj48L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCJwdWJsaXNoXCIgdmFsdWU9XCJcIj4gUHVibGlzaDwvc3Bhbj48YnI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm9wZW5saW1lLWFubm90YXRpb24tZWRpdC10b29sc1wiPjwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5gO1xuXHRcdGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5cdFx0dGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbC50cmltKCk7XG5cdFx0bGV0IGVkaXQgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRsZXQgc2VsZWN0ID0gZWRpdC5xdWVyeVNlbGVjdG9yKCcub3BlbmxpbWUtc2VsZWN0Jyk7XG5cdFx0bGV0IGJ1dHRvbiA9IGVkaXQucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLXNlbGVjdC1idXR0b24nKTtcblx0XHRsZXQgdWwgPSBlZGl0LnF1ZXJ5U2VsZWN0b3IoJ3VsJyk7XG5cdFx0bGV0IG9wdGlvbnMgPSBlZGl0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyk7XG5cdFx0bGV0IGlucHV0ID0gZWRpdC5xdWVyeVNlbGVjdG9yKCdbbmFtZT1jbGFzc2VzXScpO1xuXG5cdFx0bGV0IHN0YXRlID0gZWRpdC5xdWVyeVNlbGVjdG9yKCcub3BlbmxpbWUtc3RhdGUnKTtcblx0XHRcblx0XHRzdGF0ZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG5cdFx0XHRpZih0aGlzLmVuYWJsZVN0YXRlKSB0aGlzLnNldEFubm90YXRpb25DdXJyZW50U3RhdGUodGhpcy5hbm5vdGF0aW9uKTtcblx0XHRcdHRoaXMuc2F2ZUN1cnJlbnQoKTtcblx0XHRcdHRoaXMuc2F2ZUFubm90YXRpb24oKTsgXG5cdFx0fSk7XG5cblx0XHRidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGZvciAobGV0IG8gb2Ygb3B0aW9ucylcblx0XHRcdFx0by5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuXHRcdFx0c2VsZWN0LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xuXG5cdFx0fSk7XG5cblx0XHR1bC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRpbnB1dC52YWx1ZSA9IGUuc3JjRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2xhc3MnKTtcblx0XHRcdGlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnKSk7XG5cdFx0XHRidXR0b24uc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMuY2xhc3Nlc1tpbnB1dC52YWx1ZV0uc3R5bGUuc3Ryb2tlO1xuXHRcdFx0YnV0dG9uLnRleHRDb250ZW50ID0gZS5zcmNFbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0XHRzZWxlY3QuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG5cdFx0fSk7XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG5cdFx0XHRzZWxlY3QuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cdFx0fSk7XG5cblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcub3BlbmxpbWUtbGF5ZXJzLW1lbnUnKS5hcHBlbmRDaGlsZChlZGl0KTtcblxuXHRcdGxldCB0b29scyA9IGVkaXQucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLWFubm90YXRpb24tZWRpdC10b29scycpO1xuXG5cdFx0bGV0IHBpbiA9IGF3YWl0IFNraW4uYXBwZW5kSWNvbih0b29scywgJy5vcGVubGltZS1waW4nKTtcblx0XHRwaW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4geyB0aGlzLnNldFRvb2woJ3BpbicpOyB0aGlzLnNldEFjdGl2ZVRvb2wocGluKTsgfSk7XG5cblx0XHRsZXQgZHJhdyA9IGF3YWl0IFNraW4uYXBwZW5kSWNvbih0b29scywgJy5vcGVubGltZS1kcmF3Jyk7XG5cdFx0ZHJhdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7IHRoaXMuc2V0VG9vbCgnbGluZScpOyB0aGlzLnNldEFjdGl2ZVRvb2woZHJhdyk7IH0pO1xuXG5cblx0XHQvL1x0XHRsZXQgcGVuID0gYXdhaXQgU2tpbi5hcHBlbmRJY29uKHRvb2xzLCAnLm9wZW5saW1lLXBlbicpOyBcblx0XHQvL1x0XHRwZW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4geyB0aGlzLnNldFRvb2woJ3BlbicpOyBzZXRBY3RpdmUocGVuKTsgfSk7XG5cblx0XHRsZXQgZXJhc2UgPSBhd2FpdCBTa2luLmFwcGVuZEljb24odG9vbHMsICcub3BlbmxpbWUtZXJhc2UnKTtcblx0XHRlcmFzZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7IHRoaXMuc2V0VG9vbCgnZXJhc2UnKTsgdGhpcy5zZXRBY3RpdmVUb29sKGVyYXNlKTsgfSk7XG5cblx0XHRsZXQgdW5kbyA9IGF3YWl0IFNraW4uYXBwZW5kSWNvbih0b29scywgJy5vcGVubGltZS11bmRvJyk7XG5cdFx0dW5kby5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7IHRoaXMudW5kbygpOyB9KTtcblxuXHRcdGxldCByZWRvID0gYXdhaXQgU2tpbi5hcHBlbmRJY29uKHRvb2xzLCAnLm9wZW5saW1lLXJlZG8nKTtcblx0XHRyZWRvLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHsgdGhpcy5yZWRvKCk7IH0pO1xuXG5cdFx0LypcdFx0bGV0IGNvbG9ycGljayA9IGF3YWl0IFNraW4uYXBwZW5kSWNvbih0b29scywgJy5vcGVubGltZS1jb2xvcnBpY2snKTsgXG5cdFx0XHRcdHVuZG8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4geyB0aGlzLnBpY2tDb2xvcigpOyB9KTsgKi9cblxuXHRcdGxldCBsYWJlbCA9IGVkaXQucXVlcnlTZWxlY3RvcignW25hbWU9bGFiZWxdJyk7XG5cdFx0bGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChlKSA9PiB7IGlmICh0aGlzLmFubm90YXRpb24ubGFiZWwgIT0gbGFiZWwudmFsdWUpIHRoaXMuc2F2ZUN1cnJlbnQoKTsgdGhpcy5zYXZlQW5ub3RhdGlvbigpOyB9KTtcblxuXHRcdGxldCBkZXNjciA9IGVkaXQucXVlcnlTZWxlY3RvcignW25hbWU9ZGVzY3JpcHRpb25dJyk7XG5cdFx0ZGVzY3IuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChlKSA9PiB7IGlmICh0aGlzLmFubm90YXRpb24uZGVzY3JpcHRpb24gIT0gZGVzY3IudmFsdWUpIHRoaXMuc2F2ZUN1cnJlbnQoKTsgdGhpcy5zYXZlQW5ub3RhdGlvbigpOyB9KTtcblxuXHRcdGxldCBpZHggPSBlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWlkeF0nKTtcblx0XHRpZHguYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChlKSA9PiB7IFxuXHRcdFx0aWYgKHRoaXMuYW5ub3RhdGlvbi5pZHggIT0gaWR4LnZhbHVlKSB7XG5cdFx0XHRcdGNvbnN0IHN2Z1BpbklkeCA9IHRoaXMuYW5ub3RhdGlvbi5lbGVtZW50c1swXTtcblx0XHRcdFx0aWYoc3ZnUGluSWR4KSB7XG5cdFx0XHRcdFx0Y29uc3QgdHh0ID0gc3ZnUGluSWR4LnF1ZXJ5U2VsZWN0b3IoXCIucGluLXRleHRcIik7XG5cdFx0XHRcdFx0aWYodHh0KSB7XG5cdFx0XHRcdFx0XHR0eHQudGV4dENvbnRlbnQgPSBpZHgudmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2F2ZUN1cnJlbnQoKTtcblx0XHRcdH0gXG5cdFx0XHR0aGlzLnNhdmVBbm5vdGF0aW9uKCk7IFxuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmVudHJpZXModGhpcy5hbm5vdGF0aW9uLmRhdGEpLm1hcChrID0+IHtcblx0XHRcdGxldCBkYXRhRWxtID0gZWRpdC5xdWVyeVNlbGVjdG9yKGBbbmFtZT1kYXRhLWRhdGEtJHtrWzBdfV1gKTtcblx0XHRcdGRhdGFFbG0uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIChlKSA9PiB7IGlmICh0aGlzLmFubm90YXRpb24uZGF0YVtrWzBdXSAhPSBkYXRhRWxtLnZhbHVlKSB0aGlzLnNhdmVDdXJyZW50KCk7IHRoaXMuc2F2ZUFubm90YXRpb24oKTsgfSk7XG5cdFx0fSk7XG5cblx0XHRsZXQgY2xhc3NlcyA9IGVkaXQucXVlcnlTZWxlY3RvcignW25hbWU9Y2xhc3Nlc10nKTtcblx0XHRjbGFzc2VzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7IGlmICh0aGlzLmFubm90YXRpb24uY2xhc3MgIT0gY2xhc3Nlcy52YWx1ZSkgdGhpcy5zYXZlQ3VycmVudCgpOyB0aGlzLnNhdmVBbm5vdGF0aW9uKCk7IH0pO1xuXG5cdFx0bGV0IHB1Ymxpc2ggPSBlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPXB1Ymxpc2hdJyk7XG5cdFx0cHVibGlzaC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4geyBpZiAodGhpcy5hbm5vdGF0aW9uLnB1Ymxpc2ggIT0gcHVibGlzaC52YWx1ZSkgdGhpcy5zYXZlQ3VycmVudCgpOyB0aGlzLnNhdmVBbm5vdGF0aW9uKCk7IH0pO1xuXG5cdFx0ZWRpdC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcblx0XHR0aGlzLmVkaXRXaWRnZXQgPSBlZGl0O1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0c2V0QW5ub3RhdGlvbkN1cnJlbnRTdGF0ZShhbm5vKSB7XG5cdFx0YW5uby5zdGF0ZSA9IHdpbmRvdy5zdHJ1Y3R1cmVkQ2xvbmUodGhpcy52aWV3ZXIuY2FudmFzLmdldFN0YXRlKCkpO1xuXHRcdC8vIENhbGxiYWNrIHRvIGFkZCAgbGlnaHQvbGVucyBwYXJhbXMgb3Igb3RoZXIgZGF0YVxuXHRcdGlmKHRoaXMuY3VzdG9tU3RhdGUpIHRoaXMuY3VzdG9tU3RhdGUoYW5ubyk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRzYXZlQW5ub3RhdGlvbigpIHtcblx0XHRsZXQgZWRpdCA9IHRoaXMuZWRpdFdpZGdldDtcblx0XHRsZXQgYW5ubyA9IHRoaXMuYW5ub3RhdGlvbjtcblxuXHRcdGFubm8ubGFiZWwgPSBlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWxhYmVsXScpLnZhbHVlIHx8ICcnO1xuXHRcdGFubm8uZGVzY3JpcHRpb24gPSBlZGl0LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPWRlc2NyaXB0aW9uXScpLnZhbHVlIHx8ICcnO1xuXHRcdGFubm8uaWR4ID0gZWRpdC5xdWVyeVNlbGVjdG9yKCdbbmFtZT1pZHhdJykudmFsdWUgfHwgJzAnO1xuXHRcdE9iamVjdC5lbnRyaWVzKGFubm8uZGF0YSkubWFwKGsgPT4ge1xuXHRcdFx0YW5uby5kYXRhW2tbMF1dID0gZWRpdC5xdWVyeVNlbGVjdG9yKGBbbmFtZT1kYXRhLWRhdGEtJHtrWzBdfV1gKS52YWx1ZSB8fCAnJztcblx0XHR9KTtcdFx0XG5cdFx0YW5uby5wdWJsaXNoID0gZWRpdC5xdWVyeVNlbGVjdG9yKCdbbmFtZT1wdWJsaXNoXScpLmNoZWNrZWQgPyAxIDogMDtcblx0XHRsZXQgc2VsZWN0ID0gZWRpdC5xdWVyeVNlbGVjdG9yKCdbbmFtZT1jbGFzc2VzXScpO1xuXHRcdGFubm8uY2xhc3MgPSBzZWxlY3QudmFsdWUgfHwgJyc7XG5cblx0XHRsZXQgYnV0dG9uID0gZWRpdC5xdWVyeVNlbGVjdG9yKCcub3BlbmxpbWUtc2VsZWN0LWJ1dHRvbicpO1xuXHRcdGJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kID0gdGhpcy5jbGFzc2VzW2Fubm8uY2xhc3NdLnN0eWxlLnN0cm9rZTtcblxuXHRcdGZvciAobGV0IGUgb2YgdGhpcy5hbm5vdGF0aW9uLmVsZW1lbnRzKVxuXHRcdFx0ZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtY2xhc3MnLCBhbm5vLmNsYXNzKTtcblxuXHRcdGxldCBwb3N0ID0ge1xuXHRcdFx0aWQ6IGFubm8uaWQsIGlkeDogYW5uby5pZHgsIGxhYmVsOiBhbm5vLmxhYmVsLCBkZXNjcmlwdGlvbjogYW5uby5kZXNjcmlwdGlvbiwgY2xhc3M6IGFubm8uY2xhc3MsXG5cdFx0XHRwdWJsaXNoOiBhbm5vLnB1Ymxpc2gsIGRhdGE6IGFubm8uZGF0YVxuXHRcdH07XG5cdFx0aWYgKHRoaXMuZW5hYmxlU3RhdGUpIHBvc3QgPSB7IC4uLnBvc3QsIHN0YXRlOiBhbm5vLnN0YXRlIH07XG5cdFx0Ly8gaWYgKGFubm8ubGlnaHQpIHBvc3QgPSB7IC4uLnBvc3QsIGxpZ2h0OiBhbm5vLmxpZ2h0IH07IEZJWE1FXG5cdFx0Ly8gaWYgKGFubm8ubGVucykgcG9zdCA9IHsgLi4ucG9zdCwgbGVuczogYW5uby5sZW5zIH07XG5cblx0XHQvL2Fubm8uYmJveCA9IGFubm8uZ2V0QkJveEZyb21FbGVtZW50cygpO1xuXHRcdGxldCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcblx0XHRwb3N0LnN2ZyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cblx0XHRcdFx0JHthbm5vLmVsZW1lbnRzLm1hcCgocykgPT4geyBzLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7IHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHMpIH0pLmpvaW4oXCJcXG5cIil9ICBcblx0XHRcdFx0PC9zdmc+YDtcblxuXHRcdGlmICh0aGlzLnVwZGF0ZUNhbGxiYWNrKSB7XG5cdFx0XHRsZXQgcmVzdWx0ID0gdGhpcy51cGRhdGVDYWxsYmFjayhwb3N0KTtcblx0XHRcdGlmICghcmVzdWx0KSB7XG5cdFx0XHRcdGFsZXJ0KFwiRmFpbGVkIHRvIHVwZGF0ZSBhbm5vdGF0aW9uXCIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVx0XHRcdFx0Ly9mb3IgKGxldCBjIG9mIGVsZW1lbnQuY2hpbGRyZW4pXG5cdFx0Ly9cdFx0YS5lbGVtZW50cy5wdXNoKGMpO1xuXG5cdFx0Ly91cGRhdGUgdGhlIGVudHJ5XG5cdFx0bGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblx0XHR0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0aGlzLmxheWVyLmNyZWF0ZUFubm90YXRpb25FbnRyeShhbm5vKTtcblx0XHRsZXQgZW50cnkgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ7XG5cdFx0Ly9UT0RPIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGxvY2F0ZSB0aGUgZW50cnkhXG5cdFx0dGhpcy5sYXllci5hbm5vdGF0aW9uc0xpc3RFbnRyeS5lbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtYW5ub3RhdGlvbj1cIiR7YW5uby5pZH1cIl1gKS5yZXBsYWNlV2l0aChlbnRyeSk7XG5cdFx0dGhpcy5sYXllci5zZXRTZWxlY3RlZChhbm5vKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGRlbGV0ZVNlbGVjdGVkKCkge1xuXHRcdGxldCBpZCA9IHRoaXMubGF5ZXIuc2VsZWN0ZWQudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXHRcdGlmIChpZClcblx0XHRcdHRoaXMuZGVsZXRlQW5ub3RhdGlvbihpZCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRkZWxldGVBbm5vdGF0aW9uKGlkKSB7XG5cdFx0bGV0IGFubm8gPSB0aGlzLmxheWVyLmdldEFubm90YXRpb25CeUlkKGlkKTtcblx0XHRpZiAodGhpcy5kZWxldGVDYWxsYmFjaykge1xuXHRcdFx0aWYgKCFjb25maXJtKGBEZWxldGluZyBhbm5vdGF0aW9uICR7YW5uby5sYWJlbH0sIGFyZSB5b3Ugc3VyZT9gKSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0bGV0IHJlc3VsdCA9IHRoaXMuZGVsZXRlQ2FsbGJhY2soYW5ubyk7XG5cdFx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0XHRhbGVydChcIkZhaWxlZCB0byBkZWxldGUgdGhpcyBhbm5vdGF0aW9uLlwiKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvL3JlbW92ZSBzdmcgZWxlbWVudHMgZnJvbSB0aGUgY2FudmFzXG5cdFx0dGhpcy5sYXllci5zdmdHcm91cC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1hbm5vdGF0aW9uPVwiJHthbm5vLmlkfVwiXWApLmZvckVhY2goZSA9PiBlLnJlbW92ZSgpKTtcblxuXHRcdC8vcmVtb3ZlIGVudHJ5IGZyb20gdGhlIGxpc3Rcblx0XHRsZXQgbGlzdCA9IHRoaXMubGF5ZXIuYW5ub3RhdGlvbnNMaXN0RW50cnkuZWxlbWVudC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcGVubGltZS1saXN0Jyk7XG5cdFx0bGlzdC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1hbm5vdGF0aW9uPVwiJHthbm5vLmlkfVwiXWApLmZvckVhY2goZSA9PiBlLnJlbW92ZSgpKTtcblxuXHRcdHRoaXMubGF5ZXIuYW5ub3RhdGlvbnMgPSB0aGlzLmxheWVyLmFubm90YXRpb25zLmZpbHRlcihhID0+IGEgIT09IGFubm8pO1xuXHRcdHRoaXMubGF5ZXIuY2xlYXJTZWxlY3RlZCgpO1xuXHRcdHRoaXMuaGlkZUVkaXRXaWRnZXQoKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGV4cG9ydEFubm90YXRpb25zKCkge1xuXHRcdGxldCBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcblx0XHRjb25zdCBiQm94ID0gdGhpcy5sYXllci5ib3VuZGluZ0JveCgpO1xuXHRcdHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgYDAgMCAke2JCb3gueEhpZ2gtYkJveC54TG93fSAke2JCb3gueUhpZ2gtYkJveC55TG93fWApO1xuXHRcdGxldCBzdHlsZSA9IFV0aWwuY3JlYXRlU1ZHRWxlbWVudCgnc3R5bGUnKTtcblx0XHRzdHlsZS50ZXh0Q29udGVudCA9IHRoaXMubGF5ZXIuc3R5bGU7XG5cdFx0c3ZnRWxlbWVudC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0bGV0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuXHRcdC8vbGV0IHN2ZyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cblx0XHRmb3IgKGxldCBhbm5vIG9mIHRoaXMubGF5ZXIuYW5ub3RhdGlvbnMpIHtcblx0XHRcdGZvciAobGV0IGUgb2YgYW5uby5lbGVtZW50cykge1xuXHRcdFx0XHRpZiAoZS50YWdOYW1lID09ICdwYXRoJykge1xuXHRcdFx0XHRcdC8vSW5rc2NhcGUgbml0cGlja3Mgb24gdGhlIGNvbW1hcyBpbiBzdmcgcGF0aC5cblx0XHRcdFx0XHRsZXQgZCA9IGUuZ2V0QXR0cmlidXRlKCdkJyk7XG5cdFx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoJ2QnLCBkLnJlcGxhY2VBbGwoJywnLCAnICcpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdmdFbGVtZW50LmFwcGVuZENoaWxkKGUuY2xvbmVOb2RlKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsZXQgc3ZnID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcblx0XHQvKigke3RoaXMubGF5ZXIuYW5ub3RhdGlvbnMubWFwKGFubm8gPT4ge1xuXHRcdFx0cmV0dXJuIGA8Z3JvdXAgaWQ9XCIke2Fubm8uaWR9XCIgdGl0bGU9XCIke2Fubm8ubGFiZWx9XCIgZGF0YS1kZXNjcmlwdGlvbj1cIiR7YW5uby5kZXNjcmlwdGlvbn1cIj5cblx0XHRcdFx0JHthbm5vLmVsZW1lbnRzLm1hcCgocykgPT4geyBcblx0XHRcdFx0XHRzLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7IFxuXHRcdFx0XHRcdHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHMpIFxuXHRcdFx0XHR9KS5qb2luKFwiXFxuXCIpfVxuXHRcdFx0XHQ8L2dyb3VwPmA7XG5cdFx0fSl9XG5cdFx0PC9zdmc+YDsgKi9cblxuXHRcdC8vL2NvbnNvbGUubG9nKHN2Zyk7XG5cblx0XHR2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0XHRlLnNldEF0dHJpYnV0ZSgnaHJlZicsICdkYXRhOnRleHQvcGxhaW47Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KHN2ZykpO1xuXHRcdGUuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsICdhbm5vdGF0aW9ucy5zdmcnKTtcblx0XHRlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTtcblx0XHRlLmNsaWNrKCk7XG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHNldEFjdGl2ZVRvb2woZSkge1xuXHRcdGlmICghdGhpcy5lZGl0V2lkZ2V0KSByZXR1cm47XG5cdFx0bGV0IHRvb2xzID0gdGhpcy5lZGl0V2lkZ2V0LnF1ZXJ5U2VsZWN0b3IoJy5vcGVubGltZS1hbm5vdGF0aW9uLWVkaXQtdG9vbHMnKTtcblx0XHR0b29scy5xdWVyeVNlbGVjdG9yQWxsKCdzdmcnKS5mb3JFYWNoKGEgPT5cblx0XHRcdGEuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJykpO1xuXHRcdGlmIChlKVxuXHRcdFx0ZS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHNldFRvb2wodG9vbCkge1xuXHRcdHRoaXMudG9vbCA9IHRvb2w7XG5cdFx0aWYgKHRoaXMuZmFjdG9yeSAmJiB0aGlzLmZhY3RvcnkucXVpdClcblx0XHRcdHRoaXMuZmFjdG9yeS5xdWl0KCk7XG5cdFx0aWYgKHRvb2wpIHtcblx0XHRcdGlmICghdG9vbCBpbiB0aGlzLnRvb2xzKVxuXHRcdFx0XHR0aHJvdyBcIlVua25vd24gZWRpdG9yIHRvb2w6IFwiICsgdG9vbDtcblxuXHRcdFx0dGhpcy5mYWN0b3J5ID0gbmV3IHRoaXMudG9vbHNbdG9vbF0udG9vbCh0aGlzLnRvb2xzW3Rvb2xdKTtcblx0XHRcdHRoaXMuZmFjdG9yeS5hbm5vdGF0aW9uID0gdGhpcy5hbm5vdGF0aW9uO1xuXHRcdFx0dGhpcy5mYWN0b3J5LmxheWVyID0gdGhpcy5sYXllcjtcblx0XHR9XG5cdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLW92ZXJsYXknKS5jbGFzc0xpc3QudG9nZ2xlKCdlcmFzZScsIHRvb2wgPT0gJ2VyYXNlJyk7XG5cdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLW92ZXJsYXknKS5jbGFzc0xpc3QudG9nZ2xlKCdjcm9zc2hhaXInLCB0b29sICYmIHRvb2wgIT0gJ2VyYXNlJyk7XG5cdH1cblxuXG5cdC8vIFVORE8gU1RVRkZcdFxuXG5cdC8qKiBAaWdub3JlICovXG5cdHVuZG8oKSB7XG5cdFx0bGV0IGFubm8gPSB0aGlzLmFubm90YXRpb247IC8vY3VycmVudCBhbm5vdGF0aW9uLlxuXHRcdGlmICghYW5ubylcblx0XHRcdHJldHVybjtcblx0XHRpZiAodGhpcy5mYWN0b3J5ICYmIHRoaXMuZmFjdG9yeS51bmRvICYmIHRoaXMuZmFjdG9yeS51bmRvKCkpIHtcblx0XHRcdGFubm8ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy52aWV3ZXIucmVkcmF3KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGFubm8uaGlzdG9yeSAmJiBhbm5vLmhpc3RvcnkubGVuZ3RoKSB7XG5cdFx0XHQvL0ZJWE1FIFRPRE8gaGlzdG9yeSB3aWxsIGJlIG1vcmUgY29tcGxpY2F0ZWQgaWYgaXQgaGFzIHRvIG1hbmFnZSBtdWx0aXBsZSB0b29scy5cblx0XHRcdGFubm8uZnV0dXJlLnB1c2godGhpcy5hbm5vVG9EYXRhKGFubm8pKTtcblxuXHRcdFx0bGV0IGRhdGEgPSBhbm5vLmhpc3RvcnkucG9wKCk7XG5cdFx0XHR0aGlzLmRhdGFUb0Fubm8oZGF0YSwgYW5ubyk7XG5cblx0XHRcdGFubm8ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy52aWV3ZXIucmVkcmF3KCk7XG5cdFx0XHR0aGlzLnVwZGF0ZUVkaXRXaWRnZXQoKTtcblx0XHR9XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRyZWRvKCkge1xuXHRcdGxldCBhbm5vID0gdGhpcy5hbm5vdGF0aW9uOyAvL2N1cnJlbnQgYW5ub3RhdGlvbi5cblx0XHRpZiAoIWFubm8pXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKHRoaXMuZmFjdG9yeSAmJiB0aGlzLmZhY3RvcnkucmVkbyAmJiB0aGlzLmZhY3RvcnkucmVkbygpKSB7XG5cdFx0XHRhbm5vLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMudmlld2VyLnJlZHJhdygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoYW5uby5mdXR1cmUgJiYgYW5uby5mdXR1cmUubGVuZ3RoKSB7XG5cdFx0XHRhbm5vLmhpc3RvcnkucHVzaCh0aGlzLmFubm9Ub0RhdGEoYW5ubykpO1xuXG5cdFx0XHRsZXQgZGF0YSA9IGFubm8uZnV0dXJlLnBvcCgpO1xuXHRcdFx0dGhpcy5kYXRhVG9Bbm5vKGRhdGEsIGFubm8pO1xuXG5cdFx0XHRhbm5vLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMudmlld2VyLnJlZHJhdygpO1xuXHRcdFx0dGhpcy51cGRhdGVFZGl0V2lkZ2V0KCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0c2F2ZUN1cnJlbnQoKSB7XG5cdFx0bGV0IGFubm8gPSB0aGlzLmFubm90YXRpb247IC8vY3VycmVudCBhbm5vdGF0aW9uLlxuXHRcdGlmICghYW5uby5oaXN0b3J5KVxuXHRcdFx0YW5uby5oaXN0b3J5ID0gW107XG5cblx0XHRhbm5vLmhpc3RvcnkucHVzaCh0aGlzLmFubm9Ub0RhdGEoYW5ubykpO1xuXHRcdGFubm8uZnV0dXJlID0gW107XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRhbm5vVG9EYXRhKGFubm8pIHtcblx0XHRsZXQgZGF0YSA9IHt9O1xuXHRcdGZvciAobGV0IGkgb2YgWydpZCcsICdsYWJlbCcsICdkZXNjcmlwdGlvbicsICdjbGFzcycsICdwdWJsaXNoJywgJ2RhdGEnXSlcblx0XHRcdGRhdGFbaV0gPSBgJHthbm5vW2ldIHx8ICcnfWA7XG5cdFx0ZGF0YS5lbGVtZW50cyA9IGFubm8uZWxlbWVudHMubWFwKGUgPT4geyBsZXQgbiA9IGUuY2xvbmVOb2RlKCk7IG4ucG9pbnRzID0gZS5wb2ludHM7IHJldHVybiBuOyB9KTtcblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGRhdGFUb0Fubm8oZGF0YSwgYW5ubykge1xuXHRcdGZvciAobGV0IGkgb2YgWydpZCcsICdsYWJlbCcsICdkZXNjcmlwdGlvbicsICdjbGFzcycsICdwdWJsaXNoJywgJ2RhdGEnXSlcblx0XHRcdGFubm9baV0gPSBgJHtkYXRhW2ldfWA7XG5cdFx0YW5uby5lbGVtZW50cyA9IGRhdGEuZWxlbWVudHMubWFwKGUgPT4geyBsZXQgbiA9IGUuY2xvbmVOb2RlKCk7IG4ucG9pbnRzID0gZS5wb2ludHM7IHJldHVybiBuOyB9KTtcblx0fVxuXG5cblx0Ly8gVE9PTFMgU1RVRkZcblxuXHQvKiogQGlnbm9yZSAqL1xuXHRrZXlVcChlKSB7XG5cdFx0aWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXHRcdHN3aXRjaCAoZS5rZXkpIHtcblx0XHRcdGNhc2UgJ0VzY2FwZSc6XG5cdFx0XHRcdGlmICh0aGlzLnRvb2wpIHtcblx0XHRcdFx0XHR0aGlzLnNldEFjdGl2ZVRvb2woKTtcblx0XHRcdFx0XHR0aGlzLnNldFRvb2wobnVsbCk7XG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnRGVsZXRlJzpcblx0XHRcdFx0dGhpcy5kZWxldGVTZWxlY3RlZCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0JhY2tzcGFjZSc6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdGlmIChlLmN0cmxLZXkpXG5cdFx0XHRcdFx0dGhpcy51bmRvKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWic6XG5cdFx0XHRcdGlmIChlLmN0cmxLZXkpXG5cdFx0XHRcdFx0dGhpcy5yZWRvKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHBhblN0YXJ0KGUpIHtcblx0XHRpZiAoZS5idXR0b25zICE9IDEgfHwgZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmICghWydsaW5lJywgJ2VyYXNlJywgJ2JveCcsICdjaXJjbGUnXS5pbmNsdWRlcyh0aGlzLnRvb2wpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMucGFubmluZyA9IHRydWU7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dGhpcy5zYXZlQ3VycmVudCgpO1xuXG5cdFx0Y29uc3QgcG9zID0gdGhpcy5tYXBUb1N2ZyhlKTtcblx0XHRsZXQgc2hhcGUgPSB0aGlzLmZhY3RvcnkuY3JlYXRlKHBvcywgZSk7XG5cblx0XHR0aGlzLmFubm90YXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy52aWV3ZXIucmVkcmF3KCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRwYW5Nb3ZlKGUpIHtcblx0XHRpZiAoIXRoaXMucGFubmluZylcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdGNvbnN0IHBvcyA9IHRoaXMubWFwVG9TdmcoZSk7XG5cdFx0dGhpcy5mYWN0b3J5LmFkanVzdChwb3MsIGUpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cGFuRW5kKGUpIHtcblx0XHRpZiAoIXRoaXMucGFubmluZylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR0aGlzLnBhbm5pbmcgPSBmYWxzZTtcblxuXHRcdGNvbnN0IHBvcyA9IHRoaXMubWFwVG9TdmcoZSk7XG5cdFx0bGV0IGNoYW5nZWQgPSB0aGlzLmZhY3RvcnkuZmluaXNoKHBvcywgZSk7XG5cdFx0aWYgKCFjaGFuZ2VkKSAvL25vdGhpbmcgY2hhbmdlZCBubyBuZWVkIHRvIGtlZXAgY3VycmVudCBzaXR1YXRpb24gaW4gaGlzdG9yeS5cblx0XHRcdHRoaXMuYW5ub3RhdGlvbi5oaXN0b3J5LnBvcCgpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc2F2ZUFubm90YXRpb24oKTtcblx0XHR0aGlzLmFubm90YXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMudmlld2VyLnJlZHJhdygpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0ZmluZ2VySG92ZXIoZSkge1xuXHRcdGlmICh0aGlzLnRvb2wgIT0gJ2xpbmUnKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRjb25zdCBwb3MgPSB0aGlzLm1hcFRvU3ZnKGUpO1xuXHRcdGxldCBjaGFuZ2VkID0gdGhpcy5mYWN0b3J5LmhvdmVyKHBvcywgZSk7XG5cdFx0dGhpcy5hbm5vdGF0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLnZpZXdlci5yZWRyYXcoKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGZpbmdlclNpbmdsZVRhcChlKSB7XG5cdFx0aWYgKCFbJ3BvaW50JywgJ3BpbicsICdsaW5lJywgJ2VyYXNlJ10uaW5jbHVkZXModGhpcy50b29sKSlcblx0XHRcdHJldHVybjtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLnNhdmVDdXJyZW50KCk7XG5cblx0XHRjb25zdCBwb3MgPSB0aGlzLm1hcFRvU3ZnKGUpO1xuXHRcdGxldCBjaGFuZ2VkID0gdGhpcy5mYWN0b3J5LnRhcChwb3MsIGUpXG5cdFx0aWYgKCFjaGFuZ2VkKSAvL25vdGhpbmcgY2hhbmdlZCBubyBuZWVkIHRvIGtlZXAgY3VycmVudCBzaXR1YXRpb24gaW4gaGlzdG9yeS5cblx0XHRcdHRoaXMuYW5ub3RhdGlvbi5oaXN0b3J5LnBvcCgpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc2F2ZUFubm90YXRpb24oKTtcblx0XHR0aGlzLmFubm90YXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy52aWV3ZXIucmVkcmF3KCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRmaW5nZXJEb3VibGVUYXAoZSkge1xuXHRcdGlmICghWydsaW5lJ10uaW5jbHVkZXModGhpcy50b29sKSlcblx0XHRcdHJldHVybjtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLnNhdmVDdXJyZW50KCk7XG5cblx0XHRjb25zdCBwb3MgPSB0aGlzLm1hcFRvU3ZnKGUpO1xuXHRcdGxldCBjaGFuZ2VkID0gdGhpcy5mYWN0b3J5LmRvdWJsZVRhcChwb3MsIGUpXG5cdFx0aWYgKCFjaGFuZ2VkKSAvL25vdGhpbmcgY2hhbmdlZCBubyBuZWVkIHRvIGtlZXAgY3VycmVudCBzaXR1YXRpb24gaW4gaGlzdG9yeS5cblx0XHRcdHRoaXMuYW5ub3RhdGlvbi5oaXN0b3J5LnBvcCgpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc2F2ZUFubm90YXRpb24oKTtcblx0XHR0aGlzLmFubm90YXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy52aWV3ZXIucmVkcmF3KCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRtYXBUb1N2ZyhlKSB7XG5cdFx0Y29uc3QgcCA9IHt4OmUub2Zmc2V0WCwgeTogZS5vZmZzZXRZfTtcblx0XHRjb25zdCBsYXllclQgPSB0aGlzLmxheWVyLnRyYW5zZm9ybTtcblx0XHRjb25zdCB1c2VHTCA9IGZhbHNlO1xuXHRcdGNvbnNvbGUubG9nKGxheWVyVCk7XG5cdFx0Y29uc3QgbGF5ZXJiYiA9IHRoaXMubGF5ZXIuYm91bmRpbmdCb3goKTtcblx0XHRjb25zdCBsYXllclNpemUgPSB7dzpsYXllcmJiLndpZHRoKCksIGg6bGF5ZXJiYi5oZWlnaHQoKX07XG5cdFx0bGV0IHBvcyA9IENvb3JkaW5hdGVTeXN0ZW0uZnJvbUNhbnZhc0h0bWxUb0ltYWdlKHAsIHRoaXMudmlld2VyLmNhbWVyYSwgbGF5ZXJULCBsYXllclNpemUsIHVzZUdMKTtcblx0XHRcblx0XHRyZXR1cm4gcG9zO1xuXHR9XG59XG5cblxuLyoqIEBpZ25vcmUgKi9cbmNsYXNzIFBvaW50IHtcblx0dGFwKHBvcykge1xuXHRcdGxldCBwb2ludCA9IFV0aWwuY3JlYXRlU1ZHRWxlbWVudCgnY2lyY2xlJywgeyBjeDogcG9zLngsIGN5OiBwb3MueSwgcjogMTAsIGNsYXNzOiAncG9pbnQnIH0pO1xuXHRcdHRoaXMuYW5ub3RhdGlvbi5lbGVtZW50cy5wdXNoKHBvaW50KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufVxuXG4vKiogQGlnbm9yZSAqL1xuY2xhc3MgUGluIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cdH1cblx0dGFwKHBvcykge1xuXHRcdGNvbnN0IHN0ciA9IHRoaXMudGVtcGxhdGUocG9zLngscG9zLnkpO1xuXHRcdGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdCAgICBsZXQgcG9pbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0ciwgXCJpbWFnZS9zdmcreG1sXCIpLmRvY3VtZW50RWxlbWVudDtcbi8vXHRcdHRoaXMuYW5ub3RhdGlvbi5lbGVtZW50cy5wdXNoKHBvaW50KTtcblx0XHR0aGlzLmFubm90YXRpb24uZWxlbWVudHNbMF0gPSBwb2ludDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufVxuXG4vKiogQGlnbm9yZSAqL1xuY2xhc3MgUGVuIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Ly9UT0RPIFVzZSB0aGlzLnBhdGgucG9pbnRzIGFzIGluIGxpbmUsIGluc3RlYWQuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblx0fVxuXHRjcmVhdGUocG9zKSB7XG5cdFx0dGhpcy5wb2ludHMucHVzaChwb3MpO1xuXHRcdGlmICh0aGlzLnBvaW50cy5sZW5ndGggPT0gMSkge1xuXHRcdFx0c2F2ZUN1cnJlbnRcblxuXHRcdFx0dGhpcy5wYXRoID0gVXRpbC5jcmVhdGVTVkdFbGVtZW50KCdwYXRoJywgeyBkOiBgTSR7cG9zLnh9ICR7cG9zLnl9YCwgY2xhc3M6ICdsaW5lJyB9KTtcblx0XHRcdHJldHVybiB0aGlzLnBhdGg7XG5cdFx0fVxuXHRcdGxldCBwID0gdGhpcy5wYXRoLmdldEF0dHJpYnV0ZSgnZCcpO1xuXHRcdHRoaXMucGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwICsgYCBMJHtwb3MueH0gJHtwb3MueX1gKTtcblx0XHR0aGlzLnBhdGgucG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdH1cblx0dW5kbygpIHtcblx0XHRpZiAoIXRoaXMucG9pbnRzLmxlbmd0aClcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLnBvaW50cy5wb3AoKTtcblx0XHRsZXQgZCA9IHRoaXMucG9pbnRzLm1hcCgocCwgaSkgPT4gYCR7aSA9PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gKS5qb2luKCcgJyk7XG5cdFx0dGhpcy5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIGQpO1xuXG5cdFx0aWYgKHRoaXMucG9pbnRzLmxlbmd0aCA8IDIpIHtcblx0XHRcdHRoaXMucG9pbnRzID0gW107XG5cdFx0XHR0aGlzLmFubm90YXRpb24uZWxlbWVudHMgPSB0aGlzLmFubm90YXRpb24uZWxlbWVudHMuZmlsdGVyKChlKSA9PiBlICE9IHRoaXMucGF0aCk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKiBAaWdub3JlICovXG5jbGFzcyBCb3gge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLm9yaWdpbiA9IG51bGw7XG5cdFx0dGhpcy5ib3ggPSBudWxsO1xuXHR9XG5cblx0Y3JlYXRlKHBvcykge1xuXHRcdHRoaXMub3JpZ2luID0gcG9zO1xuXHRcdHRoaXMuYm94ID0gVXRpbC5jcmVhdGVTVkdFbGVtZW50KCdyZWN0JywgeyB4OiBwb3MueCwgeTogcG9zLnksIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGNsYXNzOiAncmVjdCcgfSk7XG5cdFx0cmV0dXJuIHRoaXMuYm94O1xuXHR9XG5cblx0YWRqdXN0KHBvcykge1xuXHRcdGxldCBwID0gdGhpcy5vcmlnaW47XG5cblx0XHR0aGlzLmJveC5zZXRBdHRyaWJ1dGUoJ3gnLCBNYXRoLm1pbihwLngsIHBvcy54KSk7XG5cdFx0dGhpcy5ib3guc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGguYWJzKHBvcy54IC0gcC54KSk7XG5cdFx0dGhpcy5ib3guc2V0QXR0cmlidXRlKCd5JywgTWF0aC5taW4ocC55LCBwb3MueSkpO1xuXHRcdHRoaXMuYm94LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgTWF0aC5hYnMocG9zLnkgLSBwLnkpKTtcblx0fVxuXG5cdGZpbmlzaChwb3MpIHtcblx0XHRyZXR1cm4gdGhpcy5ib3g7XG5cdH1cbn1cblxuLyoqIEBpZ25vcmUgKi9cbmNsYXNzIENpcmNsZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMub3JpZ2luID0gbnVsbDtcblx0XHR0aGlzLmNpcmNsZSA9IG51bGw7XG5cdH1cblx0Y3JlYXRlKHBvcykge1xuXHRcdHRoaXMub3JpZ2luID0gcG9zO1xuXHRcdHRoaXMuY2lyY2xlID0gVXRpbC5jcmVhdGVTVkdFbGVtZW50KCdjaXJjbGUnLCB7IGN4OiBwb3MueCwgY3k6IHBvcy55LCByOiAwLCBjbGFzczogJ2NpcmNsZScgfSk7XG5cdFx0cmV0dXJuIHRoaXMuY2lyY2xlO1xuXHR9XG5cdGFkanVzdChwb3MpIHtcblx0XHRsZXQgcCA9IHRoaXMub3JpZ2luO1xuXHRcdGxldCByID0gTWF0aC5oeXBvdChwb3MueCAtIHAueCwgcG9zLnkgLSBwLnkpO1xuXHRcdHRoaXMuY2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIHIpO1xuXHR9XG5cdGZpbmlzaCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jaXJjbGU7XG5cdH1cbn1cblxuLyoqIEBpZ25vcmUgKi9cbmNsYXNzIExpbmUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmhpc3RvcnkgPSBbXVxuXHR9XG5cdGNyZWF0ZShwb3MpIHtcblx0XHQvKmlmKHRoaXMuc2VnbWVudCkge1xuXHRcdFx0dGhpcy5sYXllci5zdmdHcm91cC5yZW1vdmVDaGlsZCh0aGlzLnNlZ21lbnQpO1xuXHRcdFx0dGhpcy5zZWdtZW50ID0gbnVsbDtcblx0XHR9Ki9cblx0XHRmb3IgKGxldCBlIG9mIHRoaXMuYW5ub3RhdGlvbi5lbGVtZW50cykge1xuXHRcdFx0aWYgKCFlLnBvaW50cyB8fCBlLnBvaW50cy5sZW5ndGggPCAyKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGlmIChMaW5lLmRpc3RhbmNlKGUucG9pbnRzWzBdLCBwb3MpICogcG9zLnogPCA1KSB7XG5cdFx0XHRcdGUucG9pbnRzLnJldmVyc2UoKTtcblx0XHRcdFx0dGhpcy5wYXRoID0gZTtcblx0XHRcdFx0dGhpcy5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIExpbmUuc3ZnUGF0aChlLnBvaW50cykpO1xuXHRcdFx0XHQvL3JldmVyc2UgcG9pbnRzIVxuXHRcdFx0XHR0aGlzLmhpc3RvcnkgPSBbdGhpcy5wYXRoLnBvaW50cy5sZW5ndGhdO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoTGluZS5kaXN0YW5jZVRvTGFzdChlLnBvaW50cywgcG9zKSA8IDUpIHtcblx0XHRcdFx0dGhpcy5wYXRoID0gZTtcblx0XHRcdFx0dGhpcy5hZGp1c3QocG9zKTtcblx0XHRcdFx0dGhpcy5oaXN0b3J5ID0gW3RoaXMucGF0aC5wb2ludHMubGVuZ3RoXTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnBhdGggPSBVdGlsLmNyZWF0ZVNWR0VsZW1lbnQoJ3BhdGgnLCB7IGQ6IGBNJHtwb3MueH0gJHtwb3MueX1gLCBjbGFzczogJ2xpbmUnIH0pO1xuXHRcdHRoaXMucGF0aC5wb2ludHMgPSBbcG9zXTtcblx0XHR0aGlzLmhpc3RvcnkgPSBbdGhpcy5wYXRoLnBvaW50cy5sZW5ndGhdO1xuXHRcdHRoaXMuYW5ub3RhdGlvbi5lbGVtZW50cy5wdXNoKHRoaXMucGF0aCk7XG5cdH1cblxuXHR0YXAocG9zKSB7XG5cdFx0aWYgKCF0aGlzLnBhdGgpIHtcblx0XHRcdHRoaXMuY3JlYXRlKHBvcyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLmFkanVzdChwb3MpKVxuXHRcdFx0XHR0aGlzLmhpc3RvcnkgPSBbdGhpcy5wYXRoLnBvaW50cy5sZW5ndGggLSAxXTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRkb3VibGVUYXAocG9zKSB7XG5cdFx0aWYgKCF0aGlzLnBhdGgpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHRoaXMuYWRqdXN0KHBvcykpIHtcblx0XHRcdHRoaXMuaGlzdG9yeSA9IFt0aGlzLnBhdGgucG9pbnRzLmxlbmd0aCAtIDFdO1xuXHRcdFx0dGhpcy5wYXRoID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aG92ZXIocG9zLCBldmVudCkge1xuXHRcdHJldHVybjtcblx0XHRpZiAoIXRoaXMucGF0aClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRsZXQgcyA9IHRoaXMucGF0aC5wb2ludHNbdGhpcy5wYXRoLnBvaW50cy5sZW5ndGggLSAxXTtcblx0XHRpZiAoIXRoaXMuc2VnbWVudCkge1xuXHRcdFx0dGhpcy5zZWdtZW50ID0gVXRpbC5jcmVhdGVTVkdFbGVtZW50KCdwYXRoJywgeyBjbGFzczogJ2xpbmUnIH0pO1xuXHRcdFx0dGhpcy5sYXllci5zdmdHcm91cC5hcHBlbmRDaGlsZCh0aGlzLnNlZ21lbnQpO1xuXHRcdH1cblx0XHRwb3MueCA9IHBvcy54IC0gcy54O1xuXHRcdHBvcy55ID0gcG9zLnkgLSBzLnk7XG5cdFx0bGV0IGxlbiA9IE1hdGguc3FydChwb3MueCAqIHBvcy54ICsgcG9zLnkgKiBwb3MueSk7XG5cdFx0aWYgKGxlbiA+IDMwKSB7XG5cdFx0XHRwb3MueCAqPSAzMCAvIGxlbjtcblx0XHRcdHBvcy55ICo9IDMwIC8gbGVuO1xuXHRcdH1cblx0XHR0aGlzLnNlZ21lbnQuc2V0QXR0cmlidXRlKCdkJywgYE0ke3MueH0gJHtzLnl9IGwke3Bvcy54fSAke3Bvcy55fWApO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHF1aXQoKSB7XG5cdFx0cmV0dXJuO1xuXHRcdGlmICh0aGlzLnNlZ21lbnQpIHtcblx0XHRcdHRoaXMubGF5ZXIuc3ZnR3JvdXAucmVtb3ZlQ2hpbGQodGhpcy5zZWdtZW50KTtcblx0XHRcdHRoaXMuc2VnbWVudCA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0YWRqdXN0KHBvcykge1xuXHRcdGxldCBnYXAgPSBMaW5lLmRpc3RhbmNlVG9MYXN0KHRoaXMucGF0aC5wb2ludHMsIHBvcyk7XG5cdFx0aWYgKGdhcCAqIHBvcy56IDwgNCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dGhpcy5wYXRoLnBvaW50cy5wdXNoKHBvcyk7XG5cblx0XHRsZXQgZCA9IHRoaXMucGF0aC5nZXRBdHRyaWJ1dGUoJ2QnKTtcblx0XHR0aGlzLnBhdGguc2V0QXR0cmlidXRlKCdkJywgTGluZS5zdmdQYXRoKHRoaXMucGF0aC5wb2ludHMpKTsvL2QgKyBgTCR7cG9zLnh9ICR7cG9zLnl9YCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmaW5pc2goKSB7XG5cdFx0dGhpcy5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIExpbmUuc3ZnUGF0aCh0aGlzLnBhdGgucG9pbnRzKSk7XG5cdFx0cmV0dXJuIHRydWU7IC8vc29tZSBjaGFuZ2VzIHdoZXJlIG1hZGUhXG5cdH1cblxuXHR1bmRvKCkge1xuXHRcdGlmICghdGhpcy5wYXRoIHx8ICF0aGlzLmhpc3RvcnkubGVuZ3RoKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHRoaXMucGF0aC5wb2ludHMgPSB0aGlzLnBhdGgucG9pbnRzLnNsaWNlKDAsIHRoaXMuaGlzdG9yeS5wb3AoKSk7XG5cdFx0dGhpcy5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIExpbmUuc3ZnUGF0aCh0aGlzLnBhdGgucG9pbnRzKSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmVkbygpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Ly9UT0RPOiBzbW9vdGggc2hvdWxkIGJlIFNUQUJMRSwgaWYgcG9zc2libGUuXG5cdHN0YXRpYyBzdmdQYXRoKHBvaW50cykge1xuXHRcdC8vcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+ICBgJHsoaSA9PSAwPyBcIk1cIiA6IFwiTFwiKX0ke3AueH0gJHtwLnl9YCkuam9pbignICcpOyBcblxuXHRcdGxldCB0b2xlcmFuY2UgPSAxLjUgLyBwb2ludHNbMF0uejtcblx0XHRsZXQgdG1wID0gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpO1xuXG5cdFx0bGV0IHNtb290aGVkID0gc21vb3RoKHRtcCwgOTAsIHRydWUpO1xuXHRcdHJldHVybiBzbW9vdGhUb1BhdGgoc21vb3RoZWQpO1xuXHRcdFxuXHR9XG5cdHN0YXRpYyBkaXN0YW5jZVRvTGFzdChsaW5lLCBwb2ludCkge1xuXHRcdGxldCBsYXN0ID0gbGluZVtsaW5lLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiBMaW5lLmRpc3RhbmNlKGxhc3QsIHBvaW50KTtcblx0fVxuXHRzdGF0aWMgZGlzdGFuY2UoYSwgYikge1xuXHRcdGxldCBkeCA9IGEueCAtIGIueDtcblx0XHRsZXQgZHkgPSBhLnkgLSBiLnk7XG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdH1cbn1cblxuLyoqIEBpZ25vcmUgKi9cbmNsYXNzIEVyYXNlIHtcblx0Y3JlYXRlKHBvcywgZXZlbnQpIHsgdGhpcy5lcmFzZWQgPSBmYWxzZTsgdGhpcy5lcmFzZShwb3MsIGV2ZW50KTsgfVxuXHRhZGp1c3QocG9zLCBldmVudCkgeyB0aGlzLmVyYXNlKHBvcywgZXZlbnQpOyB9XG5cdGZpbmlzaChwb3MsIGV2ZW50KSB7IHJldHVybiB0aGlzLmVyYXNlKHBvcywgZXZlbnQpOyB9IC8vdHJ1ZSBpZiBzb21lIHBvaW50cyB3aGVyZSByZW1vdmVkLlxuXHR0YXAocG9zLCBldmVudCkgeyByZXR1cm4gdGhpcy5lcmFzZShwb3MsIGV2ZW50KTsgfVxuXHRlcmFzZShwb3MsIGV2ZW50KSB7XG5cdFx0Zm9yIChsZXQgZSBvZiB0aGlzLmFubm90YXRpb24uZWxlbWVudHMpIHtcblx0XHRcdGlmIChlID09IGV2ZW50Lm9yaWdpblNyYykge1xuXHRcdFx0XHRlLnBvaW50cyA9IFtdO1xuXHRcdFx0XHR0aGlzLmVyYXNlZCA9IHRydWU7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcG9pbnRzID0gZS5wb2ludHM7XG5cdFx0XHRpZiAoIXBvaW50cyB8fCAhcG9pbnRzLmxlbmd0aClcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdGlmIChMaW5lLmRpc3RhbmNlVG9MYXN0KHBvaW50cywgcG9zKSA8IDEwKVxuXHRcdFx0XHR0aGlzLmVyYXNlZCA9IHRydWUsIHBvaW50cy5wb3AoKTtcblx0XHRcdGVsc2UgaWYgKExpbmUuZGlzdGFuY2UocG9pbnRzWzBdLCBwb3MpIDwgMTApXG5cdFx0XHRcdHRoaXMuZXJhc2VkID0gdHJ1ZSwgcG9pbnRzLnNoaWZ0KCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSB7XG5cdFx0XHRcdGUucG9pbnRzID0gW107XG5cdFx0XHRcdGUuc2V0QXR0cmlidXRlKCdkJywgJycpO1xuXHRcdFx0XHR0aGlzLmFubm90YXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmVyYXNlZCA9IHRydWU7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRlLnNldEF0dHJpYnV0ZSgnZCcsIExpbmUuc3ZnUGF0aChwb2ludHMpKTtcblx0XHR9XG5cdFx0dGhpcy5hbm5vdGF0aW9uLmVsZW1lbnRzID0gdGhpcy5hbm5vdGF0aW9uLmVsZW1lbnRzLmZpbHRlcihlID0+IHsgcmV0dXJuICFlLnBvaW50cyB8fCBlLnBvaW50cy5sZW5ndGggPiAyOyB9KTtcblx0XHRyZXR1cm4gdGhpcy5lcmFzZWQ7XG5cdH1cbn1cblxuZXhwb3J0IHsgRWRpdG9yU3ZnQW5ub3RhdGlvbiB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/EditorSvgAnnotation.js\n");

/***/ }),

/***/ "./src/Layer.js":
/*!**********************!*\
  !*** ./src/Layer.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Layer\": () => (/* binding */ Layer)\n/* harmony export */ });\n/* harmony import */ var _Transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform.js */ \"./src/Transform.js\");\n/* harmony import */ var _Layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layout.js */ \"./src/Layout.js\");\n/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cache.js */ \"./src/Cache.js\");\n/* harmony import */ var _BoundingBox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BoundingBox.js */ \"./src/BoundingBox.js\");\n/* harmony import */ var _Signals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signals.js */ \"./src/Signals.js\");\n\n\n\n\n\n\n\n/**\n * The Layer class is responsible for drawing slides in the OpenLIME viewer. \n * Layers can directly draw their contents on the viewer or be combined with each other to obtain more complex visualizations.\n * OpenLIME provides a set of ready-to-use layers that allows developers to quickly publish their datasets on the web\n * or make kiosk applications. Ready-to-use layers ranging from images, to multi-channel data (such as, for example, RTI or BRDF)\n * or the combination of multiple layers or for visualization through lenses.\n * \n * A Layer takes raster data (images) as input which are managed by the layout. A layer stores all the information\n * and functions needed to render the graphics (shaders, shader parameters, data structures, etc.), and takes care\n * of data prefetching and communication with the cache.\n * \n * The Layer is a kind of primitive class from which other Layer classes can inherit.\n * Each derived class \"registers\" on the Layer base class, the user can then use an instance of \n * Layer by indicating the chosen `type` in the `options`.\n * \n * In the example below a Layer of type 'rti' is created, then a LayerRTI (class derived from Layer) is instantiated and added to the viewer's layer stack.\n * \n * @example\n *      const layer1 = new OpenLIME.Layer({\n *          layout: 'deepzoom',\n *          label: 'Ancient Roman coin',\n *          type: 'rti',\n *          url: '../../assets/rti/hsh/info.json',\n *          normals: false\n *      });\n *      viewer.addLayer('coin1', layer1);\n */\n\n//FIXME: prefetchborder and mipmapbias should probably go into layout\nclass Layer {\n\t/**\n\t* Creates a Layer. Additionally, an object literal with Layer `options` can be specified.\n\t* Signals are triggered when the layer is ready (i.e. completely initialized) or if its state variables have been updated (a redraw is needed).\n\t* @param {Object} [options]\n\t* @param {(string|Layout)} options.layout='image' The layout (the format of the input raster images).\n\t* @param {string} options.type A string identifier to select the specific derived layer class to instantiate.\n\t* @param {string} options.id The layer unique identifier.\n\t* @param {string} options.label A string with a more comprehensive definition of the layer. If it exists, it is used in the UI layer menu, otherwise the `id` value is taken.\n\t* @param {Transform} options.transform The relative coords from layer to canvas.\n\t* @param {bool} options.visible=true Whether to render the layer.\n\t* @param {number} options.zindex Stack ordering value for the rendering of layers (higher zindex on top).\n\t* @param {bool} options.overlay=false  Whether the layer must be rendered in overlay mode.\n\t* @param {number} options.prefetchBorder=1 The threshold (in tile units) around the current camera position for which to prefetch tiles.\n\t* @param {number} options.mipmapBias=0.4 The mipmap bias of the texture.\n\t* @param {Object} options.shaders A map (shadersId, shader) of the shaders usable for the layer rendering. See @link {Shader}.\n\t* @param {Controller[]} options.controllers An array of UI device controllers active on the layer.\n\t* @param {Layer} options.sourceLayer The layer from which to take the tiles (in order to avoid tile duplication).\n\t*/\n\tconstructor(options) {\n\t\t//create from derived class if type specified\n\t\tif (options.type) {\n\t\t\tlet type = options.type;\n\t\t\tdelete options.type;\n\t\t\tif (type in this.types) {\n\n\t\t\t\treturn this.types[type](options);\n\t\t\t}\n\t\t\tthrow \"Layer type: \" + type + \"  module has not been loaded\";\n\t\t}\n\n\t\tthis.init(options);\n\n\t\t/*\n\t\t//create members from options.\n\t\tthis.rasters = this.rasters.map((raster) => new Raster(raster));\n\n\t\t//layout needs to be the same for all rasters\n\t\tif(this.rasters.length) {\n\t\t\tif(typeof(this.layout) != 'object')\n\t\t\t\tthis.layout = new Layout(this.rasters[0].url, this.layout)\n\t\t\tthis.setLayout(this.layout)\n\n\t\t\tif(this.rasters.length)\n\t\t\t\tfor(let raster in this.rasters)\n\t\t\t\t\traster.layout = this.layout;\n\t\t}\n\n\t\tif(this.shader)\n\t\t\tthis.shader = new Shader(this.shader);\n\t\t*/\n\t}\n\n\t/** @ignore */\n\tinit(options) {\n\t\tObject.assign(this, {\n\t\t\ttransform: new _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform(),\n\t\t\tvisible: true,\n\t\t\tzindex: 0,\n\t\t\toverlay: false, //in the GUI it won't affect the visibility of the other layers\n\t\t\trasters: [],\n\t\t\tlayers: [],\n\t\t\tcontrols: {},\n\t\t\tcontrollers: [],\n\t\t\tshaders: {},\n\t\t\tlayout: 'image',\n\t\t\tshader: null, //current shader.\n\t\t\tgl: null,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tprefetchBorder: 1,\n\t\t\tmipmapBias: 0.4,\n\n\t\t\t//signals: { update: [], ready: [], updateSize: [] },  //update callbacks for a redraw, ready once layout is known.\n\n\t\t\t//internal stuff, should not be passed as options.\n\t\t\ttiles: new Map(),      //keep references to each texture (and status) indexed by level, x and y.\n\t\t\t//each tile is tex: [.. one for raster ..], missing: 3 missing tex before tile is ready.\n\t\t\t//only raster used by the shader will be loade.\n\t\t\tqueue: [],     //queue of tiles to be loaded.\n\t\t\trequested: {},  //tiles requested.\n\t\t});\n\n\t\tObject.assign(this, options);\n\t\tif (this.sourceLayer) this.tiles = this.sourceLayer.tiles; //FIXME avoid tiles duplication\n\n\t\tthis.transform = new _Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform(this.transform);\n\n\t\tif (typeof (this.layout) == 'string') {\n\t\t\tlet size = { width: this.width, height: this.height };\n\t\t\tthis.setLayout(new _Layout_js__WEBPACK_IMPORTED_MODULE_1__.Layout(null, this.layout, size)); //FIXME new Layout not have size, but options.width options.height\n\t\t} else {\n\t\t\tthis.setLayout(this.layout);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the state of the layer \n\t */\n\tsetState(state, dt, easing = 'linear') {\n\t\tif ('controls' in state)\n\t\t\tfor (const [key, v] of Object.entries(state.controls)) {\n\t\t\t\tthis.setControl(key, v, dt, easing);\n\t\t\t}\n\t\tif ('mode' in state && state.mode) {\n\t\t\tthis.setMode(state.mode);\n\t\t}\n\t}\n\n\t/**\n\t * Gets the state variables of the layer.\n\t * @return {Object} An object with state variables \n\t */\n\tgetState(stateMask = null) {\n\t\tconst state = {};\n\t\tstate.controls = {};\n\t\tfor (const [key, v] of Object.entries(this.controls)) {\n\t\t\tif (!stateMask || ('controls' in stateMask && key in stateMask.controls))\n\t\t\t\tstate.controls[key] = v.current.value;\n\t\t}\n\t\tif (!stateMask || 'mode' in stateMask)\n\t\t\tif (this.getMode())\n\t\t\t\tstate.mode = this.getMode();\n\t\treturn state;\n\t}\n\n\t/** @ignore */\n\tsetLayout(layout) {\n\t\t/**\n\t\t* The event is fired when a layer is initialized.\n\t\t* @event Layer#ready\n\t\t*/\n\t\t/**\n\t\t* The event is fired if a redraw is needed.\n\t\t* @event Layer#update\n\t\t*/\n\n\t\tlet callback = () => {\n\t\t\tthis.status = 'ready';\n\t\t\tthis.setupTiles(); //setup expect status to be ready!\n\t\t\tthis.emit('ready');\n\t\t\tthis.emit('update');\n\t\t};\n\t\tif (layout.status == 'ready') //layout already initialized.\n\t\t\tcallback();\n\t\telse\n\t\t\tlayout.addEvent('ready', callback);\n\t\tthis.layout = layout;\n\n\t\t// Set signal to acknowledge change of bbox when it is known. Let this signal go up to canvas\n\t\tthis.layout.addEvent('updateSize', () => { this.emit('updateSize'); });\n\t}\n\n\t// OK\n\tsetTransform(tx) { //FIXME\n\t\tthis.transform = tx;\n\t\tthis.emit('updateSize');\n\t}\n\n\t/**\n\t * Sets the shader to use\n\t * @param {*} id the current shader identifier (the shader must already be registered in the `shaders` array)\n\t */\n\tsetShader(id) {\n\t\tif (!id in this.shaders)\n\t\t\tthrow \"Unknown shader: \" + id;\n\t\tthis.shader = this.shaders[id];\n\t\tthis.setupTiles();\n\t\tthis.shader.addEvent('update', () => { this.emit('update'); });\n\t}\n\n\t/**\n\t * Gets the current shader mode.\n\t * @returns {string} the shader mode\n\t */\n\tgetMode() {\n\t\tif (this.shader)\n\t\t\treturn this.shader.mode;\n\t\treturn null;\n\t}\t\n\n\t/**\n\t * Gets an arrays of all the modes implemented in the current shader.\n\t * @returns {string[]} arrays of modes\n\t */\n\tgetModes() {\n\t\tif (this.shader)\n\t\t\treturn this.shader.modes;\n\t\treturn [];\n\t}\n\n\t/**\n\t * Set the mode of the current shader.\n\t * @param {string} mode the mode of the current shader.\n\t */\n\tsetMode(mode) {\n\t\tthis.shader.setMode(mode);\n\t\tthis.emit('update');\n\t}\n\n\t/**\n\t * Sets a value that indicates whether the layer is visible.\n\t * @param {bool} visible The value.\n\t */\n\tsetVisible(visible) {\n\t\tthis.visible = visible;\n\t\tthis.previouslyNeeded = null;\n\t\tthis.emit('update');\n\t}\n\n\t/**\n\t * Sets the layer zindex value (stack ordering value for the rendering of layers).\n\t * @param {int} zindex The value.\n\t */\n\tsetZindex(zindex) {\n\t\tthis.zindex = zindex;\n\t\tthis.emit('update');\n\t}\n\n\t/**\n\t * Computes the minum scale value of the `layers`.\n\t * @param {Layer[]} layers \n\t * @param {bool} discardHidden Whether hidden layers are not to be included in the computation.\n\t * @returns {number} the minimum scale.\n\t * @static\n\t */\n\tstatic computeLayersMinScale(layers, discardHidden) {\n\t\tif (layers == undefined || layers == null) {\n\t\t\tconsole.log(\"ASKING SCALE INFO ON NO LAYERS\");\n\t\t\treturn 1;\n\t\t}\n\t\tlet layersScale = 1;\n\t\tfor (let layer of Object.values(layers)) {\n\t\t\tif (!discardHidden || layer.visible) {\n\t\t\t\tlet s = layer.scale();\n\t\t\t\tlayersScale = Math.min(layersScale, s);\n\t\t\t}\n\t\t}\n\t\treturn layersScale;\n\t}\n\n\t/**\n\t * Gets the scale of the layer transformation\n\t * @returns {number} The scale\n\t */\n\tscale() {\n\t\t// FIXME: this do not consider children layers\n\t\treturn this.transform.z;\n\t}\n\n\t/**\n\t * Gets the layer bounding box (<FIXME> Change name: box is in scene coordinates)\n\t * @returns {BoundingBox} The bounding box \n\t */\n\tboundingBox() {\n\t\t// FIXME: this do not consider children layers\n\t\t// Take layout bbox\n\t\tlet result = this.layout.boundingBox();\n\n\t\t// Apply layer transform to bbox\n\t\tif (this.transform != null && this.transform != undefined) {\n\t\t\tresult = this.transform.transformBox(result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t  * Computes the merge bounding box of all the 'layers`\n\t  * @param {Layer[]} layers \n\t  * @param {bool} discardHidden Whether hidden layers are not to be included in the computation.\n\t  * @returns {BoundingBox} The bounding box \n\t* @static \n\t  */\n\tstatic computeLayersBBox(layers, discardHidden) {\n\t\tif (layers == undefined || layers == null) {\n\t\t\tconsole.log(\"ASKING BBOX INFO ON NO LAYERS\");\n\t\t\tlet emptyBox = new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_3__.BoundingBox();\n\t\t\treturn emptyBox;\n\t\t}\n\t\tlet layersBbox = new _BoundingBox_js__WEBPACK_IMPORTED_MODULE_3__.BoundingBox();\n\t\tfor (let layer of Object.values(layers)) {\n\t\t\tif ((!discardHidden || layer.visible) && layer.layout.width) {\n\t\t\t\tconst bbox = layer.boundingBox();\n\t\t\t\tlayersBbox.mergeBox(bbox);\n\t\t\t}\n\t\t}\n\t\treturn layersBbox;\n\t}\n\n\t/**\n\t * Gets the shader parameter control corresponding to `name`\n\t * @param {*} name The name of the control.\n\t * return {*} The control\n\t */\n\tgetControl(name) {\n\t\tlet control = this.controls[name] ? this.controls[name] : null;\n\t\tif (control) {\n\t\t\tlet now = performance.now();\n\t\t\tthis.interpolateControl(control, now);\n\t\t}\n\t\treturn control;\n\t}\n\n\t/**\n\t * Adds a new shader parameter control.\n\t * @param {string} name The name of the control.\n\t * @param {*} value The value for initialization.\n\t */\n\taddControl(name, value) {\n\t\tif (this.controls[name])\n\t\t\tthrow new Error(`Control \"$name\" already exist!`);\n\t\tlet now = performance.now();\n\t\tthis.controls[name] = { 'source': { 'value': value, 't': now }, 'target': { 'value': value, 't': now }, 'current': { 'value': value, 't': now }, 'easing': 'linear' };\n\t}\n\n\t/**\n\t * Set a shader parameter control with new value\n\t * @param {*} name The name of the control.\n\t * @param {*} value The value for initialization.\n\t * @param {time} dt Duration of the interpolation (0=no interpolation).\n\t */\n\tsetControl(name, value, dt, easing = 'linear') { //When are created?\n\t\tlet now = performance.now();\n\t\tlet control = this.controls[name];\n\t\tthis.interpolateControl(control, now);\n\n\t\tcontrol.source.value = [...control.current.value];\n\t\tcontrol.source.t = now;\n\n\t\tcontrol.target.value = [...value];\n\t\tcontrol.target.t = now + dt;\n\n\t\tcontrol.easing = easing;\n\n\t\tthis.emit('update');\n\t}\n\t/**\n\t * Update the current values of the parameter controls.\n\t * @returns {bool} Weather the interpolation is finished (the time has now gone).\n\t */\n\tinterpolateControls() {\n\t\tlet now = performance.now();\n\t\tlet done = true;\n\t\tfor (let control of Object.values(this.controls))\n\t\t\tdone = this.interpolateControl(control, now) && done;\n\t\treturn done;\n\t}\n\n\t/** @ignore */\n\tinterpolateControl(control, time) {\n\t\tlet source = control.source;\n\t\tlet target = control.target;\n\t\tlet current = control.current;\n\n\t\tcurrent.t = time;\n\t\tif (time < source.t) {\n\t\t\tcurrent.value = [...source.value];\n\t\t\treturn false;\n\t\t}\n\n\t\tif (time > target.t - 0.0001) {\n\t\t\tlet done = current.value.every((e, i) => e === target.value[i]);\n\t\t\tcurrent.value = [...target.value];\n\t\t\treturn done;\n\t\t}\n\n\t\tlet dt = (target.t - source.t);\n\t\tlet tt = (time - source.t) / dt;\n\t\tswitch (control.easing) {\n\t\t\tcase 'ease-out': tt = 1 - Math.pow(1 - tt, 2); break;\n\t\t\tcase 'ease-in-out': tt = tt < 0.5 ? 2 * tt * tt : 1 - Math.pow(-2 * tt + 2, 2) / 2; break;\n\t\t}\n\t\tlet st = 1 - tt;\n\n\t\tcurrent.value = [];\n\t\tfor (let i = 0; i < source.value.length; i++)\n\t\t\tcurrent.value[i] = (st * source.value[i] + tt * target.value[i]);\n\t\treturn false;\n\t}\n\n\t/////////////\n\t/// CACHE HANDLING & RENDERING\n\n\t/** @ignore */\n\tdropTile(tile) {\n\t\tfor (let i = 0; i < tile.tex.length; i++) {\n\t\t\tif (tile.tex[i]) {\n\t\t\t\tthis.gl.deleteTexture(tile.tex[i]);\n\t\t\t}\n\t\t}\n\t\tthis.tiles.delete(tile.index);\n\t}\n\n\t/** @ignore */\n\tclear() {\n\t\tthis.ibuffer = this.vbuffer = null;\n\t\t_Cache_js__WEBPACK_IMPORTED_MODULE_2__.Cache.flushLayer(this);\n\t\tthis.tiles = new Map(); //TODO We need to drop these tile textures before clearing Map\n\t\tthis.setupTiles();\n\t\tthis.queue = [];\n\t\tthis.previouslyNeeded = false;\n\t}\n\n\t/*\n\t * Renders the layer\n\t */\n\t/** @ignore */\n\tdraw(transform, viewport) {\n\t\t//exception for layout image where we still do not know the image size\n\t\t//how linear or srgb should be specified here.\n\t\t//\t\tgl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n\t\tif (this.status != 'ready')// || this.tiles.size == 0)\n\t\t\treturn true;\n\n\t\tif (!this.shader)\n\t\t\tthrow \"Shader not specified!\";\n\n\t\tlet done = this.interpolateControls();\n\t\tthis.prepareWebGL();\n\n\t\t//\t\tfind which quads to draw and in case request for them\n\t\tlet available = this.layout.available(viewport, transform, this.transform, 0, this.mipmapBias, this.tiles);\n\n\t\ttransform = this.transform.compose(transform);\n\t\tlet matrix = transform.projectionMatrix(viewport);\n\t\tthis.gl.uniformMatrix4fv(this.shader.matrixlocation, this.gl.FALSE, matrix);\n\n\t\tthis.updateAllTileBuffers(available);\n\n\t\tlet i = 0;\n\t\tfor (let tile of Object.values(available)) {\n\t\t\t//\t\t\tif(tile.complete)\n\t\t\tthis.drawTile(tile, i);\n\t\t\t++i;\n\t\t}\n\t\treturn done;\n\t}\n\t\n\t/** @ignore */\n\tdrawTile(tile, index) {\n\t\t//let tiledata = this.tiles.get(tile.index);\n\t\tif (tile.missing != 0)\n\t\t\tthrow \"Attempt to draw tile still missing textures\"\n\n\t\t//coords and texture buffers updated once for all tiles from main draw() call\n\n\t\t//bind textures\n\t\tlet gl = this.gl;\n\t\tfor (var i = 0; i < this.shader.samplers.length; i++) {\n\t\t\tlet id = this.shader.samplers[i].id;\n\t\t\tgl.uniform1i(this.shader.samplers[i].location, i);\n\t\t\tgl.activeTexture(gl.TEXTURE0 + i);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, tile.tex[id]);\n\t\t}\n        const byteOffset = this.getTileByteOffset(index);\n\t\tgl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, byteOffset);\n\t}\n\n\tgetTileByteOffset(index) {\n\t\treturn index * 6 * 2;\n\t}\n\n\t/* given the full pyramid of needed tiles for a certain bounding box, \n\t *  starts from the preferred levels and goes up in the hierarchy if a tile is missing.\n\t *  complete is true if all of the 'brothers' in the hierarchy are loaded,\n\t *  drawing incomplete tiles enhance the resolution early at the cost of some overdrawing and problems with opacity.\n\t */\n\t/** @ignore */\n\t/*toRender(needed) {\n\n\t\tlet torender = {}; //array of minlevel, actual level, x, y (referred to minlevel)\n\t\tlet brothers = {};\n\n\t\tlet minlevel = needed.level;\n\t\tlet box = needed.pyramid[minlevel];\n\n\t\tfor (let y = box.yLow; y < box.yHigh; y++) {\n\t\t\tfor (let x = box.xLow; x < box.xHigh; x++) {\n\t\t\t\tlet level = minlevel;\n\t\t\t\twhile (level >= 0) {\n\t\t\t\t\tlet d = minlevel - level;\n\t\t\t\t\tlet index = this.layout.index(level, x >> d, y >> d);\n\t\t\t\t\tif (this.tiles.has(index) && this.tiles.get(index).missing == 0) {\n\t\t\t\t\t\ttorender[index] = this.tiles.get(index); //{ index: index, level: level, x: x >> d, y: y >> d, complete: true };\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet sx = (x >> (d + 1)) << 1;\n\t\t\t\t\t\tlet sy = (y >> (d + 1)) << 1;\n\t\t\t\t\t\tbrothers[this.layout.index(level, sx, sy)] = 1;\n\t\t\t\t\t\tbrothers[this.layout.index(level, sx + 1, sy)] = 1;\n\t\t\t\t\t\tbrothers[this.layout.index(level, sx + 1, sy + 1)] = 1;\n\t\t\t\t\t\tbrothers[this.layout.index(level, sx, sy + 1)] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tlevel--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let index in brothers) {\n\t\t\tif (index in torender)\n\t\t\t\ttorender[index].complete = false;\n\t\t}\n\t\treturn torender;\n\t}*/\n\n\t/** @ignore */\n\t// Update tile vertex and texture coords.\n\t// Currently called by derived classes \n\tupdateTileBuffers(coords, tcoords) {\n\t\tlet gl = this.gl;\n\t\t//TODO to reduce the number of calls (probably not needed) we can join buffers, and just make one call per draw! (except the bufferData, which is per node)\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vbuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\n\t\t//FIXME this is not needed every time.\n\t\tgl.vertexAttribPointer(this.shader.coordattrib, 3, gl.FLOAT, false, 0, 0);\n\t\tgl.enableVertexAttribArray(this.shader.coordattrib);\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.tbuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);\n\n\t\tgl.vertexAttribPointer(this.shader.texattrib, 2, gl.FLOAT, false, 0, 0);\n\t\tgl.enableVertexAttribArray(this.shader.texattrib);\n\t}\n\n\t\n\t/** @ignore */\n\t// Update tile vertex and texture coords of all the tiles in a single VBO\n\tupdateAllTileBuffers(tiles) {\n\t\tlet gl = this.gl;\n\n\t\t//use this.tiles instead.\n\t\tlet N = Object.values(tiles).length;\n\t\tif (N == 0) return;\n\t\t\n\t\tconst szV = 12;\n\t\tconst szT = 8;\n\t\tconst szI = 6;\n\t\tconst iBuffer = new Uint16Array(szI * N);\n\t\tconst vBuffer = new Float32Array(szV * N);\n\t\tconst tBuffer = new Float32Array(szT * N);\n\t\tlet i = 0;\n\t\tfor (let tile of Object.values(tiles)) {\n\t\t\tlet c = this.layout.tileCoords(tile);\n\t\t\tvBuffer.set(c.coords, i * szV);\n\t\t\ttBuffer.set(c.tcoords, i * szT);\n\t\t\t\n\t\t\tconst off = i * 4;\n\t\t\ttile.indexBufferByteOffset = 2*i*szI;\n\t\t\tiBuffer.set([off+3, off+2, off+1, off+3, off+1, off+0], i * szI);\n\t\t\t++i;\n\t\t}\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);\n\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, iBuffer, gl.STATIC_DRAW);\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vbuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, vBuffer, gl.STATIC_DRAW);\n\n\t\tgl.vertexAttribPointer(this.shader.coordattrib, 3, gl.FLOAT, false, 0, 0);\n\t\tgl.enableVertexAttribArray(this.shader.coordattrib);\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.tbuffer);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, tBuffer, gl.STATIC_DRAW);\n\n\t\tgl.vertexAttribPointer(this.shader.texattrib, 2, gl.FLOAT, false, 0, 0);\n\t\tgl.enableVertexAttribArray(this.shader.texattrib);\n\t\t\n\t}\n\n\t/*\n\t *  If layout is ready and shader is assigned, creates or update tiles to keep track of what is missing.\n\t */\n\t/** @ignore */\n\tsetupTiles() {\n\t\tif (!this.shader || !this.layout || this.layout.status != 'ready')\n\t\t\treturn;\n\n\t\tfor (let tile of this.tiles) {\n\t\t\ttile.missing = this.shader.samplers.length;\n\t\t\tfor (let sampler of this.shader.samplers) {\n\t\t\t\tif (tile.tex[sampler.id])\n\t\t\t\t\ttile.missing--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @ignore */\n\tprepareWebGL() {\n\n\t\tlet gl = this.gl;\n\n\t\tif (!this.ibuffer) { //this part might go into another function.\n\t\t\tthis.ibuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);\n\t\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([3, 2, 1, 3, 1, 0]), gl.STATIC_DRAW);\n\n\t\t\tthis.vbuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vbuffer);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0]), gl.STATIC_DRAW);\n\n\t\t\tthis.tbuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.tbuffer);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]), gl.STATIC_DRAW);\n\t\t}\n\n\t\tif (this.shader.needsUpdate)\n\t\t\tthis.shader.createProgram(gl);\n\n\t\tgl.useProgram(this.shader.program);\n\t\tthis.shader.updateUniforms(gl, this.shader.program);\n\n\n\t}\n\n\t/** @ignore */\n\tsameNeeded(a, b) {\n\t\tif (a.level != b.level)\n\t\t\treturn false;\n\n\t\tfor (let p of ['xLow', 'xHigh', 'yLow', 'yHigh'])\n\t\t\tif (a.pyramid[a.level][p] != b.pyramid[a.level][p])\n\t\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/** @ignore */\n\tprefetch(transform, viewport) {\n\t\tif (this.layers.length != 0) { //combine layers\n\t\t\tfor (let layer of this.layers)\n\t\t\t\tlayer.prefetch(transform, viewport);\n\t\t}\n\n\t\tif (this.rasters.length == 0)\n\t\t\treturn;\n\n\t\tif (this.status != 'ready')\n\t\t\treturn;\n\n\t\tif (typeof (this.layout) != 'object')\n\t\t\tthrow \"AH!\";\n\n\t\t/*let needed = this.layout.needed(viewport, transform, this.prefetchBorder, this.mipmapBias, this.tiles);\n\n\n\t\tthis.queue = [];\n\t\tlet now = performance.now();\n\t\tlet missing = this.shader.samplers.length;\n\n\n\t\tfor(let tile of needed) {\n\t\t\tif(tile.missing === null)\n\t\t\t\ttile.missing = missing;\n\t\t\tif (tile.missing != 0 && !this.requested[index])\n\t\t\t\ttmp.push(tile);\n\t\t} */\n\t\tthis.queue = this.layout.needed(viewport, transform, this.transform, this.prefetchBorder, this.mipmapBias, this.tiles);\n\t\t/*\t\tlet needed = this.layout.neededBox(viewport, transform, this.prefetchBorder, this.mipmapBias);\n\t\t\t\tif (this.previouslyNeeded && this.sameNeeded(this.previouslyNeeded, needed))\n\t\t\t\t\treturn;\n\t\t\t\tthis.previouslyNeeded = needed;\n\t\t\n\t\t\t\tthis.queue = [];\n\t\t\t\tlet now = performance.now();\n\t\t\t\t//look for needed nodes and prefetched nodes (on the pos destination\n\t\t\t\tlet missing = this.shader.samplers.length;\n\t\t\n\t\t\t\tfor (let level = 0; level <= needed.level; level++) {\n\t\t\t\t\tlet box = needed.pyramid[level];\n\t\t\t\t\tlet tmp = [];\n\t\t\t\t\tfor (let y = box.yLow; y < box.yHigh; y++) {\n\t\t\t\t\t\tfor (let x = box.xLow; x < box.xHigh; x++) {\n\t\t\t\t\t\t\tlet index = this.layout.index(level, x, y);\n\t\t\t\t\t\t\tlet tile = this.tiles.get(index) || { index, x, y, missing, tex: [], level };\n\t\t\t\t\t\t\ttile.time = now;\n\t\t\t\t\t\t\ttile.priority = needed.level - level;\n\t\t\t\t\t\t\tif (tile.missing != 0 && !this.requested[index])\n\t\t\t\t\t\t\t\ttmp.push(tile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet c = box.center();\n\t\t\t\t\t//sort tiles by distance to the center TODO: check it's correct!\n\t\t\t\t\ttmp.sort(function (a, b) { return Math.abs(a.x - c[0]) + Math.abs(a.y - c[1]) - Math.abs(b.x - c[0]) - Math.abs(b.y - c[1]); });\n\t\t\t\t\tthis.queue = this.queue.concat(tmp);\n\t\t\t\t}*/\n\t\t_Cache_js__WEBPACK_IMPORTED_MODULE_2__.Cache.setCandidates(this);\n\t}\n\n\t/** @ignore */\n\tasync loadTile(tile, callback) {\n\t\tif (this.tiles.has(tile.index))\n\t\t\tthrow \"AAARRGGHHH double tile!\";\n\n\t\tif (this.requested[tile.index])\n\t\t\tthrow \"AAARRGGHHH double request!\";\n\n\t\tthis.tiles.set(tile.index, tile);\n\t\tthis.requested[tile.index] = true;\n\n\t\tif (this.layout.type == 'itarzoom') {\n\t\t\ttile.url = this.layout.getTileURL(null, tile);\n\t\t\tlet options = {};\n\t\t\tif (tile.end)\n\t\t\t\toptions.headers = { range: `bytes=${tile.start}-${tile.end}`, 'Accept-Encoding': 'indentity' }\n\n\t\t\tvar response = await fetch(tile.url, options);\n\t\t\tif (!response.ok) {\n\t\t\t\tcallback(\"Failed loading \" + tile.url + \": \" + response.statusText);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet blob = await response.blob();\n\n\t\t\tlet i = 0;\n\t\t\tfor (let sampler of this.shader.samplers) {\n\t\t\t\tlet raster = this.rasters[sampler.id];\n\t\t\t\tlet imgblob = blob.slice(tile.offsets[i], tile.offsets[i + 1]);\n\t\t\t\tconst img = await raster.blobToImage(imgblob, this.gl);\n\t\t\t\tlet tex = raster.loadTexture(this.gl, img);\n\t\t\t\tlet size = img.width * img.height * 3;\n\t\t\t\ttile.size += size;\n\t\t\t\ttile.tex[sampler.id] = tex;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ttile.missing = 0;\n\t\t\tthis.emit('update');\n\t\t\tdelete this.requested[tile.index];\n\t\t\tif (callback) callback(tile.size);\n\t\t\treturn;\n\t\t}\n\t\ttile.missing = this.shader.samplers.length;\n\t\tfor (let sampler of this.shader.samplers) {\n\n\t\t\tlet raster = this.rasters[sampler.id];\n\t\t\ttile.url = this.layout.getTileURL(sampler.id, tile);\n\t\t\tconst [tex, size] = await raster.loadImage(tile, this.gl); // TODO Parallelize request and url must be a parameter (implement request ques per url)\n\t\t\tif (this.layout.type == \"image\") {\n\t\t\t\tthis.layout.width = raster.width;\n\t\t\t\tthis.layout.height = raster.height;\n\t\t\t\tthis.layout.emit('updateSize');\n\t\t\t}\n\t\t\ttile.size += size;\n\t\t\ttile.tex[sampler.id] = tex;\n\t\t\ttile.missing--;\n\t\t\tif (tile.missing <= 0) {\n\t\t\t\tthis.emit('update');\n\t\t\t\tdelete this.requested[tile.index];\n\t\t\t\tif (callback) callback(size);\n\t\t\t}\n\t\t}\n\t}\n}\n\nLayer.prototype.types = {}\n;(0,_Signals_js__WEBPACK_IMPORTED_MODULE_4__.addSignals)(Layer, 'update', 'ready', 'updateSize');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUFVOztBQUVNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvTGF5ZXIuanM/ZmQ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL1RyYW5zZm9ybS5qcydcbmltcG9ydCB7IExheW91dCB9IGZyb20gJy4vTGF5b3V0LmpzJ1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJ1xuaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICcuL0JvdW5kaW5nQm94LmpzJ1xuaW1wb3J0IHsgYWRkU2lnbmFscyB9IGZyb20gJy4vU2lnbmFscy5qcydcblxuXG4vKipcbiAqIFRoZSBMYXllciBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBzbGlkZXMgaW4gdGhlIE9wZW5MSU1FIHZpZXdlci4gXG4gKiBMYXllcnMgY2FuIGRpcmVjdGx5IGRyYXcgdGhlaXIgY29udGVudHMgb24gdGhlIHZpZXdlciBvciBiZSBjb21iaW5lZCB3aXRoIGVhY2ggb3RoZXIgdG8gb2J0YWluIG1vcmUgY29tcGxleCB2aXN1YWxpemF0aW9ucy5cbiAqIE9wZW5MSU1FIHByb3ZpZGVzIGEgc2V0IG9mIHJlYWR5LXRvLXVzZSBsYXllcnMgdGhhdCBhbGxvd3MgZGV2ZWxvcGVycyB0byBxdWlja2x5IHB1Ymxpc2ggdGhlaXIgZGF0YXNldHMgb24gdGhlIHdlYlxuICogb3IgbWFrZSBraW9zayBhcHBsaWNhdGlvbnMuIFJlYWR5LXRvLXVzZSBsYXllcnMgcmFuZ2luZyBmcm9tIGltYWdlcywgdG8gbXVsdGktY2hhbm5lbCBkYXRhIChzdWNoIGFzLCBmb3IgZXhhbXBsZSwgUlRJIG9yIEJSREYpXG4gKiBvciB0aGUgY29tYmluYXRpb24gb2YgbXVsdGlwbGUgbGF5ZXJzIG9yIGZvciB2aXN1YWxpemF0aW9uIHRocm91Z2ggbGVuc2VzLlxuICogXG4gKiBBIExheWVyIHRha2VzIHJhc3RlciBkYXRhIChpbWFnZXMpIGFzIGlucHV0IHdoaWNoIGFyZSBtYW5hZ2VkIGJ5IHRoZSBsYXlvdXQuIEEgbGF5ZXIgc3RvcmVzIGFsbCB0aGUgaW5mb3JtYXRpb25cbiAqIGFuZCBmdW5jdGlvbnMgbmVlZGVkIHRvIHJlbmRlciB0aGUgZ3JhcGhpY3MgKHNoYWRlcnMsIHNoYWRlciBwYXJhbWV0ZXJzLCBkYXRhIHN0cnVjdHVyZXMsIGV0Yy4pLCBhbmQgdGFrZXMgY2FyZVxuICogb2YgZGF0YSBwcmVmZXRjaGluZyBhbmQgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBjYWNoZS5cbiAqIFxuICogVGhlIExheWVyIGlzIGEga2luZCBvZiBwcmltaXRpdmUgY2xhc3MgZnJvbSB3aGljaCBvdGhlciBMYXllciBjbGFzc2VzIGNhbiBpbmhlcml0LlxuICogRWFjaCBkZXJpdmVkIGNsYXNzIFwicmVnaXN0ZXJzXCIgb24gdGhlIExheWVyIGJhc2UgY2xhc3MsIHRoZSB1c2VyIGNhbiB0aGVuIHVzZSBhbiBpbnN0YW5jZSBvZiBcbiAqIExheWVyIGJ5IGluZGljYXRpbmcgdGhlIGNob3NlbiBgdHlwZWAgaW4gdGhlIGBvcHRpb25zYC5cbiAqIFxuICogSW4gdGhlIGV4YW1wbGUgYmVsb3cgYSBMYXllciBvZiB0eXBlICdydGknIGlzIGNyZWF0ZWQsIHRoZW4gYSBMYXllclJUSSAoY2xhc3MgZGVyaXZlZCBmcm9tIExheWVyKSBpcyBpbnN0YW50aWF0ZWQgYW5kIGFkZGVkIHRvIHRoZSB2aWV3ZXIncyBsYXllciBzdGFjay5cbiAqIFxuICogQGV4YW1wbGVcbiAqICAgICAgY29uc3QgbGF5ZXIxID0gbmV3IE9wZW5MSU1FLkxheWVyKHtcbiAqICAgICAgICAgIGxheW91dDogJ2RlZXB6b29tJyxcbiAqICAgICAgICAgIGxhYmVsOiAnQW5jaWVudCBSb21hbiBjb2luJyxcbiAqICAgICAgICAgIHR5cGU6ICdydGknLFxuICogICAgICAgICAgdXJsOiAnLi4vLi4vYXNzZXRzL3J0aS9oc2gvaW5mby5qc29uJyxcbiAqICAgICAgICAgIG5vcm1hbHM6IGZhbHNlXG4gKiAgICAgIH0pO1xuICogICAgICB2aWV3ZXIuYWRkTGF5ZXIoJ2NvaW4xJywgbGF5ZXIxKTtcbiAqL1xuXG4vL0ZJWE1FOiBwcmVmZXRjaGJvcmRlciBhbmQgbWlwbWFwYmlhcyBzaG91bGQgcHJvYmFibHkgZ28gaW50byBsYXlvdXRcbmNsYXNzIExheWVyIHtcblx0LyoqXG5cdCogQ3JlYXRlcyBhIExheWVyLiBBZGRpdGlvbmFsbHksIGFuIG9iamVjdCBsaXRlcmFsIHdpdGggTGF5ZXIgYG9wdGlvbnNgIGNhbiBiZSBzcGVjaWZpZWQuXG5cdCogU2lnbmFscyBhcmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGxheWVyIGlzIHJlYWR5IChpLmUuIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQpIG9yIGlmIGl0cyBzdGF0ZSB2YXJpYWJsZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgKGEgcmVkcmF3IGlzIG5lZWRlZCkuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHQqIEBwYXJhbSB7KHN0cmluZ3xMYXlvdXQpfSBvcHRpb25zLmxheW91dD0naW1hZ2UnIFRoZSBsYXlvdXQgKHRoZSBmb3JtYXQgb2YgdGhlIGlucHV0IHJhc3RlciBpbWFnZXMpLlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnR5cGUgQSBzdHJpbmcgaWRlbnRpZmllciB0byBzZWxlY3QgdGhlIHNwZWNpZmljIGRlcml2ZWQgbGF5ZXIgY2xhc3MgdG8gaW5zdGFudGlhdGUuXG5cdCogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWQgVGhlIGxheWVyIHVuaXF1ZSBpZGVudGlmaWVyLlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxhYmVsIEEgc3RyaW5nIHdpdGggYSBtb3JlIGNvbXByZWhlbnNpdmUgZGVmaW5pdGlvbiBvZiB0aGUgbGF5ZXIuIElmIGl0IGV4aXN0cywgaXQgaXMgdXNlZCBpbiB0aGUgVUkgbGF5ZXIgbWVudSwgb3RoZXJ3aXNlIHRoZSBgaWRgIHZhbHVlIGlzIHRha2VuLlxuXHQqIEBwYXJhbSB7VHJhbnNmb3JtfSBvcHRpb25zLnRyYW5zZm9ybSBUaGUgcmVsYXRpdmUgY29vcmRzIGZyb20gbGF5ZXIgdG8gY2FudmFzLlxuXHQqIEBwYXJhbSB7Ym9vbH0gb3B0aW9ucy52aXNpYmxlPXRydWUgV2hldGhlciB0byByZW5kZXIgdGhlIGxheWVyLlxuXHQqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnppbmRleCBTdGFjayBvcmRlcmluZyB2YWx1ZSBmb3IgdGhlIHJlbmRlcmluZyBvZiBsYXllcnMgKGhpZ2hlciB6aW5kZXggb24gdG9wKS5cblx0KiBAcGFyYW0ge2Jvb2x9IG9wdGlvbnMub3ZlcmxheT1mYWxzZSAgV2hldGhlciB0aGUgbGF5ZXIgbXVzdCBiZSByZW5kZXJlZCBpbiBvdmVybGF5IG1vZGUuXG5cdCogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucHJlZmV0Y2hCb3JkZXI9MSBUaGUgdGhyZXNob2xkIChpbiB0aWxlIHVuaXRzKSBhcm91bmQgdGhlIGN1cnJlbnQgY2FtZXJhIHBvc2l0aW9uIGZvciB3aGljaCB0byBwcmVmZXRjaCB0aWxlcy5cblx0KiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5taXBtYXBCaWFzPTAuNCBUaGUgbWlwbWFwIGJpYXMgb2YgdGhlIHRleHR1cmUuXG5cdCogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc2hhZGVycyBBIG1hcCAoc2hhZGVyc0lkLCBzaGFkZXIpIG9mIHRoZSBzaGFkZXJzIHVzYWJsZSBmb3IgdGhlIGxheWVyIHJlbmRlcmluZy4gU2VlIEBsaW5rIHtTaGFkZXJ9LlxuXHQqIEBwYXJhbSB7Q29udHJvbGxlcltdfSBvcHRpb25zLmNvbnRyb2xsZXJzIEFuIGFycmF5IG9mIFVJIGRldmljZSBjb250cm9sbGVycyBhY3RpdmUgb24gdGhlIGxheWVyLlxuXHQqIEBwYXJhbSB7TGF5ZXJ9IG9wdGlvbnMuc291cmNlTGF5ZXIgVGhlIGxheWVyIGZyb20gd2hpY2ggdG8gdGFrZSB0aGUgdGlsZXMgKGluIG9yZGVyIHRvIGF2b2lkIHRpbGUgZHVwbGljYXRpb24pLlxuXHQqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0Ly9jcmVhdGUgZnJvbSBkZXJpdmVkIGNsYXNzIGlmIHR5cGUgc3BlY2lmaWVkXG5cdFx0aWYgKG9wdGlvbnMudHlwZSkge1xuXHRcdFx0bGV0IHR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdFx0XHRkZWxldGUgb3B0aW9ucy50eXBlO1xuXHRcdFx0aWYgKHR5cGUgaW4gdGhpcy50eXBlcykge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnR5cGVzW3R5cGVdKG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgXCJMYXllciB0eXBlOiBcIiArIHR5cGUgKyBcIiAgbW9kdWxlIGhhcyBub3QgYmVlbiBsb2FkZWRcIjtcblx0XHR9XG5cblx0XHR0aGlzLmluaXQob3B0aW9ucyk7XG5cblx0XHQvKlxuXHRcdC8vY3JlYXRlIG1lbWJlcnMgZnJvbSBvcHRpb25zLlxuXHRcdHRoaXMucmFzdGVycyA9IHRoaXMucmFzdGVycy5tYXAoKHJhc3RlcikgPT4gbmV3IFJhc3RlcihyYXN0ZXIpKTtcblxuXHRcdC8vbGF5b3V0IG5lZWRzIHRvIGJlIHRoZSBzYW1lIGZvciBhbGwgcmFzdGVyc1xuXHRcdGlmKHRoaXMucmFzdGVycy5sZW5ndGgpIHtcblx0XHRcdGlmKHR5cGVvZih0aGlzLmxheW91dCkgIT0gJ29iamVjdCcpXG5cdFx0XHRcdHRoaXMubGF5b3V0ID0gbmV3IExheW91dCh0aGlzLnJhc3RlcnNbMF0udXJsLCB0aGlzLmxheW91dClcblx0XHRcdHRoaXMuc2V0TGF5b3V0KHRoaXMubGF5b3V0KVxuXG5cdFx0XHRpZih0aGlzLnJhc3RlcnMubGVuZ3RoKVxuXHRcdFx0XHRmb3IobGV0IHJhc3RlciBpbiB0aGlzLnJhc3RlcnMpXG5cdFx0XHRcdFx0cmFzdGVyLmxheW91dCA9IHRoaXMubGF5b3V0O1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuc2hhZGVyKVxuXHRcdFx0dGhpcy5zaGFkZXIgPSBuZXcgU2hhZGVyKHRoaXMuc2hhZGVyKTtcblx0XHQqL1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0aW5pdChvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XG5cdFx0XHR0cmFuc2Zvcm06IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdHZpc2libGU6IHRydWUsXG5cdFx0XHR6aW5kZXg6IDAsXG5cdFx0XHRvdmVybGF5OiBmYWxzZSwgLy9pbiB0aGUgR1VJIGl0IHdvbid0IGFmZmVjdCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgb3RoZXIgbGF5ZXJzXG5cdFx0XHRyYXN0ZXJzOiBbXSxcblx0XHRcdGxheWVyczogW10sXG5cdFx0XHRjb250cm9sczoge30sXG5cdFx0XHRjb250cm9sbGVyczogW10sXG5cdFx0XHRzaGFkZXJzOiB7fSxcblx0XHRcdGxheW91dDogJ2ltYWdlJyxcblx0XHRcdHNoYWRlcjogbnVsbCwgLy9jdXJyZW50IHNoYWRlci5cblx0XHRcdGdsOiBudWxsLFxuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHRwcmVmZXRjaEJvcmRlcjogMSxcblx0XHRcdG1pcG1hcEJpYXM6IDAuNCxcblxuXHRcdFx0Ly9zaWduYWxzOiB7IHVwZGF0ZTogW10sIHJlYWR5OiBbXSwgdXBkYXRlU2l6ZTogW10gfSwgIC8vdXBkYXRlIGNhbGxiYWNrcyBmb3IgYSByZWRyYXcsIHJlYWR5IG9uY2UgbGF5b3V0IGlzIGtub3duLlxuXG5cdFx0XHQvL2ludGVybmFsIHN0dWZmLCBzaG91bGQgbm90IGJlIHBhc3NlZCBhcyBvcHRpb25zLlxuXHRcdFx0dGlsZXM6IG5ldyBNYXAoKSwgICAgICAvL2tlZXAgcmVmZXJlbmNlcyB0byBlYWNoIHRleHR1cmUgKGFuZCBzdGF0dXMpIGluZGV4ZWQgYnkgbGV2ZWwsIHggYW5kIHkuXG5cdFx0XHQvL2VhY2ggdGlsZSBpcyB0ZXg6IFsuLiBvbmUgZm9yIHJhc3RlciAuLl0sIG1pc3Npbmc6IDMgbWlzc2luZyB0ZXggYmVmb3JlIHRpbGUgaXMgcmVhZHkuXG5cdFx0XHQvL29ubHkgcmFzdGVyIHVzZWQgYnkgdGhlIHNoYWRlciB3aWxsIGJlIGxvYWRlLlxuXHRcdFx0cXVldWU6IFtdLCAgICAgLy9xdWV1ZSBvZiB0aWxlcyB0byBiZSBsb2FkZWQuXG5cdFx0XHRyZXF1ZXN0ZWQ6IHt9LCAgLy90aWxlcyByZXF1ZXN0ZWQuXG5cdFx0fSk7XG5cblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXHRcdGlmICh0aGlzLnNvdXJjZUxheWVyKSB0aGlzLnRpbGVzID0gdGhpcy5zb3VyY2VMYXllci50aWxlczsgLy9GSVhNRSBhdm9pZCB0aWxlcyBkdXBsaWNhdGlvblxuXG5cdFx0dGhpcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtKTtcblxuXHRcdGlmICh0eXBlb2YgKHRoaXMubGF5b3V0KSA9PSAnc3RyaW5nJykge1xuXHRcdFx0bGV0IHNpemUgPSB7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH07XG5cdFx0XHR0aGlzLnNldExheW91dChuZXcgTGF5b3V0KG51bGwsIHRoaXMubGF5b3V0LCBzaXplKSk7IC8vRklYTUUgbmV3IExheW91dCBub3QgaGF2ZSBzaXplLCBidXQgb3B0aW9ucy53aWR0aCBvcHRpb25zLmhlaWdodFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldExheW91dCh0aGlzLmxheW91dCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBsYXllciBcblx0ICovXG5cdHNldFN0YXRlKHN0YXRlLCBkdCwgZWFzaW5nID0gJ2xpbmVhcicpIHtcblx0XHRpZiAoJ2NvbnRyb2xzJyBpbiBzdGF0ZSlcblx0XHRcdGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc3RhdGUuY29udHJvbHMpKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q29udHJvbChrZXksIHYsIGR0LCBlYXNpbmcpO1xuXHRcdFx0fVxuXHRcdGlmICgnbW9kZScgaW4gc3RhdGUgJiYgc3RhdGUubW9kZSkge1xuXHRcdFx0dGhpcy5zZXRNb2RlKHN0YXRlLm1vZGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzdGF0ZSB2YXJpYWJsZXMgb2YgdGhlIGxheWVyLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHN0YXRlIHZhcmlhYmxlcyBcblx0ICovXG5cdGdldFN0YXRlKHN0YXRlTWFzayA9IG51bGwpIHtcblx0XHRjb25zdCBzdGF0ZSA9IHt9O1xuXHRcdHN0YXRlLmNvbnRyb2xzID0ge307XG5cdFx0Zm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNvbnRyb2xzKSkge1xuXHRcdFx0aWYgKCFzdGF0ZU1hc2sgfHwgKCdjb250cm9scycgaW4gc3RhdGVNYXNrICYmIGtleSBpbiBzdGF0ZU1hc2suY29udHJvbHMpKVxuXHRcdFx0XHRzdGF0ZS5jb250cm9sc1trZXldID0gdi5jdXJyZW50LnZhbHVlO1xuXHRcdH1cblx0XHRpZiAoIXN0YXRlTWFzayB8fCAnbW9kZScgaW4gc3RhdGVNYXNrKVxuXHRcdFx0aWYgKHRoaXMuZ2V0TW9kZSgpKVxuXHRcdFx0XHRzdGF0ZS5tb2RlID0gdGhpcy5nZXRNb2RlKCk7XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0c2V0TGF5b3V0KGxheW91dCkge1xuXHRcdC8qKlxuXHRcdCogVGhlIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBsYXllciBpcyBpbml0aWFsaXplZC5cblx0XHQqIEBldmVudCBMYXllciNyZWFkeVxuXHRcdCovXG5cdFx0LyoqXG5cdFx0KiBUaGUgZXZlbnQgaXMgZmlyZWQgaWYgYSByZWRyYXcgaXMgbmVlZGVkLlxuXHRcdCogQGV2ZW50IExheWVyI3VwZGF0ZVxuXHRcdCovXG5cblx0XHRsZXQgY2FsbGJhY2sgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLnN0YXR1cyA9ICdyZWFkeSc7XG5cdFx0XHR0aGlzLnNldHVwVGlsZXMoKTsgLy9zZXR1cCBleHBlY3Qgc3RhdHVzIHRvIGJlIHJlYWR5IVxuXHRcdFx0dGhpcy5lbWl0KCdyZWFkeScpO1xuXHRcdFx0dGhpcy5lbWl0KCd1cGRhdGUnKTtcblx0XHR9O1xuXHRcdGlmIChsYXlvdXQuc3RhdHVzID09ICdyZWFkeScpIC8vbGF5b3V0IGFscmVhZHkgaW5pdGlhbGl6ZWQuXG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdGVsc2Vcblx0XHRcdGxheW91dC5hZGRFdmVudCgncmVhZHknLCBjYWxsYmFjayk7XG5cdFx0dGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG5cblx0XHQvLyBTZXQgc2lnbmFsIHRvIGFja25vd2xlZGdlIGNoYW5nZSBvZiBiYm94IHdoZW4gaXQgaXMga25vd24uIExldCB0aGlzIHNpZ25hbCBnbyB1cCB0byBjYW52YXNcblx0XHR0aGlzLmxheW91dC5hZGRFdmVudCgndXBkYXRlU2l6ZScsICgpID0+IHsgdGhpcy5lbWl0KCd1cGRhdGVTaXplJyk7IH0pO1xuXHR9XG5cblx0Ly8gT0tcblx0c2V0VHJhbnNmb3JtKHR4KSB7IC8vRklYTUVcblx0XHR0aGlzLnRyYW5zZm9ybSA9IHR4O1xuXHRcdHRoaXMuZW1pdCgndXBkYXRlU2l6ZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNoYWRlciB0byB1c2Vcblx0ICogQHBhcmFtIHsqfSBpZCB0aGUgY3VycmVudCBzaGFkZXIgaWRlbnRpZmllciAodGhlIHNoYWRlciBtdXN0IGFscmVhZHkgYmUgcmVnaXN0ZXJlZCBpbiB0aGUgYHNoYWRlcnNgIGFycmF5KVxuXHQgKi9cblx0c2V0U2hhZGVyKGlkKSB7XG5cdFx0aWYgKCFpZCBpbiB0aGlzLnNoYWRlcnMpXG5cdFx0XHR0aHJvdyBcIlVua25vd24gc2hhZGVyOiBcIiArIGlkO1xuXHRcdHRoaXMuc2hhZGVyID0gdGhpcy5zaGFkZXJzW2lkXTtcblx0XHR0aGlzLnNldHVwVGlsZXMoKTtcblx0XHR0aGlzLnNoYWRlci5hZGRFdmVudCgndXBkYXRlJywgKCkgPT4geyB0aGlzLmVtaXQoJ3VwZGF0ZScpOyB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50IHNoYWRlciBtb2RlLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgc2hhZGVyIG1vZGVcblx0ICovXG5cdGdldE1vZGUoKSB7XG5cdFx0aWYgKHRoaXMuc2hhZGVyKVxuXHRcdFx0cmV0dXJuIHRoaXMuc2hhZGVyLm1vZGU7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cdFxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIGFycmF5cyBvZiBhbGwgdGhlIG1vZGVzIGltcGxlbWVudGVkIGluIHRoZSBjdXJyZW50IHNoYWRlci5cblx0ICogQHJldHVybnMge3N0cmluZ1tdfSBhcnJheXMgb2YgbW9kZXNcblx0ICovXG5cdGdldE1vZGVzKCkge1xuXHRcdGlmICh0aGlzLnNoYWRlcilcblx0XHRcdHJldHVybiB0aGlzLnNoYWRlci5tb2Rlcztcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBtb2RlIG9mIHRoZSBjdXJyZW50IHNoYWRlci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgdGhlIG1vZGUgb2YgdGhlIGN1cnJlbnQgc2hhZGVyLlxuXHQgKi9cblx0c2V0TW9kZShtb2RlKSB7XG5cdFx0dGhpcy5zaGFkZXIuc2V0TW9kZShtb2RlKTtcblx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuXHQgKiBAcGFyYW0ge2Jvb2x9IHZpc2libGUgVGhlIHZhbHVlLlxuXHQgKi9cblx0c2V0VmlzaWJsZSh2aXNpYmxlKSB7XG5cdFx0dGhpcy52aXNpYmxlID0gdmlzaWJsZTtcblx0XHR0aGlzLnByZXZpb3VzbHlOZWVkZWQgPSBudWxsO1xuXHRcdHRoaXMuZW1pdCgndXBkYXRlJyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbGF5ZXIgemluZGV4IHZhbHVlIChzdGFjayBvcmRlcmluZyB2YWx1ZSBmb3IgdGhlIHJlbmRlcmluZyBvZiBsYXllcnMpLlxuXHQgKiBAcGFyYW0ge2ludH0gemluZGV4IFRoZSB2YWx1ZS5cblx0ICovXG5cdHNldFppbmRleCh6aW5kZXgpIHtcblx0XHR0aGlzLnppbmRleCA9IHppbmRleDtcblx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbXB1dGVzIHRoZSBtaW51bSBzY2FsZSB2YWx1ZSBvZiB0aGUgYGxheWVyc2AuXG5cdCAqIEBwYXJhbSB7TGF5ZXJbXX0gbGF5ZXJzIFxuXHQgKiBAcGFyYW0ge2Jvb2x9IGRpc2NhcmRIaWRkZW4gV2hldGhlciBoaWRkZW4gbGF5ZXJzIGFyZSBub3QgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGNvbXB1dGF0aW9uLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbWluaW11bSBzY2FsZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGNvbXB1dGVMYXllcnNNaW5TY2FsZShsYXllcnMsIGRpc2NhcmRIaWRkZW4pIHtcblx0XHRpZiAobGF5ZXJzID09IHVuZGVmaW5lZCB8fCBsYXllcnMgPT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJBU0tJTkcgU0NBTEUgSU5GTyBPTiBOTyBMQVlFUlNcIik7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0bGV0IGxheWVyc1NjYWxlID0gMTtcblx0XHRmb3IgKGxldCBsYXllciBvZiBPYmplY3QudmFsdWVzKGxheWVycykpIHtcblx0XHRcdGlmICghZGlzY2FyZEhpZGRlbiB8fCBsYXllci52aXNpYmxlKSB7XG5cdFx0XHRcdGxldCBzID0gbGF5ZXIuc2NhbGUoKTtcblx0XHRcdFx0bGF5ZXJzU2NhbGUgPSBNYXRoLm1pbihsYXllcnNTY2FsZSwgcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsYXllcnNTY2FsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzY2FsZSBvZiB0aGUgbGF5ZXIgdHJhbnNmb3JtYXRpb25cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHNjYWxlXG5cdCAqL1xuXHRzY2FsZSgpIHtcblx0XHQvLyBGSVhNRTogdGhpcyBkbyBub3QgY29uc2lkZXIgY2hpbGRyZW4gbGF5ZXJzXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtLno7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbGF5ZXIgYm91bmRpbmcgYm94ICg8RklYTUU+IENoYW5nZSBuYW1lOiBib3ggaXMgaW4gc2NlbmUgY29vcmRpbmF0ZXMpXG5cdCAqIEByZXR1cm5zIHtCb3VuZGluZ0JveH0gVGhlIGJvdW5kaW5nIGJveCBcblx0ICovXG5cdGJvdW5kaW5nQm94KCkge1xuXHRcdC8vIEZJWE1FOiB0aGlzIGRvIG5vdCBjb25zaWRlciBjaGlsZHJlbiBsYXllcnNcblx0XHQvLyBUYWtlIGxheW91dCBiYm94XG5cdFx0bGV0IHJlc3VsdCA9IHRoaXMubGF5b3V0LmJvdW5kaW5nQm94KCk7XG5cblx0XHQvLyBBcHBseSBsYXllciB0cmFuc2Zvcm0gdG8gYmJveFxuXHRcdGlmICh0aGlzLnRyYW5zZm9ybSAhPSBudWxsICYmIHRoaXMudHJhbnNmb3JtICE9IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVzdWx0ID0gdGhpcy50cmFuc2Zvcm0udHJhbnNmb3JtQm94KHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgICogQ29tcHV0ZXMgdGhlIG1lcmdlIGJvdW5kaW5nIGJveCBvZiBhbGwgdGhlICdsYXllcnNgXG5cdCAgKiBAcGFyYW0ge0xheWVyW119IGxheWVycyBcblx0ICAqIEBwYXJhbSB7Ym9vbH0gZGlzY2FyZEhpZGRlbiBXaGV0aGVyIGhpZGRlbiBsYXllcnMgYXJlIG5vdCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgY29tcHV0YXRpb24uXG5cdCAgKiBAcmV0dXJucyB7Qm91bmRpbmdCb3h9IFRoZSBib3VuZGluZyBib3ggXG5cdCogQHN0YXRpYyBcblx0ICAqL1xuXHRzdGF0aWMgY29tcHV0ZUxheWVyc0JCb3gobGF5ZXJzLCBkaXNjYXJkSGlkZGVuKSB7XG5cdFx0aWYgKGxheWVycyA9PSB1bmRlZmluZWQgfHwgbGF5ZXJzID09IG51bGwpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiQVNLSU5HIEJCT1ggSU5GTyBPTiBOTyBMQVlFUlNcIik7XG5cdFx0XHRsZXQgZW1wdHlCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcblx0XHRcdHJldHVybiBlbXB0eUJveDtcblx0XHR9XG5cdFx0bGV0IGxheWVyc0Jib3ggPSBuZXcgQm91bmRpbmdCb3goKTtcblx0XHRmb3IgKGxldCBsYXllciBvZiBPYmplY3QudmFsdWVzKGxheWVycykpIHtcblx0XHRcdGlmICgoIWRpc2NhcmRIaWRkZW4gfHwgbGF5ZXIudmlzaWJsZSkgJiYgbGF5ZXIubGF5b3V0LndpZHRoKSB7XG5cdFx0XHRcdGNvbnN0IGJib3ggPSBsYXllci5ib3VuZGluZ0JveCgpO1xuXHRcdFx0XHRsYXllcnNCYm94Lm1lcmdlQm94KGJib3gpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbGF5ZXJzQmJveDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzaGFkZXIgcGFyYW1ldGVyIGNvbnRyb2wgY29ycmVzcG9uZGluZyB0byBgbmFtZWBcblx0ICogQHBhcmFtIHsqfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLlxuXHQgKiByZXR1cm4geyp9IFRoZSBjb250cm9sXG5cdCAqL1xuXHRnZXRDb250cm9sKG5hbWUpIHtcblx0XHRsZXQgY29udHJvbCA9IHRoaXMuY29udHJvbHNbbmFtZV0gPyB0aGlzLmNvbnRyb2xzW25hbWVdIDogbnVsbDtcblx0XHRpZiAoY29udHJvbCkge1xuXHRcdFx0bGV0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0dGhpcy5pbnRlcnBvbGF0ZUNvbnRyb2woY29udHJvbCwgbm93KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbnRyb2w7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5ldyBzaGFkZXIgcGFyYW1ldGVyIGNvbnRyb2wuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBmb3IgaW5pdGlhbGl6YXRpb24uXG5cdCAqL1xuXHRhZGRDb250cm9sKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvbnRyb2wgXCIkbmFtZVwiIGFscmVhZHkgZXhpc3QhYCk7XG5cdFx0bGV0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHRoaXMuY29udHJvbHNbbmFtZV0gPSB7ICdzb3VyY2UnOiB7ICd2YWx1ZSc6IHZhbHVlLCAndCc6IG5vdyB9LCAndGFyZ2V0JzogeyAndmFsdWUnOiB2YWx1ZSwgJ3QnOiBub3cgfSwgJ2N1cnJlbnQnOiB7ICd2YWx1ZSc6IHZhbHVlLCAndCc6IG5vdyB9LCAnZWFzaW5nJzogJ2xpbmVhcicgfTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgYSBzaGFkZXIgcGFyYW1ldGVyIGNvbnRyb2wgd2l0aCBuZXcgdmFsdWVcblx0ICogQHBhcmFtIHsqfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250cm9sLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBmb3IgaW5pdGlhbGl6YXRpb24uXG5cdCAqIEBwYXJhbSB7dGltZX0gZHQgRHVyYXRpb24gb2YgdGhlIGludGVycG9sYXRpb24gKDA9bm8gaW50ZXJwb2xhdGlvbikuXG5cdCAqL1xuXHRzZXRDb250cm9sKG5hbWUsIHZhbHVlLCBkdCwgZWFzaW5nID0gJ2xpbmVhcicpIHsgLy9XaGVuIGFyZSBjcmVhdGVkP1xuXHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgY29udHJvbCA9IHRoaXMuY29udHJvbHNbbmFtZV07XG5cdFx0dGhpcy5pbnRlcnBvbGF0ZUNvbnRyb2woY29udHJvbCwgbm93KTtcblxuXHRcdGNvbnRyb2wuc291cmNlLnZhbHVlID0gWy4uLmNvbnRyb2wuY3VycmVudC52YWx1ZV07XG5cdFx0Y29udHJvbC5zb3VyY2UudCA9IG5vdztcblxuXHRcdGNvbnRyb2wudGFyZ2V0LnZhbHVlID0gWy4uLnZhbHVlXTtcblx0XHRjb250cm9sLnRhcmdldC50ID0gbm93ICsgZHQ7XG5cblx0XHRjb250cm9sLmVhc2luZyA9IGVhc2luZztcblxuXHRcdHRoaXMuZW1pdCgndXBkYXRlJyk7XG5cdH1cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIHBhcmFtZXRlciBjb250cm9scy5cblx0ICogQHJldHVybnMge2Jvb2x9IFdlYXRoZXIgdGhlIGludGVycG9sYXRpb24gaXMgZmluaXNoZWQgKHRoZSB0aW1lIGhhcyBub3cgZ29uZSkuXG5cdCAqL1xuXHRpbnRlcnBvbGF0ZUNvbnRyb2xzKCkge1xuXHRcdGxldCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgZG9uZSA9IHRydWU7XG5cdFx0Zm9yIChsZXQgY29udHJvbCBvZiBPYmplY3QudmFsdWVzKHRoaXMuY29udHJvbHMpKVxuXHRcdFx0ZG9uZSA9IHRoaXMuaW50ZXJwb2xhdGVDb250cm9sKGNvbnRyb2wsIG5vdykgJiYgZG9uZTtcblx0XHRyZXR1cm4gZG9uZTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGludGVycG9sYXRlQ29udHJvbChjb250cm9sLCB0aW1lKSB7XG5cdFx0bGV0IHNvdXJjZSA9IGNvbnRyb2wuc291cmNlO1xuXHRcdGxldCB0YXJnZXQgPSBjb250cm9sLnRhcmdldDtcblx0XHRsZXQgY3VycmVudCA9IGNvbnRyb2wuY3VycmVudDtcblxuXHRcdGN1cnJlbnQudCA9IHRpbWU7XG5cdFx0aWYgKHRpbWUgPCBzb3VyY2UudCkge1xuXHRcdFx0Y3VycmVudC52YWx1ZSA9IFsuLi5zb3VyY2UudmFsdWVdO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lID4gdGFyZ2V0LnQgLSAwLjAwMDEpIHtcblx0XHRcdGxldCBkb25lID0gY3VycmVudC52YWx1ZS5ldmVyeSgoZSwgaSkgPT4gZSA9PT0gdGFyZ2V0LnZhbHVlW2ldKTtcblx0XHRcdGN1cnJlbnQudmFsdWUgPSBbLi4udGFyZ2V0LnZhbHVlXTtcblx0XHRcdHJldHVybiBkb25lO1xuXHRcdH1cblxuXHRcdGxldCBkdCA9ICh0YXJnZXQudCAtIHNvdXJjZS50KTtcblx0XHRsZXQgdHQgPSAodGltZSAtIHNvdXJjZS50KSAvIGR0O1xuXHRcdHN3aXRjaCAoY29udHJvbC5lYXNpbmcpIHtcblx0XHRcdGNhc2UgJ2Vhc2Utb3V0JzogdHQgPSAxIC0gTWF0aC5wb3coMSAtIHR0LCAyKTsgYnJlYWs7XG5cdFx0XHRjYXNlICdlYXNlLWluLW91dCc6IHR0ID0gdHQgPCAwLjUgPyAyICogdHQgKiB0dCA6IDEgLSBNYXRoLnBvdygtMiAqIHR0ICsgMiwgMikgLyAyOyBicmVhaztcblx0XHR9XG5cdFx0bGV0IHN0ID0gMSAtIHR0O1xuXG5cdFx0Y3VycmVudC52YWx1ZSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLnZhbHVlLmxlbmd0aDsgaSsrKVxuXHRcdFx0Y3VycmVudC52YWx1ZVtpXSA9IChzdCAqIHNvdXJjZS52YWx1ZVtpXSArIHR0ICogdGFyZ2V0LnZhbHVlW2ldKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLy8vLy8vLy8vLy8vXG5cdC8vLyBDQUNIRSBIQU5ETElORyAmIFJFTkRFUklOR1xuXG5cdC8qKiBAaWdub3JlICovXG5cdGRyb3BUaWxlKHRpbGUpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRpbGUudGV4Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGlsZS50ZXhbaV0pIHtcblx0XHRcdFx0dGhpcy5nbC5kZWxldGVUZXh0dXJlKHRpbGUudGV4W2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy50aWxlcy5kZWxldGUodGlsZS5pbmRleCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRjbGVhcigpIHtcblx0XHR0aGlzLmlidWZmZXIgPSB0aGlzLnZidWZmZXIgPSBudWxsO1xuXHRcdENhY2hlLmZsdXNoTGF5ZXIodGhpcyk7XG5cdFx0dGhpcy50aWxlcyA9IG5ldyBNYXAoKTsgLy9UT0RPIFdlIG5lZWQgdG8gZHJvcCB0aGVzZSB0aWxlIHRleHR1cmVzIGJlZm9yZSBjbGVhcmluZyBNYXBcblx0XHR0aGlzLnNldHVwVGlsZXMoKTtcblx0XHR0aGlzLnF1ZXVlID0gW107XG5cdFx0dGhpcy5wcmV2aW91c2x5TmVlZGVkID0gZmFsc2U7XG5cdH1cblxuXHQvKlxuXHQgKiBSZW5kZXJzIHRoZSBsYXllclxuXHQgKi9cblx0LyoqIEBpZ25vcmUgKi9cblx0ZHJhdyh0cmFuc2Zvcm0sIHZpZXdwb3J0KSB7XG5cdFx0Ly9leGNlcHRpb24gZm9yIGxheW91dCBpbWFnZSB3aGVyZSB3ZSBzdGlsbCBkbyBub3Qga25vdyB0aGUgaW1hZ2Ugc2l6ZVxuXHRcdC8vaG93IGxpbmVhciBvciBzcmdiIHNob3VsZCBiZSBzcGVjaWZpZWQgaGVyZS5cblx0XHQvL1x0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMLCBnbC5OT05FKTtcblx0XHRpZiAodGhpcy5zdGF0dXMgIT0gJ3JlYWR5JykvLyB8fCB0aGlzLnRpbGVzLnNpemUgPT0gMClcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0aWYgKCF0aGlzLnNoYWRlcilcblx0XHRcdHRocm93IFwiU2hhZGVyIG5vdCBzcGVjaWZpZWQhXCI7XG5cblx0XHRsZXQgZG9uZSA9IHRoaXMuaW50ZXJwb2xhdGVDb250cm9scygpO1xuXHRcdHRoaXMucHJlcGFyZVdlYkdMKCk7XG5cblx0XHQvL1x0XHRmaW5kIHdoaWNoIHF1YWRzIHRvIGRyYXcgYW5kIGluIGNhc2UgcmVxdWVzdCBmb3IgdGhlbVxuXHRcdGxldCBhdmFpbGFibGUgPSB0aGlzLmxheW91dC5hdmFpbGFibGUodmlld3BvcnQsIHRyYW5zZm9ybSwgdGhpcy50cmFuc2Zvcm0sIDAsIHRoaXMubWlwbWFwQmlhcywgdGhpcy50aWxlcyk7XG5cblx0XHR0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5jb21wb3NlKHRyYW5zZm9ybSk7XG5cdFx0bGV0IG1hdHJpeCA9IHRyYW5zZm9ybS5wcm9qZWN0aW9uTWF0cml4KHZpZXdwb3J0KTtcblx0XHR0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5zaGFkZXIubWF0cml4bG9jYXRpb24sIHRoaXMuZ2wuRkFMU0UsIG1hdHJpeCk7XG5cblx0XHR0aGlzLnVwZGF0ZUFsbFRpbGVCdWZmZXJzKGF2YWlsYWJsZSk7XG5cblx0XHRsZXQgaSA9IDA7XG5cdFx0Zm9yIChsZXQgdGlsZSBvZiBPYmplY3QudmFsdWVzKGF2YWlsYWJsZSkpIHtcblx0XHRcdC8vXHRcdFx0aWYodGlsZS5jb21wbGV0ZSlcblx0XHRcdHRoaXMuZHJhd1RpbGUodGlsZSwgaSk7XG5cdFx0XHQrK2k7XG5cdFx0fVxuXHRcdHJldHVybiBkb25lO1xuXHR9XG5cdFxuXHQvKiogQGlnbm9yZSAqL1xuXHRkcmF3VGlsZSh0aWxlLCBpbmRleCkge1xuXHRcdC8vbGV0IHRpbGVkYXRhID0gdGhpcy50aWxlcy5nZXQodGlsZS5pbmRleCk7XG5cdFx0aWYgKHRpbGUubWlzc2luZyAhPSAwKVxuXHRcdFx0dGhyb3cgXCJBdHRlbXB0IHRvIGRyYXcgdGlsZSBzdGlsbCBtaXNzaW5nIHRleHR1cmVzXCJcblxuXHRcdC8vY29vcmRzIGFuZCB0ZXh0dXJlIGJ1ZmZlcnMgdXBkYXRlZCBvbmNlIGZvciBhbGwgdGlsZXMgZnJvbSBtYWluIGRyYXcoKSBjYWxsXG5cblx0XHQvL2JpbmQgdGV4dHVyZXNcblx0XHRsZXQgZ2wgPSB0aGlzLmdsO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaGFkZXIuc2FtcGxlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBpZCA9IHRoaXMuc2hhZGVyLnNhbXBsZXJzW2ldLmlkO1xuXHRcdFx0Z2wudW5pZm9ybTFpKHRoaXMuc2hhZGVyLnNhbXBsZXJzW2ldLmxvY2F0aW9uLCBpKTtcblx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpKTtcblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRpbGUudGV4W2lkXSk7XG5cdFx0fVxuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gdGhpcy5nZXRUaWxlQnl0ZU9mZnNldChpbmRleCk7XG5cdFx0Z2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIGJ5dGVPZmZzZXQpO1xuXHR9XG5cblx0Z2V0VGlsZUJ5dGVPZmZzZXQoaW5kZXgpIHtcblx0XHRyZXR1cm4gaW5kZXggKiA2ICogMjtcblx0fVxuXG5cdC8qIGdpdmVuIHRoZSBmdWxsIHB5cmFtaWQgb2YgbmVlZGVkIHRpbGVzIGZvciBhIGNlcnRhaW4gYm91bmRpbmcgYm94LCBcblx0ICogIHN0YXJ0cyBmcm9tIHRoZSBwcmVmZXJyZWQgbGV2ZWxzIGFuZCBnb2VzIHVwIGluIHRoZSBoaWVyYXJjaHkgaWYgYSB0aWxlIGlzIG1pc3NpbmcuXG5cdCAqICBjb21wbGV0ZSBpcyB0cnVlIGlmIGFsbCBvZiB0aGUgJ2Jyb3RoZXJzJyBpbiB0aGUgaGllcmFyY2h5IGFyZSBsb2FkZWQsXG5cdCAqICBkcmF3aW5nIGluY29tcGxldGUgdGlsZXMgZW5oYW5jZSB0aGUgcmVzb2x1dGlvbiBlYXJseSBhdCB0aGUgY29zdCBvZiBzb21lIG92ZXJkcmF3aW5nIGFuZCBwcm9ibGVtcyB3aXRoIG9wYWNpdHkuXG5cdCAqL1xuXHQvKiogQGlnbm9yZSAqL1xuXHQvKnRvUmVuZGVyKG5lZWRlZCkge1xuXG5cdFx0bGV0IHRvcmVuZGVyID0ge307IC8vYXJyYXkgb2YgbWlubGV2ZWwsIGFjdHVhbCBsZXZlbCwgeCwgeSAocmVmZXJyZWQgdG8gbWlubGV2ZWwpXG5cdFx0bGV0IGJyb3RoZXJzID0ge307XG5cblx0XHRsZXQgbWlubGV2ZWwgPSBuZWVkZWQubGV2ZWw7XG5cdFx0bGV0IGJveCA9IG5lZWRlZC5weXJhbWlkW21pbmxldmVsXTtcblxuXHRcdGZvciAobGV0IHkgPSBib3gueUxvdzsgeSA8IGJveC55SGlnaDsgeSsrKSB7XG5cdFx0XHRmb3IgKGxldCB4ID0gYm94LnhMb3c7IHggPCBib3gueEhpZ2g7IHgrKykge1xuXHRcdFx0XHRsZXQgbGV2ZWwgPSBtaW5sZXZlbDtcblx0XHRcdFx0d2hpbGUgKGxldmVsID49IDApIHtcblx0XHRcdFx0XHRsZXQgZCA9IG1pbmxldmVsIC0gbGV2ZWw7XG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gdGhpcy5sYXlvdXQuaW5kZXgobGV2ZWwsIHggPj4gZCwgeSA+PiBkKTtcblx0XHRcdFx0XHRpZiAodGhpcy50aWxlcy5oYXMoaW5kZXgpICYmIHRoaXMudGlsZXMuZ2V0KGluZGV4KS5taXNzaW5nID09IDApIHtcblx0XHRcdFx0XHRcdHRvcmVuZGVyW2luZGV4XSA9IHRoaXMudGlsZXMuZ2V0KGluZGV4KTsgLy97IGluZGV4OiBpbmRleCwgbGV2ZWw6IGxldmVsLCB4OiB4ID4+IGQsIHk6IHkgPj4gZCwgY29tcGxldGU6IHRydWUgfTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsZXQgc3ggPSAoeCA+PiAoZCArIDEpKSA8PCAxO1xuXHRcdFx0XHRcdFx0bGV0IHN5ID0gKHkgPj4gKGQgKyAxKSkgPDwgMTtcblx0XHRcdFx0XHRcdGJyb3RoZXJzW3RoaXMubGF5b3V0LmluZGV4KGxldmVsLCBzeCwgc3kpXSA9IDE7XG5cdFx0XHRcdFx0XHRicm90aGVyc1t0aGlzLmxheW91dC5pbmRleChsZXZlbCwgc3ggKyAxLCBzeSldID0gMTtcblx0XHRcdFx0XHRcdGJyb3RoZXJzW3RoaXMubGF5b3V0LmluZGV4KGxldmVsLCBzeCArIDEsIHN5ICsgMSldID0gMTtcblx0XHRcdFx0XHRcdGJyb3RoZXJzW3RoaXMubGF5b3V0LmluZGV4KGxldmVsLCBzeCwgc3kgKyAxKV0gPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXZlbC0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGluZGV4IGluIGJyb3RoZXJzKSB7XG5cdFx0XHRpZiAoaW5kZXggaW4gdG9yZW5kZXIpXG5cdFx0XHRcdHRvcmVuZGVyW2luZGV4XS5jb21wbGV0ZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdG9yZW5kZXI7XG5cdH0qL1xuXG5cdC8qKiBAaWdub3JlICovXG5cdC8vIFVwZGF0ZSB0aWxlIHZlcnRleCBhbmQgdGV4dHVyZSBjb29yZHMuXG5cdC8vIEN1cnJlbnRseSBjYWxsZWQgYnkgZGVyaXZlZCBjbGFzc2VzIFxuXHR1cGRhdGVUaWxlQnVmZmVycyhjb29yZHMsIHRjb29yZHMpIHtcblx0XHRsZXQgZ2wgPSB0aGlzLmdsO1xuXHRcdC8vVE9ETyB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBjYWxscyAocHJvYmFibHkgbm90IG5lZWRlZCkgd2UgY2FuIGpvaW4gYnVmZmVycywgYW5kIGp1c3QgbWFrZSBvbmUgY2FsbCBwZXIgZHJhdyEgKGV4Y2VwdCB0aGUgYnVmZmVyRGF0YSwgd2hpY2ggaXMgcGVyIG5vZGUpXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGNvb3JkcywgZ2wuU1RBVElDX0RSQVcpO1xuXHRcdC8vRklYTUUgdGhpcyBpcyBub3QgbmVlZGVkIGV2ZXJ5IHRpbWUuXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5jb29yZGF0dHJpYiwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnNoYWRlci5jb29yZGF0dHJpYik7XG5cblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50YnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGNvb3JkcywgZ2wuU1RBVElDX0RSQVcpO1xuXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci50ZXhhdHRyaWIsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5zaGFkZXIudGV4YXR0cmliKTtcblx0fVxuXG5cdFxuXHQvKiogQGlnbm9yZSAqL1xuXHQvLyBVcGRhdGUgdGlsZSB2ZXJ0ZXggYW5kIHRleHR1cmUgY29vcmRzIG9mIGFsbCB0aGUgdGlsZXMgaW4gYSBzaW5nbGUgVkJPXG5cdHVwZGF0ZUFsbFRpbGVCdWZmZXJzKHRpbGVzKSB7XG5cdFx0bGV0IGdsID0gdGhpcy5nbDtcblxuXHRcdC8vdXNlIHRoaXMudGlsZXMgaW5zdGVhZC5cblx0XHRsZXQgTiA9IE9iamVjdC52YWx1ZXModGlsZXMpLmxlbmd0aDtcblx0XHRpZiAoTiA9PSAwKSByZXR1cm47XG5cdFx0XG5cdFx0Y29uc3Qgc3pWID0gMTI7XG5cdFx0Y29uc3Qgc3pUID0gODtcblx0XHRjb25zdCBzekkgPSA2O1xuXHRcdGNvbnN0IGlCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoc3pJICogTik7XG5cdFx0Y29uc3QgdkJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoc3pWICogTik7XG5cdFx0Y29uc3QgdEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoc3pUICogTik7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGZvciAobGV0IHRpbGUgb2YgT2JqZWN0LnZhbHVlcyh0aWxlcykpIHtcblx0XHRcdGxldCBjID0gdGhpcy5sYXlvdXQudGlsZUNvb3Jkcyh0aWxlKTtcblx0XHRcdHZCdWZmZXIuc2V0KGMuY29vcmRzLCBpICogc3pWKTtcblx0XHRcdHRCdWZmZXIuc2V0KGMudGNvb3JkcywgaSAqIHN6VCk7XG5cdFx0XHRcblx0XHRcdGNvbnN0IG9mZiA9IGkgKiA0O1xuXHRcdFx0dGlsZS5pbmRleEJ1ZmZlckJ5dGVPZmZzZXQgPSAyKmkqc3pJO1xuXHRcdFx0aUJ1ZmZlci5zZXQoW29mZiszLCBvZmYrMiwgb2ZmKzEsIG9mZiszLCBvZmYrMSwgb2ZmKzBdLCBpICogc3pJKTtcblx0XHRcdCsraTtcblx0XHR9XG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pYnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpQnVmZmVyLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52YnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdkJ1ZmZlciwgZ2wuU1RBVElDX0RSQVcpO1xuXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci5jb29yZGF0dHJpYiwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLnNoYWRlci5jb29yZGF0dHJpYik7XG5cblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50YnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdEJ1ZmZlciwgZ2wuU1RBVElDX0RSQVcpO1xuXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnNoYWRlci50ZXhhdHRyaWIsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5zaGFkZXIudGV4YXR0cmliKTtcblx0XHRcblx0fVxuXG5cdC8qXG5cdCAqICBJZiBsYXlvdXQgaXMgcmVhZHkgYW5kIHNoYWRlciBpcyBhc3NpZ25lZCwgY3JlYXRlcyBvciB1cGRhdGUgdGlsZXMgdG8ga2VlcCB0cmFjayBvZiB3aGF0IGlzIG1pc3NpbmcuXG5cdCAqL1xuXHQvKiogQGlnbm9yZSAqL1xuXHRzZXR1cFRpbGVzKCkge1xuXHRcdGlmICghdGhpcy5zaGFkZXIgfHwgIXRoaXMubGF5b3V0IHx8IHRoaXMubGF5b3V0LnN0YXR1cyAhPSAncmVhZHknKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Zm9yIChsZXQgdGlsZSBvZiB0aGlzLnRpbGVzKSB7XG5cdFx0XHR0aWxlLm1pc3NpbmcgPSB0aGlzLnNoYWRlci5zYW1wbGVycy5sZW5ndGg7XG5cdFx0XHRmb3IgKGxldCBzYW1wbGVyIG9mIHRoaXMuc2hhZGVyLnNhbXBsZXJzKSB7XG5cdFx0XHRcdGlmICh0aWxlLnRleFtzYW1wbGVyLmlkXSlcblx0XHRcdFx0XHR0aWxlLm1pc3NpbmctLTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRwcmVwYXJlV2ViR0woKSB7XG5cblx0XHRsZXQgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0aWYgKCF0aGlzLmlidWZmZXIpIHsgLy90aGlzIHBhcnQgbWlnaHQgZ28gaW50byBhbm90aGVyIGZ1bmN0aW9uLlxuXHRcdFx0dGhpcy5pYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmlidWZmZXIpO1xuXHRcdFx0Z2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KFszLCAyLCAxLCAzLCAxLCAwXSksIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdFx0dGhpcy52YnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy52YnVmZmVyKTtcblx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAwLCAxLCAwLCAxLCAxLCAwLCAxLCAwLCAwXSksIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdFx0dGhpcy50YnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50YnVmZmVyKTtcblx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAxLCAxLCAwXSksIGdsLlNUQVRJQ19EUkFXKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zaGFkZXIubmVlZHNVcGRhdGUpXG5cdFx0XHR0aGlzLnNoYWRlci5jcmVhdGVQcm9ncmFtKGdsKTtcblxuXHRcdGdsLnVzZVByb2dyYW0odGhpcy5zaGFkZXIucHJvZ3JhbSk7XG5cdFx0dGhpcy5zaGFkZXIudXBkYXRlVW5pZm9ybXMoZ2wsIHRoaXMuc2hhZGVyLnByb2dyYW0pO1xuXG5cblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHNhbWVOZWVkZWQoYSwgYikge1xuXHRcdGlmIChhLmxldmVsICE9IGIubGV2ZWwpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRmb3IgKGxldCBwIG9mIFsneExvdycsICd4SGlnaCcsICd5TG93JywgJ3lIaWdoJ10pXG5cdFx0XHRpZiAoYS5weXJhbWlkW2EubGV2ZWxdW3BdICE9IGIucHlyYW1pZFthLmxldmVsXVtwXSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRwcmVmZXRjaCh0cmFuc2Zvcm0sIHZpZXdwb3J0KSB7XG5cdFx0aWYgKHRoaXMubGF5ZXJzLmxlbmd0aCAhPSAwKSB7IC8vY29tYmluZSBsYXllcnNcblx0XHRcdGZvciAobGV0IGxheWVyIG9mIHRoaXMubGF5ZXJzKVxuXHRcdFx0XHRsYXllci5wcmVmZXRjaCh0cmFuc2Zvcm0sIHZpZXdwb3J0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5yYXN0ZXJzLmxlbmd0aCA9PSAwKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYgKHRoaXMuc3RhdHVzICE9ICdyZWFkeScpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRpZiAodHlwZW9mICh0aGlzLmxheW91dCkgIT0gJ29iamVjdCcpXG5cdFx0XHR0aHJvdyBcIkFIIVwiO1xuXG5cdFx0LypsZXQgbmVlZGVkID0gdGhpcy5sYXlvdXQubmVlZGVkKHZpZXdwb3J0LCB0cmFuc2Zvcm0sIHRoaXMucHJlZmV0Y2hCb3JkZXIsIHRoaXMubWlwbWFwQmlhcywgdGhpcy50aWxlcyk7XG5cblxuXHRcdHRoaXMucXVldWUgPSBbXTtcblx0XHRsZXQgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0bGV0IG1pc3NpbmcgPSB0aGlzLnNoYWRlci5zYW1wbGVycy5sZW5ndGg7XG5cblxuXHRcdGZvcihsZXQgdGlsZSBvZiBuZWVkZWQpIHtcblx0XHRcdGlmKHRpbGUubWlzc2luZyA9PT0gbnVsbClcblx0XHRcdFx0dGlsZS5taXNzaW5nID0gbWlzc2luZztcblx0XHRcdGlmICh0aWxlLm1pc3NpbmcgIT0gMCAmJiAhdGhpcy5yZXF1ZXN0ZWRbaW5kZXhdKVxuXHRcdFx0XHR0bXAucHVzaCh0aWxlKTtcblx0XHR9ICovXG5cdFx0dGhpcy5xdWV1ZSA9IHRoaXMubGF5b3V0Lm5lZWRlZCh2aWV3cG9ydCwgdHJhbnNmb3JtLCB0aGlzLnRyYW5zZm9ybSwgdGhpcy5wcmVmZXRjaEJvcmRlciwgdGhpcy5taXBtYXBCaWFzLCB0aGlzLnRpbGVzKTtcblx0XHQvKlx0XHRsZXQgbmVlZGVkID0gdGhpcy5sYXlvdXQubmVlZGVkQm94KHZpZXdwb3J0LCB0cmFuc2Zvcm0sIHRoaXMucHJlZmV0Y2hCb3JkZXIsIHRoaXMubWlwbWFwQmlhcyk7XG5cdFx0XHRcdGlmICh0aGlzLnByZXZpb3VzbHlOZWVkZWQgJiYgdGhpcy5zYW1lTmVlZGVkKHRoaXMucHJldmlvdXNseU5lZWRlZCwgbmVlZGVkKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdHRoaXMucHJldmlvdXNseU5lZWRlZCA9IG5lZWRlZDtcblx0XHRcblx0XHRcdFx0dGhpcy5xdWV1ZSA9IFtdO1xuXHRcdFx0XHRsZXQgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHRcdC8vbG9vayBmb3IgbmVlZGVkIG5vZGVzIGFuZCBwcmVmZXRjaGVkIG5vZGVzIChvbiB0aGUgcG9zIGRlc3RpbmF0aW9uXG5cdFx0XHRcdGxldCBtaXNzaW5nID0gdGhpcy5zaGFkZXIuc2FtcGxlcnMubGVuZ3RoO1xuXHRcdFxuXHRcdFx0XHRmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDw9IG5lZWRlZC5sZXZlbDsgbGV2ZWwrKykge1xuXHRcdFx0XHRcdGxldCBib3ggPSBuZWVkZWQucHlyYW1pZFtsZXZlbF07XG5cdFx0XHRcdFx0bGV0IHRtcCA9IFtdO1xuXHRcdFx0XHRcdGZvciAobGV0IHkgPSBib3gueUxvdzsgeSA8IGJveC55SGlnaDsgeSsrKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCB4ID0gYm94LnhMb3c7IHggPCBib3gueEhpZ2g7IHgrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQgaW5kZXggPSB0aGlzLmxheW91dC5pbmRleChsZXZlbCwgeCwgeSk7XG5cdFx0XHRcdFx0XHRcdGxldCB0aWxlID0gdGhpcy50aWxlcy5nZXQoaW5kZXgpIHx8IHsgaW5kZXgsIHgsIHksIG1pc3NpbmcsIHRleDogW10sIGxldmVsIH07XG5cdFx0XHRcdFx0XHRcdHRpbGUudGltZSA9IG5vdztcblx0XHRcdFx0XHRcdFx0dGlsZS5wcmlvcml0eSA9IG5lZWRlZC5sZXZlbCAtIGxldmVsO1xuXHRcdFx0XHRcdFx0XHRpZiAodGlsZS5taXNzaW5nICE9IDAgJiYgIXRoaXMucmVxdWVzdGVkW2luZGV4XSlcblx0XHRcdFx0XHRcdFx0XHR0bXAucHVzaCh0aWxlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGMgPSBib3guY2VudGVyKCk7XG5cdFx0XHRcdFx0Ly9zb3J0IHRpbGVzIGJ5IGRpc3RhbmNlIHRvIHRoZSBjZW50ZXIgVE9ETzogY2hlY2sgaXQncyBjb3JyZWN0IVxuXHRcdFx0XHRcdHRtcC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLmFicyhhLnggLSBjWzBdKSArIE1hdGguYWJzKGEueSAtIGNbMV0pIC0gTWF0aC5hYnMoYi54IC0gY1swXSkgLSBNYXRoLmFicyhiLnkgLSBjWzFdKTsgfSk7XG5cdFx0XHRcdFx0dGhpcy5xdWV1ZSA9IHRoaXMucXVldWUuY29uY2F0KHRtcCk7XG5cdFx0XHRcdH0qL1xuXHRcdENhY2hlLnNldENhbmRpZGF0ZXModGhpcyk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRhc3luYyBsb2FkVGlsZSh0aWxlLCBjYWxsYmFjaykge1xuXHRcdGlmICh0aGlzLnRpbGVzLmhhcyh0aWxlLmluZGV4KSlcblx0XHRcdHRocm93IFwiQUFBUlJHR0hISCBkb3VibGUgdGlsZSFcIjtcblxuXHRcdGlmICh0aGlzLnJlcXVlc3RlZFt0aWxlLmluZGV4XSlcblx0XHRcdHRocm93IFwiQUFBUlJHR0hISCBkb3VibGUgcmVxdWVzdCFcIjtcblxuXHRcdHRoaXMudGlsZXMuc2V0KHRpbGUuaW5kZXgsIHRpbGUpO1xuXHRcdHRoaXMucmVxdWVzdGVkW3RpbGUuaW5kZXhdID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLmxheW91dC50eXBlID09ICdpdGFyem9vbScpIHtcblx0XHRcdHRpbGUudXJsID0gdGhpcy5sYXlvdXQuZ2V0VGlsZVVSTChudWxsLCB0aWxlKTtcblx0XHRcdGxldCBvcHRpb25zID0ge307XG5cdFx0XHRpZiAodGlsZS5lbmQpXG5cdFx0XHRcdG9wdGlvbnMuaGVhZGVycyA9IHsgcmFuZ2U6IGBieXRlcz0ke3RpbGUuc3RhcnR9LSR7dGlsZS5lbmR9YCwgJ0FjY2VwdC1FbmNvZGluZyc6ICdpbmRlbnRpdHknIH1cblxuXHRcdFx0dmFyIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGlsZS51cmwsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKCFyZXNwb25zZS5vaykge1xuXHRcdFx0XHRjYWxsYmFjayhcIkZhaWxlZCBsb2FkaW5nIFwiICsgdGlsZS51cmwgKyBcIjogXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG5cblx0XHRcdGxldCBpID0gMDtcblx0XHRcdGZvciAobGV0IHNhbXBsZXIgb2YgdGhpcy5zaGFkZXIuc2FtcGxlcnMpIHtcblx0XHRcdFx0bGV0IHJhc3RlciA9IHRoaXMucmFzdGVyc1tzYW1wbGVyLmlkXTtcblx0XHRcdFx0bGV0IGltZ2Jsb2IgPSBibG9iLnNsaWNlKHRpbGUub2Zmc2V0c1tpXSwgdGlsZS5vZmZzZXRzW2kgKyAxXSk7XG5cdFx0XHRcdGNvbnN0IGltZyA9IGF3YWl0IHJhc3Rlci5ibG9iVG9JbWFnZShpbWdibG9iLCB0aGlzLmdsKTtcblx0XHRcdFx0bGV0IHRleCA9IHJhc3Rlci5sb2FkVGV4dHVyZSh0aGlzLmdsLCBpbWcpO1xuXHRcdFx0XHRsZXQgc2l6ZSA9IGltZy53aWR0aCAqIGltZy5oZWlnaHQgKiAzO1xuXHRcdFx0XHR0aWxlLnNpemUgKz0gc2l6ZTtcblx0XHRcdFx0dGlsZS50ZXhbc2FtcGxlci5pZF0gPSB0ZXg7XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblx0XHRcdHRpbGUubWlzc2luZyA9IDA7XG5cdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuXHRcdFx0ZGVsZXRlIHRoaXMucmVxdWVzdGVkW3RpbGUuaW5kZXhdO1xuXHRcdFx0aWYgKGNhbGxiYWNrKSBjYWxsYmFjayh0aWxlLnNpemUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aWxlLm1pc3NpbmcgPSB0aGlzLnNoYWRlci5zYW1wbGVycy5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgc2FtcGxlciBvZiB0aGlzLnNoYWRlci5zYW1wbGVycykge1xuXG5cdFx0XHRsZXQgcmFzdGVyID0gdGhpcy5yYXN0ZXJzW3NhbXBsZXIuaWRdO1xuXHRcdFx0dGlsZS51cmwgPSB0aGlzLmxheW91dC5nZXRUaWxlVVJMKHNhbXBsZXIuaWQsIHRpbGUpO1xuXHRcdFx0Y29uc3QgW3RleCwgc2l6ZV0gPSBhd2FpdCByYXN0ZXIubG9hZEltYWdlKHRpbGUsIHRoaXMuZ2wpOyAvLyBUT0RPIFBhcmFsbGVsaXplIHJlcXVlc3QgYW5kIHVybCBtdXN0IGJlIGEgcGFyYW1ldGVyIChpbXBsZW1lbnQgcmVxdWVzdCBxdWVzIHBlciB1cmwpXG5cdFx0XHRpZiAodGhpcy5sYXlvdXQudHlwZSA9PSBcImltYWdlXCIpIHtcblx0XHRcdFx0dGhpcy5sYXlvdXQud2lkdGggPSByYXN0ZXIud2lkdGg7XG5cdFx0XHRcdHRoaXMubGF5b3V0LmhlaWdodCA9IHJhc3Rlci5oZWlnaHQ7XG5cdFx0XHRcdHRoaXMubGF5b3V0LmVtaXQoJ3VwZGF0ZVNpemUnKTtcblx0XHRcdH1cblx0XHRcdHRpbGUuc2l6ZSArPSBzaXplO1xuXHRcdFx0dGlsZS50ZXhbc2FtcGxlci5pZF0gPSB0ZXg7XG5cdFx0XHR0aWxlLm1pc3NpbmctLTtcblx0XHRcdGlmICh0aWxlLm1pc3NpbmcgPD0gMCkge1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5yZXF1ZXN0ZWRbdGlsZS5pbmRleF07XG5cdFx0XHRcdGlmIChjYWxsYmFjaykgY2FsbGJhY2soc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbkxheWVyLnByb3RvdHlwZS50eXBlcyA9IHt9XG5hZGRTaWduYWxzKExheWVyLCAndXBkYXRlJywgJ3JlYWR5JywgJ3VwZGF0ZVNpemUnKTtcblxuZXhwb3J0IHsgTGF5ZXIgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Layer.js\n");

/***/ }),

/***/ "./src/LayerAnnotation.js":
/*!********************************!*\
  !*** ./src/LayerAnnotation.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayerAnnotation\": () => (/* binding */ LayerAnnotation)\n/* harmony export */ });\n/* harmony import */ var _Annotation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Annotation.js */ \"./src/Annotation.js\");\n/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ \"./src/Layer.js\");\n/* harmony import */ var _Signals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Signals.js */ \"./src/Signals.js\");\n\n\n\n\n/**\n * An annotation layer is a layer used to display decorations (text, graphics elements, glyphs, etc...) on top of other layers.\n * Its purpose is to provide additional information useful for the interpretation of the underlying layers.\n * An object literal with `options` can be specified.\n * \n * Here you will find a tutorial to learn how to build a client-server architecture to manage annotations in OpenLIME. //FIXME\n * \n * Extends {@link Layer}.\n */\nclass LayerAnnotation extends _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer { //FIXME CustomData Object template {name: { label: defaultValue: type:number,enum,string,boolean min: max: enum:[] }}\n\t/**\n\t * Instantiates a LayerAnnotation object.\n\t * @param {Object} [options] An object literal with options that inherits from {@link Layer}.\n\t * @param {string} options.style Properties to style annotations.\n \t * @param {(string|Array)} options.annotations The URL of the annotation data (JSON file or HTTP GET Request to an annotation server) or an array of annotations.\n\t */\n\tconstructor(options) {\n\t\toptions = Object.assign({\n\t\t\t// geometry: null,  //unused, might want to store here the quads/shapes for opengl rendering\n\t\t\tstyle: null,    //straightforward for svg annotations, to be defined or opengl rendering\n\t\t\tannotations: [],\n\t\t\tselected: new Set,\n\t\t\toverlay: true,\n\t\t\tannotationsListEntry: null, //TODO: horrible name for the interface list of annotations\n\t\t}, options);\n\t\tsuper(options);\n\n\t\tif (typeof (this.annotations) == \"string\") { //assumes it is an URL\n\t\t\t(async () => { await this.loadAnnotations(this.annotations); })();\n\t\t}\n\t}\n\n\t/** @ignore */\n\tasync loadAnnotations(url) {\n\t\tconst headers = new Headers();\n\t\theaders.append('pragma', 'no-cache');\n\t\theaders.append('cache-control', 'no-cache');\n\t\tvar response = await fetch(url, {\n\t\t\tmethod: 'GET',\n\t\t\theaders: headers,\n\t  \t});\n\t\tif(!response.ok) {\n\t\t\tthis.status = \"Failed loading \" + this.url + \": \" + response.statusText;\n\t\t\treturn;\n\t\t}\n\t\tthis.annotations = await response.json();\n\t\tif(this.annotations.status == 'error') {\n\t\t\talert(\"Failed to load annotations: \" + this.annotations.msg);\n\t\t\treturn;\n\t\t}\n\t\t//this.annotations = this.annotations.map(a => '@context' in a ? Annotation.fromJsonLd(a): a);\n\t\tthis.annotations = this.annotations.map(a => new _Annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation(a));\n\t\tfor(let a of this.annotations)\n\t\t\tif(a.publish != 1)\n\t\t\t\ta.visible = false;\n\t\t//this.annotations.sort((a, b) => a.label.localeCompare(b.label));\n\t\tif(this.annotationsListEntry)\n\t\t\tthis.createAnnotationsList();\n\t\t\n\t\tthis.emit('update');\n\t\tthis.emit('ready');\n\t\tthis.emit('loaded');\n\t}\n\n\t/** @ignore */\n\tnewAnnotation(annotation) {\n\t\tif(!annotation)\n\t\t\tannotation = new _Annotation_js__WEBPACK_IMPORTED_MODULE_0__.Annotation();\n\n\t\tthis.annotations.push(annotation);\n\t\tlet html = this.createAnnotationEntry(annotation);\n\t\tlet template = document.createElement('template');\n\t\ttemplate.innerHTML = html.trim();\n\t\t\n\t\tlet list =  this.annotationsListEntry.element.parentElement.querySelector('.openlime-list');\n\t\tlist.appendChild(template.content.firstChild);\n\t\t\n\t\tthis.clearSelected();\n\t\t//this.setSelected(annotation);\n\t\treturn annotation;\n\t}\n\n\t/** @ignore */\n\tannotationsEntry() {\n\t\treturn this.annotationsListEntry =  {\n\t\t\thtml: '',\n\t\t\tlist: [], //will be filled later.\n\t\t\tclasses: 'openlime-annotations',\n\t\t\tstatus: () => 'active',\n\t\t\toncreate: () => { \n\t\t\t\tif(Array.isArray(this.annotations))\n\t\t\t\t\tthis.createAnnotationsList();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @ignore */\n\tcreateAnnotationsList() {\n\t\tlet html ='';\n\t\tfor(let a of this.annotations) {\n\t\t\thtml += this.createAnnotationEntry(a);\n\t\t}\n\n\t\tlet list =  this.annotationsListEntry.element.parentElement.querySelector('.openlime-list');\n\t\tlist.innerHTML = html;\n\t\tlist.addEventListener('click', (e) =>  { \n\t\t\tlet svg = e.srcElement.closest('svg');\n\t\t\tif(svg) {\n\t\t\t\tlet entry = svg.closest('[data-annotation]')\n\t\t\t\tentry.classList.toggle('hidden');\n\t\t\t\tlet id = entry.getAttribute('data-annotation');\n\t\t\t\tlet anno = this.getAnnotationById(id);\n\t\t\t\tanno.visible = !anno.visible;\n\t\t\t\tanno.needsUpdate = true;\n\t\t\t\tthis.emit('update');\n\t\t\t}\n\n\t\t\tlet id = e.srcElement.getAttribute('data-annotation');\n\t\t\tif(id) {\n\t\t\t\tthis.clearSelected();\n\t\t\t\tlet anno = this.getAnnotationById(id);\n\t\t\t\tthis.setSelected(anno, true);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @ignore */\n\tcreateAnnotationEntry(a) {\n\t\treturn `<a href=\"#\" data-annotation=\"${a.id}\" class=\"openlime-entry ${a.visible == 0? 'hidden':''}\">${a.label || ''}\n\t\t\t<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"openlime-eye\"><path d=\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\"></path><circle cx=\"12\" cy=\"12\" r=\"3\"></circle></svg>\n\t\t\t<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"openlime-eye-off\"><path d=\"M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24\"></path><line x1=\"1\" y1=\"1\" x2=\"23\" y2=\"23\"></line></svg>\n\t\t\t</a>`;\n\t}\n\n\t/**\n\t * Gets an annotation by its `id`\n\t * @param {string} id \n\t * @returns {Annotation} The annotation.\n\t */\n\tgetAnnotationById(id) {\n\t\tfor(const anno of this.annotations)\n\t\t\tif(anno.id == id)\n\t\t\t\treturn anno;\n\t\treturn null;\n\t}\n\n\t/** @ignore */\n\tclearSelected() {\n\t\tthis.annotationsListEntry.element.parentElement.querySelectorAll(`[data-annotation]`).forEach((e) => e.classList.remove('selected'));\n\t\tthis.selected.clear();\n\t}\n\n\t/**\n\t * Selects/deselects an annotation\n\t * @param {Annotation} anno The annotation.\n\t * @param {bool} on=true Whether to select the annotation.\n\t */\n\tsetSelected(anno, on = true) {\n\t\tthis.annotationsListEntry.element.parentElement.querySelector(`[data-annotation=\"${anno.id}\"]`).classList.toggle('selected', on);\n\t\tif(on)\n\t\t\tthis.selected.add(anno.id);\n\t\telse\n\t\t\tthis.selected.delete(anno.id);\n\t\tthis.emit('selected', anno);\n\t}\n}\n\n(0,_Signals_js__WEBPACK_IMPORTED_MODULE_2__.addSignals)(LayerAnnotation, 'selected', 'loaded');\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGF5ZXJBbm5vdGF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkM7QUFDWDtBQUNROztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLDhCQUE4Qiw0Q0FBSyxHQUFHLG9DQUFvQyxRQUFRO0FBQ2xGO0FBQ0E7QUFDQSxZQUFZLFFBQVEsNkRBQTZELFlBQVk7QUFDN0YsWUFBWSxRQUFRO0FBQ3BCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSwrQ0FBK0M7QUFDL0Msa0JBQWtCLCtDQUErQztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0RBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSywwQkFBMEIsNEJBQTRCLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0EscUZBQXFGLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQVU7QUFDZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9MYXllckFubm90YXRpb24uanM/ZGYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uIH0gZnJvbSAnLi9Bbm5vdGF0aW9uLmpzJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi9MYXllci5qcydcbmltcG9ydCB7IGFkZFNpZ25hbHMgfSBmcm9tICcuL1NpZ25hbHMuanMnO1xuXG4vKipcbiAqIEFuIGFubm90YXRpb24gbGF5ZXIgaXMgYSBsYXllciB1c2VkIHRvIGRpc3BsYXkgZGVjb3JhdGlvbnMgKHRleHQsIGdyYXBoaWNzIGVsZW1lbnRzLCBnbHlwaHMsIGV0Yy4uLikgb24gdG9wIG9mIG90aGVyIGxheWVycy5cbiAqIEl0cyBwdXJwb3NlIGlzIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB1c2VmdWwgZm9yIHRoZSBpbnRlcnByZXRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBsYXllcnMuXG4gKiBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBvcHRpb25zYCBjYW4gYmUgc3BlY2lmaWVkLlxuICogXG4gKiBIZXJlIHlvdSB3aWxsIGZpbmQgYSB0dXRvcmlhbCB0byBsZWFybiBob3cgdG8gYnVpbGQgYSBjbGllbnQtc2VydmVyIGFyY2hpdGVjdHVyZSB0byBtYW5hZ2UgYW5ub3RhdGlvbnMgaW4gT3BlbkxJTUUuIC8vRklYTUVcbiAqIFxuICogRXh0ZW5kcyB7QGxpbmsgTGF5ZXJ9LlxuICovXG5jbGFzcyBMYXllckFubm90YXRpb24gZXh0ZW5kcyBMYXllciB7IC8vRklYTUUgQ3VzdG9tRGF0YSBPYmplY3QgdGVtcGxhdGUge25hbWU6IHsgbGFiZWw6IGRlZmF1bHRWYWx1ZTogdHlwZTpudW1iZXIsZW51bSxzdHJpbmcsYm9vbGVhbiBtaW46IG1heDogZW51bTpbXSB9fVxuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgTGF5ZXJBbm5vdGF0aW9uIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIG9wdGlvbnMgdGhhdCBpbmhlcml0cyBmcm9tIHtAbGluayBMYXllcn0uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN0eWxlIFByb3BlcnRpZXMgdG8gc3R5bGUgYW5ub3RhdGlvbnMuXG4gXHQgKiBAcGFyYW0geyhzdHJpbmd8QXJyYXkpfSBvcHRpb25zLmFubm90YXRpb25zIFRoZSBVUkwgb2YgdGhlIGFubm90YXRpb24gZGF0YSAoSlNPTiBmaWxlIG9yIEhUVFAgR0VUIFJlcXVlc3QgdG8gYW4gYW5ub3RhdGlvbiBzZXJ2ZXIpIG9yIGFuIGFycmF5IG9mIGFubm90YXRpb25zLlxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdC8vIGdlb21ldHJ5OiBudWxsLCAgLy91bnVzZWQsIG1pZ2h0IHdhbnQgdG8gc3RvcmUgaGVyZSB0aGUgcXVhZHMvc2hhcGVzIGZvciBvcGVuZ2wgcmVuZGVyaW5nXG5cdFx0XHRzdHlsZTogbnVsbCwgICAgLy9zdHJhaWdodGZvcndhcmQgZm9yIHN2ZyBhbm5vdGF0aW9ucywgdG8gYmUgZGVmaW5lZCBvciBvcGVuZ2wgcmVuZGVyaW5nXG5cdFx0XHRhbm5vdGF0aW9uczogW10sXG5cdFx0XHRzZWxlY3RlZDogbmV3IFNldCxcblx0XHRcdG92ZXJsYXk6IHRydWUsXG5cdFx0XHRhbm5vdGF0aW9uc0xpc3RFbnRyeTogbnVsbCwgLy9UT0RPOiBob3JyaWJsZSBuYW1lIGZvciB0aGUgaW50ZXJmYWNlIGxpc3Qgb2YgYW5ub3RhdGlvbnNcblx0XHR9LCBvcHRpb25zKTtcblx0XHRzdXBlcihvcHRpb25zKTtcblxuXHRcdGlmICh0eXBlb2YgKHRoaXMuYW5ub3RhdGlvbnMpID09IFwic3RyaW5nXCIpIHsgLy9hc3N1bWVzIGl0IGlzIGFuIFVSTFxuXHRcdFx0KGFzeW5jICgpID0+IHsgYXdhaXQgdGhpcy5sb2FkQW5ub3RhdGlvbnModGhpcy5hbm5vdGF0aW9ucyk7IH0pKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0YXN5bmMgbG9hZEFubm90YXRpb25zKHVybCkge1xuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuXHRcdGhlYWRlcnMuYXBwZW5kKCdwcmFnbWEnLCAnbm8tY2FjaGUnKTtcblx0XHRoZWFkZXJzLmFwcGVuZCgnY2FjaGUtY29udHJvbCcsICduby1jYWNoZScpO1xuXHRcdHZhciByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuXHRcdFx0bWV0aG9kOiAnR0VUJyxcblx0XHRcdGhlYWRlcnM6IGhlYWRlcnMsXG5cdCAgXHR9KTtcblx0XHRpZighcmVzcG9uc2Uub2spIHtcblx0XHRcdHRoaXMuc3RhdHVzID0gXCJGYWlsZWQgbG9hZGluZyBcIiArIHRoaXMudXJsICsgXCI6IFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5hbm5vdGF0aW9ucyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblx0XHRpZih0aGlzLmFubm90YXRpb25zLnN0YXR1cyA9PSAnZXJyb3InKSB7XG5cdFx0XHRhbGVydChcIkZhaWxlZCB0byBsb2FkIGFubm90YXRpb25zOiBcIiArIHRoaXMuYW5ub3RhdGlvbnMubXNnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Ly90aGlzLmFubm90YXRpb25zID0gdGhpcy5hbm5vdGF0aW9ucy5tYXAoYSA9PiAnQGNvbnRleHQnIGluIGEgPyBBbm5vdGF0aW9uLmZyb21Kc29uTGQoYSk6IGEpO1xuXHRcdHRoaXMuYW5ub3RhdGlvbnMgPSB0aGlzLmFubm90YXRpb25zLm1hcChhID0+IG5ldyBBbm5vdGF0aW9uKGEpKTtcblx0XHRmb3IobGV0IGEgb2YgdGhpcy5hbm5vdGF0aW9ucylcblx0XHRcdGlmKGEucHVibGlzaCAhPSAxKVxuXHRcdFx0XHRhLnZpc2libGUgPSBmYWxzZTtcblx0XHQvL3RoaXMuYW5ub3RhdGlvbnMuc29ydCgoYSwgYikgPT4gYS5sYWJlbC5sb2NhbGVDb21wYXJlKGIubGFiZWwpKTtcblx0XHRpZih0aGlzLmFubm90YXRpb25zTGlzdEVudHJ5KVxuXHRcdFx0dGhpcy5jcmVhdGVBbm5vdGF0aW9uc0xpc3QoKTtcblx0XHRcblx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuXHRcdHRoaXMuZW1pdCgncmVhZHknKTtcblx0XHR0aGlzLmVtaXQoJ2xvYWRlZCcpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0bmV3QW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG5cdFx0aWYoIWFubm90YXRpb24pXG5cdFx0XHRhbm5vdGF0aW9uID0gbmV3IEFubm90YXRpb24oKTtcblxuXHRcdHRoaXMuYW5ub3RhdGlvbnMucHVzaChhbm5vdGF0aW9uKTtcblx0XHRsZXQgaHRtbCA9IHRoaXMuY3JlYXRlQW5ub3RhdGlvbkVudHJ5KGFubm90YXRpb24pO1xuXHRcdGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5cdFx0dGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbC50cmltKCk7XG5cdFx0XG5cdFx0bGV0IGxpc3QgPSAgdGhpcy5hbm5vdGF0aW9uc0xpc3RFbnRyeS5lbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLWxpc3QnKTtcblx0XHRsaXN0LmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG5cdFx0XG5cdFx0dGhpcy5jbGVhclNlbGVjdGVkKCk7XG5cdFx0Ly90aGlzLnNldFNlbGVjdGVkKGFubm90YXRpb24pO1xuXHRcdHJldHVybiBhbm5vdGF0aW9uO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0YW5ub3RhdGlvbnNFbnRyeSgpIHtcblx0XHRyZXR1cm4gdGhpcy5hbm5vdGF0aW9uc0xpc3RFbnRyeSA9ICB7XG5cdFx0XHRodG1sOiAnJyxcblx0XHRcdGxpc3Q6IFtdLCAvL3dpbGwgYmUgZmlsbGVkIGxhdGVyLlxuXHRcdFx0Y2xhc3NlczogJ29wZW5saW1lLWFubm90YXRpb25zJyxcblx0XHRcdHN0YXR1czogKCkgPT4gJ2FjdGl2ZScsXG5cdFx0XHRvbmNyZWF0ZTogKCkgPT4geyBcblx0XHRcdFx0aWYoQXJyYXkuaXNBcnJheSh0aGlzLmFubm90YXRpb25zKSlcblx0XHRcdFx0XHR0aGlzLmNyZWF0ZUFubm90YXRpb25zTGlzdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGNyZWF0ZUFubm90YXRpb25zTGlzdCgpIHtcblx0XHRsZXQgaHRtbCA9Jyc7XG5cdFx0Zm9yKGxldCBhIG9mIHRoaXMuYW5ub3RhdGlvbnMpIHtcblx0XHRcdGh0bWwgKz0gdGhpcy5jcmVhdGVBbm5vdGF0aW9uRW50cnkoYSk7XG5cdFx0fVxuXG5cdFx0bGV0IGxpc3QgPSAgdGhpcy5hbm5vdGF0aW9uc0xpc3RFbnRyeS5lbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLWxpc3QnKTtcblx0XHRsaXN0LmlubmVySFRNTCA9IGh0bWw7XG5cdFx0bGlzdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiAgeyBcblx0XHRcdGxldCBzdmcgPSBlLnNyY0VsZW1lbnQuY2xvc2VzdCgnc3ZnJyk7XG5cdFx0XHRpZihzdmcpIHtcblx0XHRcdFx0bGV0IGVudHJ5ID0gc3ZnLmNsb3Nlc3QoJ1tkYXRhLWFubm90YXRpb25dJylcblx0XHRcdFx0ZW50cnkuY2xhc3NMaXN0LnRvZ2dsZSgnaGlkZGVuJyk7XG5cdFx0XHRcdGxldCBpZCA9IGVudHJ5LmdldEF0dHJpYnV0ZSgnZGF0YS1hbm5vdGF0aW9uJyk7XG5cdFx0XHRcdGxldCBhbm5vID0gdGhpcy5nZXRBbm5vdGF0aW9uQnlJZChpZCk7XG5cdFx0XHRcdGFubm8udmlzaWJsZSA9ICFhbm5vLnZpc2libGU7XG5cdFx0XHRcdGFubm8ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaWQgPSBlLnNyY0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWFubm90YXRpb24nKTtcblx0XHRcdGlmKGlkKSB7XG5cdFx0XHRcdHRoaXMuY2xlYXJTZWxlY3RlZCgpO1xuXHRcdFx0XHRsZXQgYW5ubyA9IHRoaXMuZ2V0QW5ub3RhdGlvbkJ5SWQoaWQpO1xuXHRcdFx0XHR0aGlzLnNldFNlbGVjdGVkKGFubm8sIHRydWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0Y3JlYXRlQW5ub3RhdGlvbkVudHJ5KGEpIHtcblx0XHRyZXR1cm4gYDxhIGhyZWY9XCIjXCIgZGF0YS1hbm5vdGF0aW9uPVwiJHthLmlkfVwiIGNsYXNzPVwib3BlbmxpbWUtZW50cnkgJHthLnZpc2libGUgPT0gMD8gJ2hpZGRlbic6Jyd9XCI+JHthLmxhYmVsIHx8ICcnfVxuXHRcdFx0PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGNsYXNzPVwib3BlbmxpbWUtZXllXCI+PHBhdGggZD1cIk0xIDEyczQtOCAxMS04IDExIDggMTEgOC00IDgtMTEgOC0xMS04LTExLTh6XCI+PC9wYXRoPjxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiM1wiPjwvY2lyY2xlPjwvc3ZnPlxuXHRcdFx0PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGNsYXNzPVwib3BlbmxpbWUtZXllLW9mZlwiPjxwYXRoIGQ9XCJNMTcuOTQgMTcuOTRBMTAuMDcgMTAuMDcgMCAwIDEgMTIgMjBjLTcgMC0xMS04LTExLThhMTguNDUgMTguNDUgMCAwIDEgNS4wNi01Ljk0TTkuOSA0LjI0QTkuMTIgOS4xMiAwIDAgMSAxMiA0YzcgMCAxMSA4IDExIDhhMTguNSAxOC41IDAgMCAxLTIuMTYgMy4xOW0tNi43Mi0xLjA3YTMgMyAwIDEgMS00LjI0LTQuMjRcIj48L3BhdGg+PGxpbmUgeDE9XCIxXCIgeTE9XCIxXCIgeDI9XCIyM1wiIHkyPVwiMjNcIj48L2xpbmU+PC9zdmc+XG5cdFx0XHQ8L2E+YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFuIGFubm90YXRpb24gYnkgaXRzIGBpZGBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIFxuXHQgKiBAcmV0dXJucyB7QW5ub3RhdGlvbn0gVGhlIGFubm90YXRpb24uXG5cdCAqL1xuXHRnZXRBbm5vdGF0aW9uQnlJZChpZCkge1xuXHRcdGZvcihjb25zdCBhbm5vIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG5cdFx0XHRpZihhbm5vLmlkID09IGlkKVxuXHRcdFx0XHRyZXR1cm4gYW5ubztcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGNsZWFyU2VsZWN0ZWQoKSB7XG5cdFx0dGhpcy5hbm5vdGF0aW9uc0xpc3RFbnRyeS5lbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtYW5ub3RhdGlvbl1gKS5mb3JFYWNoKChlKSA9PiBlLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpO1xuXHRcdHRoaXMuc2VsZWN0ZWQuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWxlY3RzL2Rlc2VsZWN0cyBhbiBhbm5vdGF0aW9uXG5cdCAqIEBwYXJhbSB7QW5ub3RhdGlvbn0gYW5ubyBUaGUgYW5ub3RhdGlvbi5cblx0ICogQHBhcmFtIHtib29sfSBvbj10cnVlIFdoZXRoZXIgdG8gc2VsZWN0IHRoZSBhbm5vdGF0aW9uLlxuXHQgKi9cblx0c2V0U2VsZWN0ZWQoYW5ubywgb24gPSB0cnVlKSB7XG5cdFx0dGhpcy5hbm5vdGF0aW9uc0xpc3RFbnRyeS5lbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtYW5ub3RhdGlvbj1cIiR7YW5uby5pZH1cIl1gKS5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcsIG9uKTtcblx0XHRpZihvbilcblx0XHRcdHRoaXMuc2VsZWN0ZWQuYWRkKGFubm8uaWQpO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuc2VsZWN0ZWQuZGVsZXRlKGFubm8uaWQpO1xuXHRcdHRoaXMuZW1pdCgnc2VsZWN0ZWQnLCBhbm5vKTtcblx0fVxufVxuXG5hZGRTaWduYWxzKExheWVyQW5ub3RhdGlvbiwgJ3NlbGVjdGVkJywgJ2xvYWRlZCcpO1xuZXhwb3J0IHsgTGF5ZXJBbm5vdGF0aW9uIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LayerAnnotation.js\n");

/***/ }),

/***/ "./src/LayerCombiner.js":
/*!******************************!*\
  !*** ./src/LayerCombiner.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayerCombiner\": () => (/* binding */ LayerCombiner)\n/* harmony export */ });\n/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layer.js */ \"./src/Layer.js\");\n\n\n/**\n * Combines other layers (in the framebuffer) using a custom shader. {@link LayerLens} is an example.\n * The class LayerImage can also be instantiated via the Layer parent class and `options.type='combiner'`.\n * \n * Extends {@link Layer}.\n * @param {options} options Same as {@link Layer}, but `options.layers` are required\n * @example\n * // Instantiate the LayerCombiner class and set the two inputs (layer0 and layer1)\n * const combiner = new OpenLIME.Layer({\n *     type: 'combiner',\n *     visible: true,\n *     layers: [layer0, layer1]\n * });\n * \n * // Instantiate the ShaderCombiner class (a custom shader) and select 'diff' as default mode (for visualization purposes)\n * const shader = new OpenLIME.ShaderCombiner();\n * shader.mode = 'diff';\n *\n * // Assign the newly created shader to the combiner (labelling it 'standard') and enable it\n * combiner.shaders = { 'standard': shader };\n * combiner.setShader('standard');\n *\n * // Add the combiner to the canvas\n * lime.addLayer('combiner', combiner);\n */\nclass LayerCombiner extends _Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\tif(Object.keys(this.rasters).length != 0)\n\t\t\tthrow \"Rasters options should be empty!\";\n\n/*\t\tlet shader = new ShaderCombiner({\n\t\t\t'label': 'Combiner',\n\t\t\t'samplers': [{ id:0, name:'source1', type:'vec3' }, { id:1, name:'source2', type:'vec3' }],\n\t\t});\n\n\t\tthis.shaders = {'standard': shader };\n\t\tthis.setShader('standard'); */\n\n//todo if layers check for importjson\n\n\t\tthis.textures = [];\n\t\tthis.framebuffers = [];\n\t\tthis.status = 'ready';\n\t}\n\n\t/** @ignore */\n\tdraw(transform, viewport) {\n\t\tfor(let layer of this.layers)\n\t\t\tif(layer.status != 'ready')\n\t\t\t\treturn;\n\n\t\tif(!this.shader)\n\t\t\tthrow \"Shader not specified!\";\n\n\t\tlet w = viewport.dx;\n\t\tlet h = viewport.dy;\n\n\t\tif(!this.framebuffers.length || this.layout.width != w || this.layout.height != h) {\n\t\t\tthis.deleteFramebuffers();\n\t\t\tthis.layout.width = w;\n\t\t\tthis.layout.height = h;\n\t\t\tthis.createFramebuffers();\n\t\t}\n\n\t\tlet gl = this.gl;\n\t\tvar b = [0, 0, 0, 0];\n\t\tgl.clearColor(b[0], b[1], b[2], b[3]);\n\n//TODO optimize: render to texture ONLY if some parameters change!\n//provider di textures... max memory and reference counting.\n\n\t\tfor(let i = 0; i < this.layers.length; i++) { \n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\t\tthis.layers[i].draw(transform, {x:0, y:0, dx:w, dy:h, w:w, h:h});\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\t}\n\n\t\tthis.prepareWebGL();\n\n\t\tfor(let i = 0; i < this.layers.length; i++) {\n\t\t\tgl.uniform1i(this.shader.samplers[i].location, i);\n\t\t\tgl.activeTexture(gl.TEXTURE0 + i);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, this.textures[i]);\n\t\t}\n\n\t\tthis.updateTileBuffers(\n\t\t\tnew Float32Array([-1, -1, 0,  -1, 1, 0,  1, 1, 0,  1, -1, 0]), \n\t\t\tnew Float32Array([ 0,  0,      0, 1,     1, 1,     1,  0]));\n\t\tgl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT,0);\n\t}\n\n\t/** @ignore */\n\tcreateFramebuffers() {\n\t\tlet gl = this.gl;\n\t\tfor(let i = 0; i < this.layers.length; i++) {\n\t\t\t//TODO for thing like lens, we might want to create SMALLER textures for some layers.\n\t\t\tconst texture = gl.createTexture();\n\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\t\t\tconst level = 0;\n\t\t\tconst internalFormat = gl.RGBA;\n\t\t\tconst border = 0;\n\t\t\tconst format = gl.RGBA;\n\t\t\tconst type = gl.UNSIGNED_BYTE;\n\t\t\tgl.texImage2D(gl.TEXTURE_2D, level, internalFormat,\n\t\t\t\tthis.layout.width, this.layout.height, border, format, type, null);\n\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n\t\t\tconst framebuffer = gl.createFramebuffer();\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\t\tthis.textures[i] = texture;\n\t\t\tthis.framebuffers[i] = framebuffer;\n\t\t}\n\t}\n\n\t//TODO release textures and framebuffers\n\t/** @ignore */\n\tdeleteFramebuffers() {\n\t}\n\n\t/** @ignore */\n\tboundingBox() {\n\t\t// Combiner ask the combination of all its children boxes\n\t\t// keeping the hidden, because they could be hidden, but revealed by the combiner\n\t\tconst discardHidden = false;\n\t\tlet result = _Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer.computeLayersBBox(this.layers, discardHidden);\n\t\tif (this.transform != null && this.transform != undefined) {\n\t\t\tresult = this.transform.transformBox(result);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t/** @ignore */\n\tscale() {\n\t\t//Combiner ask the scale of all its children\n\t\t//keeping the hidden, because they could be hidden, but revealed by the combiner\n\t\tconst discardHidden = false;\n\t\tlet scale = _Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer.computeLayersMinScale(this.layers, discardHidden);\n\t\tscale *= this.transform.z;\n\t\treturn scale;\n\t}\n}\n\n_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer.prototype.types.combiner = (options) => { return new LayerCombiner(options); }\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGF5ZXJDb21iaW5lci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtQzs7QUFFbkM7QUFDQSxzRUFBc0UsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsV0FBVyxTQUFTLGlCQUFpQixZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBSztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUMsSUFBSSxtQ0FBbUM7QUFDNUYsR0FBRzs7QUFFSCxrQkFBa0I7QUFDbEIsOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrRUFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUVBQWlDLGtCQUFrQjs7QUFFM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9MYXllckNvbWJpbmVyLmpzP2MwZjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGF5ZXIgfSAgZnJvbSAnLi9MYXllci5qcydcblxuLyoqXG4gKiBDb21iaW5lcyBvdGhlciBsYXllcnMgKGluIHRoZSBmcmFtZWJ1ZmZlcikgdXNpbmcgYSBjdXN0b20gc2hhZGVyLiB7QGxpbmsgTGF5ZXJMZW5zfSBpcyBhbiBleGFtcGxlLlxuICogVGhlIGNsYXNzIExheWVySW1hZ2UgY2FuIGFsc28gYmUgaW5zdGFudGlhdGVkIHZpYSB0aGUgTGF5ZXIgcGFyZW50IGNsYXNzIGFuZCBgb3B0aW9ucy50eXBlPSdjb21iaW5lcidgLlxuICogXG4gKiBFeHRlbmRzIHtAbGluayBMYXllcn0uXG4gKiBAcGFyYW0ge29wdGlvbnN9IG9wdGlvbnMgU2FtZSBhcyB7QGxpbmsgTGF5ZXJ9LCBidXQgYG9wdGlvbnMubGF5ZXJzYCBhcmUgcmVxdWlyZWRcbiAqIEBleGFtcGxlXG4gKiAvLyBJbnN0YW50aWF0ZSB0aGUgTGF5ZXJDb21iaW5lciBjbGFzcyBhbmQgc2V0IHRoZSB0d28gaW5wdXRzIChsYXllcjAgYW5kIGxheWVyMSlcbiAqIGNvbnN0IGNvbWJpbmVyID0gbmV3IE9wZW5MSU1FLkxheWVyKHtcbiAqICAgICB0eXBlOiAnY29tYmluZXInLFxuICogICAgIHZpc2libGU6IHRydWUsXG4gKiAgICAgbGF5ZXJzOiBbbGF5ZXIwLCBsYXllcjFdXG4gKiB9KTtcbiAqIFxuICogLy8gSW5zdGFudGlhdGUgdGhlIFNoYWRlckNvbWJpbmVyIGNsYXNzIChhIGN1c3RvbSBzaGFkZXIpIGFuZCBzZWxlY3QgJ2RpZmYnIGFzIGRlZmF1bHQgbW9kZSAoZm9yIHZpc3VhbGl6YXRpb24gcHVycG9zZXMpXG4gKiBjb25zdCBzaGFkZXIgPSBuZXcgT3BlbkxJTUUuU2hhZGVyQ29tYmluZXIoKTtcbiAqIHNoYWRlci5tb2RlID0gJ2RpZmYnO1xuICpcbiAqIC8vIEFzc2lnbiB0aGUgbmV3bHkgY3JlYXRlZCBzaGFkZXIgdG8gdGhlIGNvbWJpbmVyIChsYWJlbGxpbmcgaXQgJ3N0YW5kYXJkJykgYW5kIGVuYWJsZSBpdFxuICogY29tYmluZXIuc2hhZGVycyA9IHsgJ3N0YW5kYXJkJzogc2hhZGVyIH07XG4gKiBjb21iaW5lci5zZXRTaGFkZXIoJ3N0YW5kYXJkJyk7XG4gKlxuICogLy8gQWRkIHRoZSBjb21iaW5lciB0byB0aGUgY2FudmFzXG4gKiBsaW1lLmFkZExheWVyKCdjb21iaW5lcicsIGNvbWJpbmVyKTtcbiAqL1xuY2xhc3MgTGF5ZXJDb21iaW5lciBleHRlbmRzIExheWVyIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXG5cdFx0aWYoT2JqZWN0LmtleXModGhpcy5yYXN0ZXJzKS5sZW5ndGggIT0gMClcblx0XHRcdHRocm93IFwiUmFzdGVycyBvcHRpb25zIHNob3VsZCBiZSBlbXB0eSFcIjtcblxuLypcdFx0bGV0IHNoYWRlciA9IG5ldyBTaGFkZXJDb21iaW5lcih7XG5cdFx0XHQnbGFiZWwnOiAnQ29tYmluZXInLFxuXHRcdFx0J3NhbXBsZXJzJzogW3sgaWQ6MCwgbmFtZTonc291cmNlMScsIHR5cGU6J3ZlYzMnIH0sIHsgaWQ6MSwgbmFtZTonc291cmNlMicsIHR5cGU6J3ZlYzMnIH1dLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5zaGFkZXJzID0geydzdGFuZGFyZCc6IHNoYWRlciB9O1xuXHRcdHRoaXMuc2V0U2hhZGVyKCdzdGFuZGFyZCcpOyAqL1xuXG4vL3RvZG8gaWYgbGF5ZXJzIGNoZWNrIGZvciBpbXBvcnRqc29uXG5cblx0XHR0aGlzLnRleHR1cmVzID0gW107XG5cdFx0dGhpcy5mcmFtZWJ1ZmZlcnMgPSBbXTtcblx0XHR0aGlzLnN0YXR1cyA9ICdyZWFkeSc7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRkcmF3KHRyYW5zZm9ybSwgdmlld3BvcnQpIHtcblx0XHRmb3IobGV0IGxheWVyIG9mIHRoaXMubGF5ZXJzKVxuXHRcdFx0aWYobGF5ZXIuc3RhdHVzICE9ICdyZWFkeScpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdGlmKCF0aGlzLnNoYWRlcilcblx0XHRcdHRocm93IFwiU2hhZGVyIG5vdCBzcGVjaWZpZWQhXCI7XG5cblx0XHRsZXQgdyA9IHZpZXdwb3J0LmR4O1xuXHRcdGxldCBoID0gdmlld3BvcnQuZHk7XG5cblx0XHRpZighdGhpcy5mcmFtZWJ1ZmZlcnMubGVuZ3RoIHx8IHRoaXMubGF5b3V0LndpZHRoICE9IHcgfHwgdGhpcy5sYXlvdXQuaGVpZ2h0ICE9IGgpIHtcblx0XHRcdHRoaXMuZGVsZXRlRnJhbWVidWZmZXJzKCk7XG5cdFx0XHR0aGlzLmxheW91dC53aWR0aCA9IHc7XG5cdFx0XHR0aGlzLmxheW91dC5oZWlnaHQgPSBoO1xuXHRcdFx0dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcnMoKTtcblx0XHR9XG5cblx0XHRsZXQgZ2wgPSB0aGlzLmdsO1xuXHRcdHZhciBiID0gWzAsIDAsIDAsIDBdO1xuXHRcdGdsLmNsZWFyQ29sb3IoYlswXSwgYlsxXSwgYlsyXSwgYlszXSk7XG5cbi8vVE9ETyBvcHRpbWl6ZTogcmVuZGVyIHRvIHRleHR1cmUgT05MWSBpZiBzb21lIHBhcmFtZXRlcnMgY2hhbmdlIVxuLy9wcm92aWRlciBkaSB0ZXh0dXJlcy4uLiBtYXggbWVtb3J5IGFuZCByZWZlcmVuY2UgY291bnRpbmcuXG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5sYXllcnMubGVuZ3RoOyBpKyspIHsgXG5cdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXJzW2ldKTtcblx0XHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXHRcdFx0dGhpcy5sYXllcnNbaV0uZHJhdyh0cmFuc2Zvcm0sIHt4OjAsIHk6MCwgZHg6dywgZHk6aCwgdzp3LCBoOmh9KTtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5wcmVwYXJlV2ViR0woKTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z2wudW5pZm9ybTFpKHRoaXMuc2hhZGVyLnNhbXBsZXJzW2ldLmxvY2F0aW9uLCBpKTtcblx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpKTtcblx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZXNbaV0pO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlVGlsZUJ1ZmZlcnMoXG5cdFx0XHRuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIDAsICAtMSwgMSwgMCwgIDEsIDEsIDAsICAxLCAtMSwgMF0pLCBcblx0XHRcdG5ldyBGbG9hdDMyQXJyYXkoWyAwLCAgMCwgICAgICAwLCAxLCAgICAgMSwgMSwgICAgIDEsICAwXSkpO1xuXHRcdGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULDApO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0Y3JlYXRlRnJhbWVidWZmZXJzKCkge1xuXHRcdGxldCBnbCA9IHRoaXMuZ2w7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQvL1RPRE8gZm9yIHRoaW5nIGxpa2UgbGVucywgd2UgbWlnaHQgd2FudCB0byBjcmVhdGUgU01BTExFUiB0ZXh0dXJlcyBmb3Igc29tZSBsYXllcnMuXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuXHRcdFx0Y29uc3QgbGV2ZWwgPSAwO1xuXHRcdFx0Y29uc3QgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuXHRcdFx0Y29uc3QgYm9yZGVyID0gMDtcblx0XHRcdGNvbnN0IGZvcm1hdCA9IGdsLlJHQkE7XG5cdFx0XHRjb25zdCB0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LFxuXHRcdFx0XHR0aGlzLmxheW91dC53aWR0aCwgdGhpcy5sYXlvdXQuaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG5cblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuXHRcdFx0Y29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG5cdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdFx0dGhpcy50ZXh0dXJlc1tpXSA9IHRleHR1cmU7XG5cdFx0XHR0aGlzLmZyYW1lYnVmZmVyc1tpXSA9IGZyYW1lYnVmZmVyO1xuXHRcdH1cblx0fVxuXG5cdC8vVE9ETyByZWxlYXNlIHRleHR1cmVzIGFuZCBmcmFtZWJ1ZmZlcnNcblx0LyoqIEBpZ25vcmUgKi9cblx0ZGVsZXRlRnJhbWVidWZmZXJzKCkge1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0Ym91bmRpbmdCb3goKSB7XG5cdFx0Ly8gQ29tYmluZXIgYXNrIHRoZSBjb21iaW5hdGlvbiBvZiBhbGwgaXRzIGNoaWxkcmVuIGJveGVzXG5cdFx0Ly8ga2VlcGluZyB0aGUgaGlkZGVuLCBiZWNhdXNlIHRoZXkgY291bGQgYmUgaGlkZGVuLCBidXQgcmV2ZWFsZWQgYnkgdGhlIGNvbWJpbmVyXG5cdFx0Y29uc3QgZGlzY2FyZEhpZGRlbiA9IGZhbHNlO1xuXHRcdGxldCByZXN1bHQgPSBMYXllci5jb21wdXRlTGF5ZXJzQkJveCh0aGlzLmxheWVycywgZGlzY2FyZEhpZGRlbik7XG5cdFx0aWYgKHRoaXMudHJhbnNmb3JtICE9IG51bGwgJiYgdGhpcy50cmFuc2Zvcm0gIT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXN1bHQgPSB0aGlzLnRyYW5zZm9ybS50cmFuc2Zvcm1Cb3gocmVzdWx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0LyoqIEBpZ25vcmUgKi9cblx0c2NhbGUoKSB7XG5cdFx0Ly9Db21iaW5lciBhc2sgdGhlIHNjYWxlIG9mIGFsbCBpdHMgY2hpbGRyZW5cblx0XHQvL2tlZXBpbmcgdGhlIGhpZGRlbiwgYmVjYXVzZSB0aGV5IGNvdWxkIGJlIGhpZGRlbiwgYnV0IHJldmVhbGVkIGJ5IHRoZSBjb21iaW5lclxuXHRcdGNvbnN0IGRpc2NhcmRIaWRkZW4gPSBmYWxzZTtcblx0XHRsZXQgc2NhbGUgPSBMYXllci5jb21wdXRlTGF5ZXJzTWluU2NhbGUodGhpcy5sYXllcnMsIGRpc2NhcmRIaWRkZW4pO1xuXHRcdHNjYWxlICo9IHRoaXMudHJhbnNmb3JtLno7XG5cdFx0cmV0dXJuIHNjYWxlO1xuXHR9XG59XG5cbkxheWVyLnByb3RvdHlwZS50eXBlc1snY29tYmluZXInXSA9IChvcHRpb25zKSA9PiB7IHJldHVybiBuZXcgTGF5ZXJDb21iaW5lcihvcHRpb25zKTsgfVxuXG5leHBvcnQgeyBMYXllckNvbWJpbmVyIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LayerCombiner.js\n");

/***/ }),

/***/ "./src/LayerDstretch.js":
/*!******************************!*\
  !*** ./src/LayerDstretch.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayerDstretch\": () => (/* binding */ LayerDstretch)\n/* harmony export */ });\n/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layer.js */ \"./src/Layer.js\");\n/* harmony import */ var _LayerImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LayerImage.js */ \"./src/LayerImage.js\");\n/* harmony import */ var _ShaderDstretch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShaderDstretch.js */ \"./src/ShaderDstretch.js\");\n/* harmony import */ var _Raster_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Raster.js */ \"./src/Raster.js\");\n\n\n\n\n\nclass LayerDstretch extends _LayerImage_js__WEBPACK_IMPORTED_MODULE_1__.LayerImage {\n    constructor(options) {\n\t\tsuper(options);\n\n\t\tif(!this.url)\n\t\t\tthrow \"Url option is required\";\n\n\t\tthis.shaders['dstretch'] = new _ShaderDstretch_js__WEBPACK_IMPORTED_MODULE_2__.ShaderDstretch();\n\t\tthis.setShader('dstretch');\n\t\tthis.eulerRotation = [0,0,0];\n\n\t\tthis.worldRotation = 0; //if the canvas or ethe layer rotate, light direction neeeds to be rotated too.\n\t\tif(this.url)\n\t\t\tthis.loadJson();\n\t\tthis.addControl('light', [0, 0]);\n\t}\n\n\tsetLight(value, dt) {\n\t\tthis.setControl('light', value, dt);\n\n\t\tthis.eulerRotation[0] = Math.PI * this.getControl('light').current.value[0];//this.controls['light'].current[0];\n\t\tthis.eulerRotation[1] = Math.PI * this.getControl('light').current.value[1];//this.controls['light'].current[1];\n\n\t\tthis.shader.updateRotationMatrix(this.eulerRotation);\n\t\tthis.emit('update');\n\t}\n\t\n\tloadJson() {\n\t\t(async () => {\n\t\t\tlet json\n\t\t\ttry {\n\t\t\t\tlet dstretchUrl = this.url.substring(0, this.url.lastIndexOf(\".\")) + \".dstretch\";\n\t\t\t\tlet response = await fetch(dstretchUrl);\n\t\t\t\tconsole.log(response.ok);\n\t\t\t\tjson = await response.json();\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tjson = {\n\t\t\t\t\ttransformation: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n\t\t\t\t\tsamples: []\n\t\t\t\t};\n\t\t\t\tthis.rasters[0].loadTexture = this.loadAndSampleTexture.bind(this);\n\t\t\t}\n\n\t\t\tthis.layout.setUrls([this.url]);\n\t\t\tthis.shader.init(json);\n\t\t})();\n\t} \n\n\tdraw(transform, viewport) {\n\t\tthis.shader.setMinMax();\n\t\treturn super.draw(transform, viewport);\n\t}\n\n\tloadAndSampleTexture(gl, img) {\n\t\tthis.rasters[0].width = img.width;\n\t\tthis.rasters[0].height = img.height;\n\t\tlet tex = gl.createTexture();\n\t\tgl.bindTexture(gl.TEXTURE_2D, tex);\n\t\tgl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\tgl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); //_MIPMAP_LINEAR);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n\n\t\t// Sample the texture\n\t\t// Temporarily print the texture on a canvas\n\t\tlet canvas = document.createElement(\"canvas\");\n\t\tlet context = canvas.getContext(\"2d\");\n\n\t\tcanvas.setAttribute(\"width\", img.width);\n\t\tcanvas.setAttribute(\"height\", img.height);\n\t\tcontext.drawImage(img, 0, 0, img.width, img.height);\n\n\t\t// Get the data and sample the texture\n\t\tlet imageData = context.getImageData(0, 0, img.width, img.height).data;\n\t\tlet samples = [];\n\t\tlet rowSkip = Math.floor(img.height / 32);\n\t\tlet colSkip = Math.floor(img.width / 32);\n\n\t\tconsole.log(rowSkip, colSkip);\n\n\t\tfor (let i=0; i<imageData.length; i+=4) {\n\t\t\tlet row = Math.floor((i / 4) / img.width);\n\t\t\tlet col = Math.floor(i / 4) % img.width;\n\n\t\t\tif (row % rowSkip == 0 && col % colSkip == 0)\n\t\t\t\tsamples.push([imageData[i], imageData[i+1], imageData[i+2]]);\n\t\t}\n\n\t\tthis.shader.samples = samples;\n\t\tthis.shader.setMinMax();\n\t\treturn tex;\n\t}\n}\n\n_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer.prototype.types.dstretch = (options) => { return new LayerDstretch(options); }\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGF5ZXJEc3RyZXRjaC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpQztBQUNTO0FBQ1M7QUFDZDs7QUFFckMsNEJBQTRCLHNEQUFVO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsOERBQWM7QUFDL0M7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4RUFBOEU7QUFDOUUsOEVBQThFOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUVBQWlDLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL0xheWVyRHN0cmV0Y2guanM/MmFhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCB7TGF5ZXJJbWFnZX0gZnJvbSAnLi9MYXllckltYWdlLmpzJ1xuaW1wb3J0IHtTaGFkZXJEc3RyZXRjaH0gZnJvbSAnLi9TaGFkZXJEc3RyZXRjaC5qcyc7XG5pbXBvcnQgeyBSYXN0ZXIgfSBmcm9tICcuL1Jhc3Rlci5qcyc7XG5cbmNsYXNzIExheWVyRHN0cmV0Y2ggZXh0ZW5kcyBMYXllckltYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cblx0XHRpZighdGhpcy51cmwpXG5cdFx0XHR0aHJvdyBcIlVybCBvcHRpb24gaXMgcmVxdWlyZWRcIjtcblxuXHRcdHRoaXMuc2hhZGVyc1snZHN0cmV0Y2gnXSA9IG5ldyBTaGFkZXJEc3RyZXRjaCgpO1xuXHRcdHRoaXMuc2V0U2hhZGVyKCdkc3RyZXRjaCcpO1xuXHRcdHRoaXMuZXVsZXJSb3RhdGlvbiA9IFswLDAsMF07XG5cblx0XHR0aGlzLndvcmxkUm90YXRpb24gPSAwOyAvL2lmIHRoZSBjYW52YXMgb3IgZXRoZSBsYXllciByb3RhdGUsIGxpZ2h0IGRpcmVjdGlvbiBuZWVlZHMgdG8gYmUgcm90YXRlZCB0b28uXG5cdFx0aWYodGhpcy51cmwpXG5cdFx0XHR0aGlzLmxvYWRKc29uKCk7XG5cdFx0dGhpcy5hZGRDb250cm9sKCdsaWdodCcsIFswLCAwXSk7XG5cdH1cblxuXHRzZXRMaWdodCh2YWx1ZSwgZHQpIHtcblx0XHR0aGlzLnNldENvbnRyb2woJ2xpZ2h0JywgdmFsdWUsIGR0KTtcblxuXHRcdHRoaXMuZXVsZXJSb3RhdGlvblswXSA9IE1hdGguUEkgKiB0aGlzLmdldENvbnRyb2woJ2xpZ2h0JykuY3VycmVudC52YWx1ZVswXTsvL3RoaXMuY29udHJvbHNbJ2xpZ2h0J10uY3VycmVudFswXTtcblx0XHR0aGlzLmV1bGVyUm90YXRpb25bMV0gPSBNYXRoLlBJICogdGhpcy5nZXRDb250cm9sKCdsaWdodCcpLmN1cnJlbnQudmFsdWVbMV07Ly90aGlzLmNvbnRyb2xzWydsaWdodCddLmN1cnJlbnRbMV07XG5cblx0XHR0aGlzLnNoYWRlci51cGRhdGVSb3RhdGlvbk1hdHJpeCh0aGlzLmV1bGVyUm90YXRpb24pO1xuXHRcdHRoaXMuZW1pdCgndXBkYXRlJyk7XG5cdH1cblx0XG5cdGxvYWRKc29uKCkge1xuXHRcdChhc3luYyAoKSA9PiB7XG5cdFx0XHRsZXQganNvblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGV0IGRzdHJldGNoVXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIHRoaXMudXJsLmxhc3RJbmRleE9mKFwiLlwiKSkgKyBcIi5kc3RyZXRjaFwiO1xuXHRcdFx0XHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChkc3RyZXRjaFVybCk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlc3BvbnNlLm9rKTtcblx0XHRcdFx0anNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRqc29uID0ge1xuXHRcdFx0XHRcdHRyYW5zZm9ybWF0aW9uOiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0sXG5cdFx0XHRcdFx0c2FtcGxlczogW11cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5yYXN0ZXJzWzBdLmxvYWRUZXh0dXJlID0gdGhpcy5sb2FkQW5kU2FtcGxlVGV4dHVyZS5iaW5kKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmxheW91dC5zZXRVcmxzKFt0aGlzLnVybF0pO1xuXHRcdFx0dGhpcy5zaGFkZXIuaW5pdChqc29uKTtcblx0XHR9KSgpO1xuXHR9IFxuXG5cdGRyYXcodHJhbnNmb3JtLCB2aWV3cG9ydCkge1xuXHRcdHRoaXMuc2hhZGVyLnNldE1pbk1heCgpO1xuXHRcdHJldHVybiBzdXBlci5kcmF3KHRyYW5zZm9ybSwgdmlld3BvcnQpO1xuXHR9XG5cblx0bG9hZEFuZFNhbXBsZVRleHR1cmUoZ2wsIGltZykge1xuXHRcdHRoaXMucmFzdGVyc1swXS53aWR0aCA9IGltZy53aWR0aDtcblx0XHR0aGlzLnJhc3RlcnNbMF0uaGVpZ2h0ID0gaW1nLmhlaWdodDtcblx0XHRsZXQgdGV4ID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleCk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyZihnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyZihnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7IC8vX01JUE1BUF9MSU5FQVIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcblxuXHRcdC8vIFNhbXBsZSB0aGUgdGV4dHVyZVxuXHRcdC8vIFRlbXBvcmFyaWx5IHByaW50IHRoZSB0ZXh0dXJlIG9uIGEgY2FudmFzXG5cdFx0bGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0bGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGltZy53aWR0aCk7XG5cdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBpbWcuaGVpZ2h0KTtcblx0XHRjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG5cblx0XHQvLyBHZXQgdGhlIGRhdGEgYW5kIHNhbXBsZSB0aGUgdGV4dHVyZVxuXHRcdGxldCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpLmRhdGE7XG5cdFx0bGV0IHNhbXBsZXMgPSBbXTtcblx0XHRsZXQgcm93U2tpcCA9IE1hdGguZmxvb3IoaW1nLmhlaWdodCAvIDMyKTtcblx0XHRsZXQgY29sU2tpcCA9IE1hdGguZmxvb3IoaW1nLndpZHRoIC8gMzIpO1xuXG5cdFx0Y29uc29sZS5sb2cocm93U2tpcCwgY29sU2tpcCk7XG5cblx0XHRmb3IgKGxldCBpPTA7IGk8aW1hZ2VEYXRhLmxlbmd0aDsgaSs9NCkge1xuXHRcdFx0bGV0IHJvdyA9IE1hdGguZmxvb3IoKGkgLyA0KSAvIGltZy53aWR0aCk7XG5cdFx0XHRsZXQgY29sID0gTWF0aC5mbG9vcihpIC8gNCkgJSBpbWcud2lkdGg7XG5cblx0XHRcdGlmIChyb3cgJSByb3dTa2lwID09IDAgJiYgY29sICUgY29sU2tpcCA9PSAwKVxuXHRcdFx0XHRzYW1wbGVzLnB1c2goW2ltYWdlRGF0YVtpXSwgaW1hZ2VEYXRhW2krMV0sIGltYWdlRGF0YVtpKzJdXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zaGFkZXIuc2FtcGxlcyA9IHNhbXBsZXM7XG5cdFx0dGhpcy5zaGFkZXIuc2V0TWluTWF4KCk7XG5cdFx0cmV0dXJuIHRleDtcblx0fVxufVxuXG5MYXllci5wcm90b3R5cGUudHlwZXNbJ2RzdHJldGNoJ10gPSAob3B0aW9ucykgPT4geyByZXR1cm4gbmV3IExheWVyRHN0cmV0Y2gob3B0aW9ucyk7IH1cblxuZXhwb3J0IHsgTGF5ZXJEc3RyZXRjaCB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/LayerDstretch.js\n");

/***/ }),

/***/ "./src/LayerImage.js":
/*!***************************!*\
  !*** ./src/LayerImage.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayerImage\": () => (/* binding */ LayerImage)\n/* harmony export */ });\n/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layer.js */ \"./src/Layer.js\");\n/* harmony import */ var _Raster_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Raster.js */ \"./src/Raster.js\");\n/* harmony import */ var _Shader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shader.js */ \"./src/Shader.js\");\n\n\n\n\n/**\n * The class LayerImage is derived from Layer and it is responsible for the rendering of simple images.\n * \n * @example\n * // Create an image layer and add it to the canvans\n * const layer = new OpenLIME.Layer({\n *     layout: 'image',\n *     type: 'image',\n *     url: '../../assets/lime/image/lime.jpg'\n * });\n * lime.addLayer('Base', layer);\n */\nclass LayerImage extends _Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer {\n\t/**\n \t* Displays a simple image.\n \t* An object literal with Layer `options` can be specified.\n\t* The class LayerImage can also be instantiated via the Layer parent class and `options.type='image'`.\n \t*\n\t  Extends {@link Layer}.\n \t* @param {Object} options an object literal with Layer options {@link Layer}, but `options.url` and `options.layout` are required.\n \t* @param {string} options.url The URL of the image\n \t* @param {(string|Layout)} options.layout='image' The layout (the format of the input raster images).\n \t*/\n\tconstructor(options) {\t\n\t\tsuper(options);\n\n\t\tif(Object.keys(this.rasters).length != 0)\n\t\t\tthrow \"Rasters options should be empty!\";\n\n\t\tif (this.url)\n\t\t\tthis.layout.setUrls([this.url]);\n\t\telse if (this.layout.urls.length == 0)\n\t\t\tthrow \"Missing options.url parameter\";\t\n\n\t\tconst rasterFormat = this.format != null ? this.format : 'vec4';\n\t\tlet raster = new _Raster_js__WEBPACK_IMPORTED_MODULE_1__.Raster({ format: rasterFormat });\n\n\t\tthis.rasters.push(raster);\n\t\t\n\n\t\tlet shader = new _Shader_js__WEBPACK_IMPORTED_MODULE_2__.Shader({\n\t\t\t'label': 'Rgb',\n\t\t\t'samplers': [{ id:0, name:'kd', type: rasterFormat }]\n\t\t});\n\t\t\n\t\tshader.fragShaderSrc = function(gl) {\n\n\t\t\tlet gl2 = !(gl instanceof WebGLRenderingContext);\n\t\t\tlet str = `${gl2? '#version 300 es' : ''}\n\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D kd;\n\n${gl2? 'in' : 'varying'} vec2 v_texcoord;\n${gl2? 'out' : ''} vec4 color;\n\n\nvoid main() {\n\tcolor = texture${gl2?'':'2D'}(kd, v_texcoord);\n\t${gl2? '':'gl_FragColor = color;'}\n}\n`;\n\t\t\treturn str;\n\n\t\t};\n\n\t\tthis.shaders = {'standard': shader };\n\t\tthis.setShader('standard');\n\t}\n}\n\n_Layer_js__WEBPACK_IMPORTED_MODULE_0__.Layer.prototype.types.image = (options) => { return new LayerImage(options); }\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGF5ZXJJbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1DO0FBQ0M7QUFDQTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx5QkFBeUIsNENBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFFBQVEsOENBQThDLFlBQVk7QUFDOUUsWUFBWSxRQUFRO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDhDQUFNLEdBQUcsc0JBQXNCOztBQUVsRDtBQUNBOztBQUVBLG1CQUFtQiw4Q0FBTTtBQUN6QjtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRSx1QkFBdUI7QUFDekIsRUFBRSxpQkFBaUI7OztBQUduQjtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLEdBQUcsOEJBQThCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBLGtFQUE4QixrQkFBa0I7O0FBRTNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvTGF5ZXJJbWFnZS5qcz8xYTQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExheWVyIH0gIGZyb20gJy4vTGF5ZXIuanMnXG5pbXBvcnQgeyBSYXN0ZXIgfSBmcm9tICcuL1Jhc3Rlci5qcydcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4vU2hhZGVyLmpzJ1xuXG4vKipcbiAqIFRoZSBjbGFzcyBMYXllckltYWdlIGlzIGRlcml2ZWQgZnJvbSBMYXllciBhbmQgaXQgaXMgcmVzcG9uc2libGUgZm9yIHRoZSByZW5kZXJpbmcgb2Ygc2ltcGxlIGltYWdlcy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBhbiBpbWFnZSBsYXllciBhbmQgYWRkIGl0IHRvIHRoZSBjYW52YW5zXG4gKiBjb25zdCBsYXllciA9IG5ldyBPcGVuTElNRS5MYXllcih7XG4gKiAgICAgbGF5b3V0OiAnaW1hZ2UnLFxuICogICAgIHR5cGU6ICdpbWFnZScsXG4gKiAgICAgdXJsOiAnLi4vLi4vYXNzZXRzL2xpbWUvaW1hZ2UvbGltZS5qcGcnXG4gKiB9KTtcbiAqIGxpbWUuYWRkTGF5ZXIoJ0Jhc2UnLCBsYXllcik7XG4gKi9cbmNsYXNzIExheWVySW1hZ2UgZXh0ZW5kcyBMYXllciB7XG5cdC8qKlxuIFx0KiBEaXNwbGF5cyBhIHNpbXBsZSBpbWFnZS5cbiBcdCogQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBMYXllciBgb3B0aW9uc2AgY2FuIGJlIHNwZWNpZmllZC5cblx0KiBUaGUgY2xhc3MgTGF5ZXJJbWFnZSBjYW4gYWxzbyBiZSBpbnN0YW50aWF0ZWQgdmlhIHRoZSBMYXllciBwYXJlbnQgY2xhc3MgYW5kIGBvcHRpb25zLnR5cGU9J2ltYWdlJ2AuXG4gXHQqXG5cdCAgRXh0ZW5kcyB7QGxpbmsgTGF5ZXJ9LlxuIFx0KiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIExheWVyIG9wdGlvbnMge0BsaW5rIExheWVyfSwgYnV0IGBvcHRpb25zLnVybGAgYW5kIGBvcHRpb25zLmxheW91dGAgYXJlIHJlcXVpcmVkLlxuIFx0KiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmwgVGhlIFVSTCBvZiB0aGUgaW1hZ2VcbiBcdCogQHBhcmFtIHsoc3RyaW5nfExheW91dCl9IG9wdGlvbnMubGF5b3V0PSdpbWFnZScgVGhlIGxheW91dCAodGhlIGZvcm1hdCBvZiB0aGUgaW5wdXQgcmFzdGVyIGltYWdlcykuXG4gXHQqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHRcblx0XHRzdXBlcihvcHRpb25zKTtcblxuXHRcdGlmKE9iamVjdC5rZXlzKHRoaXMucmFzdGVycykubGVuZ3RoICE9IDApXG5cdFx0XHR0aHJvdyBcIlJhc3RlcnMgb3B0aW9ucyBzaG91bGQgYmUgZW1wdHkhXCI7XG5cblx0XHRpZiAodGhpcy51cmwpXG5cdFx0XHR0aGlzLmxheW91dC5zZXRVcmxzKFt0aGlzLnVybF0pO1xuXHRcdGVsc2UgaWYgKHRoaXMubGF5b3V0LnVybHMubGVuZ3RoID09IDApXG5cdFx0XHR0aHJvdyBcIk1pc3Npbmcgb3B0aW9ucy51cmwgcGFyYW1ldGVyXCI7XHRcblxuXHRcdGNvbnN0IHJhc3RlckZvcm1hdCA9IHRoaXMuZm9ybWF0ICE9IG51bGwgPyB0aGlzLmZvcm1hdCA6ICd2ZWM0Jztcblx0XHRsZXQgcmFzdGVyID0gbmV3IFJhc3Rlcih7IGZvcm1hdDogcmFzdGVyRm9ybWF0IH0pO1xuXG5cdFx0dGhpcy5yYXN0ZXJzLnB1c2gocmFzdGVyKTtcblx0XHRcblxuXHRcdGxldCBzaGFkZXIgPSBuZXcgU2hhZGVyKHtcblx0XHRcdCdsYWJlbCc6ICdSZ2InLFxuXHRcdFx0J3NhbXBsZXJzJzogW3sgaWQ6MCwgbmFtZTona2QnLCB0eXBlOiByYXN0ZXJGb3JtYXQgfV1cblx0XHR9KTtcblx0XHRcblx0XHRzaGFkZXIuZnJhZ1NoYWRlclNyYyA9IGZ1bmN0aW9uKGdsKSB7XG5cblx0XHRcdGxldCBnbDIgPSAhKGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KTtcblx0XHRcdGxldCBzdHIgPSBgJHtnbDI/ICcjdmVyc2lvbiAzMDAgZXMnIDogJyd9XG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5cbnVuaWZvcm0gc2FtcGxlcjJEIGtkO1xuXG4ke2dsMj8gJ2luJyA6ICd2YXJ5aW5nJ30gdmVjMiB2X3RleGNvb3JkO1xuJHtnbDI/ICdvdXQnIDogJyd9IHZlYzQgY29sb3I7XG5cblxudm9pZCBtYWluKCkge1xuXHRjb2xvciA9IHRleHR1cmUke2dsMj8nJzonMkQnfShrZCwgdl90ZXhjb29yZCk7XG5cdCR7Z2wyPyAnJzonZ2xfRnJhZ0NvbG9yID0gY29sb3I7J31cbn1cbmA7XG5cdFx0XHRyZXR1cm4gc3RyO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2hhZGVycyA9IHsnc3RhbmRhcmQnOiBzaGFkZXIgfTtcblx0XHR0aGlzLnNldFNoYWRlcignc3RhbmRhcmQnKTtcblx0fVxufVxuXG5MYXllci5wcm90b3R5cGUudHlwZXNbJ2ltYWdlJ10gPSAob3B0aW9ucykgPT4geyByZXR1cm4gbmV3IExheWVySW1hZ2Uob3B0aW9ucyk7IH1cblxuZXhwb3J0IHsgTGF5ZXJJbWFnZSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/LayerImage.js\n");

/***/ }),

/***/ "./src/LayerLens.js":
/*!**************************!*\
  !*** ./src/LayerLens.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayerLens\": () => (/* binding */ LayerLens)\n/* harmony export */ });\n/* harmony import */ var _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CoordinateSystem.js */ \"./src/CoordinateSystem.js\");\n/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ \"./src/Layer.js\");\n/* harmony import */ var _LayerCombiner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LayerCombiner.js */ \"./src/LayerCombiner.js\");\n/* harmony import */ var _ShaderLens_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShaderLens.js */ \"./src/ShaderLens.js\");\n\n\n\n\n\n/**\n * Displays a lens on the canvas. \n */\nclass LayerLens extends _LayerCombiner_js__WEBPACK_IMPORTED_MODULE_2__.LayerCombiner {\n\tconstructor(options) {\n\t\toptions = Object.assign({\n\t\t\toverlay: true,\n\t\t\tradius: 100,\n\t\t\tborderColor: [0.078, 0.078, 0.078, 1],\n\t\t\tborderWidth: 12,\n\t\t\tborderEnable: false,\n\t\t\tdashboard: null,\n\t\t}, options);\n\t\tsuper(options);\n\n\t\tif (!this.camera) {\n\t\t\tconsole.log(\"Missing camera\");\n\t\t\tthrow \"Missing Camera\"\n\t\t}\n\t\t\n\t\t// Shader lens currently handles up to 2 layers\n\t\tlet shader = new _ShaderLens_js__WEBPACK_IMPORTED_MODULE_3__.ShaderLens();\n\t\tif (this.layers.length == 2) shader.setOverlayLayerEnabled(true); //FIXME Is it a mode? Control?\n\t\tthis.shaders['lens'] = shader;\n\t\tthis.setShader('lens');\n\n\t\tthis.addControl('center', [0, 0]);\n\t\tthis.addControl('radius', [this.radius, 0]);\n\t\tthis.addControl('borderColor', this.borderColor);\n\t\tthis.addControl('borderWidth', [this.borderWidth]);\n\n\t\tthis.oldRadius = -9999;\n\t\tthis.oldCenter = [-9999, -9999];\n\n\t\tthis.useGL = true;\n\n\t\tif(this.dashboard) this.dashboard.lensLayer = this;\n\t}\n\n\tsetVisible(visible) {\n\t\tif(this.dashboard) {\n\t\t\tif(visible) {\n\t\t\t\tthis.dashboard.container.style.display = 'block';\n\t\t\t} else {\n\t\t\t\tthis.dashboard.container.style.display = 'none';\n\t\t\t}\n\t\t}\n\t\tsuper.setVisible(visible);\n\t}\n\n\tremoveOverlayLayer() {\n\t\tthis.layers.length = 1;\n\t\tthis.shader.setOverlayLayerEnabled(false);\n\t}\n\n\tsetBaseLayer(l) {\n\t\tthis.layers[0] = l;\n\t\tthis.emit('update');\n\t}\n\n\tsetOverlayLayer(l) {\n\t\tthis.layers[1] = l;\n\t\tthis.layers[1].setVisible(true);\n\t\tthis.shader.setOverlayLayerEnabled(true);\n\n\t\tthis.regenerateFrameBuffers();\n\t}\n\n\tregenerateFrameBuffers() {\n\t\t// Regenerate frame buffers\n\t\tconst w = this.layout.width;\n\t\tconst h = this.layout.height;\n\t\tthis.deleteFramebuffers();\n\t\tthis.layout.width = w;\n\t\tthis.layout.height = h;\n\t\tthis.createFramebuffers();\n\t}\n\t\n\tsetRadius(r, delayms = 100, easing='linear') {\n\t\tthis.setControl('radius', [r, 0], delayms, easing);\n\t}\n\n\tgetRadius() {\n\t\treturn this.controls['radius'].current.value[0];\n\t}\n\n\tsetCenter(x, y, delayms = 100, easing='linear') {\n\t\tthis.setControl('center', [x, y], delayms, easing);\n\t}\n\n\tgetCurrentCenter() {\n\t\tconst p = this.controls['center'].current.value;\n\t\treturn {x:p[0], y:p[1]};\n\t}\n\n\tgetTargetCenter() {\n\t\tconst p = this.controls['center'].target.value;\n\t\treturn {x:p[0], y:p[1]};\n\t}\n\n\tgetBorderColor() {\n\t\treturn this.controls['borderColor'].current.value;\n\t}\n\n\tgetBorderWidth() {\n\t\treturn this.controls['borderWidth'].current.value[0];\n\t}\n\n\tdraw(transform, viewport) {\n\t\tlet done = this.interpolateControls();\n\n\t\t// Update dashboard size & pos\n\t\tif (this.dashboard) {\n\t\t\tconst c = this.getCurrentCenter();\n\t\t\tconst r = this.getRadius();\n\t\t\tthis.dashboard.update(c.x, c.y, r);\n\t\t\tthis.oldCenter = c;\n\t\t\tthis.oldRadius = r;\n\t\t}\n\t\t// const vlens = this.getLensInViewportCoords(transform, viewport);\n\t\t// this.shader.setLensUniforms(vlens, [viewport.w, viewport.h], this.borderColor);\n\t\t// this.emit('draw');\n\t\t// super.draw(transform, viewport);\n\n\t\tfor(let layer of this.layers)\n\t\t\tif(layer.status != 'ready')\n\t\t\t\treturn false;\n\n\t\tif(!this.shader)\n\t\t\tthrow \"Shader not specified!\";\n\n\t\tlet gl = this.gl;\n\n\t\t// Draw on a restricted viewport around the lens, to lower down the number of required tiles\n\t\tlet lensViewport = this.getLensViewport(transform, viewport);\n\n\t\t// If an overlay is present, merge its viewport with the lens one\n\t\tlet overlayViewport = this.getOverlayLayerViewport(transform, viewport);\n\t\tif (overlayViewport != null) {\n\t\t\tlensViewport = this.joinViewports(lensViewport, overlayViewport);\n\t\t}\n\n\t\tgl.viewport(lensViewport.x, lensViewport.y, lensViewport.dx, lensViewport.dy);\n\n\t\t// Keep the framwbuffer to the window size in order to avoid changing at each scale event\n\t\tif(!this.framebuffers.length || this.layout.width != viewport.w || this.layout.height != viewport.h) {\n\t\t\tthis.deleteFramebuffers();\n\t\t\tthis.layout.width = viewport.w;\n\t\t\tthis.layout.height = viewport.h;\n\t\t\tthis.createFramebuffers();\n\t\t}\n\t\tvar b = [0, 0, 0, 0];\n\t\tgl.clearColor(b[0], b[1], b[2], b[3]);\n\n\t\t// Draw the layers only within the viewport enclosing the lens\n\t\tfor(let i = 0; i < this.layers.length; i++) { \n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\t\tthis.layers[i].draw(transform, lensViewport);\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t\t}\n\t\t\n\t\t// Set in the lensShader the proper lens position wrt the window viewport\n\t\tconst vl = this.getLensInViewportCoords(transform, viewport);\n\t\tthis.shader.setLensUniforms(vl, [viewport.w, viewport.h], this.getBorderColor(), this.borderEnable);\n\t\n\t\tthis.prepareWebGL();\n\n\t\t// Bind all textures and combine them with the shaderLens\n\t\tfor(let i = 0; i < this.layers.length; i++) {\n\t\t\tgl.uniform1i(this.shader.samplers[i].location, i);\n\t\t\tgl.activeTexture(gl.TEXTURE0 + i);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, this.textures[i]);\n\t\t}\n\n\t\t// Get texture coords of the lensViewport with respect to the framebuffer sz\n\t\tconst lx = lensViewport.x/lensViewport.w;\n\t\tconst ly = lensViewport.y/lensViewport.h;\n\t\tconst hx = (lensViewport.x+lensViewport.dx)/lensViewport.w;\n\t\tconst hy = (lensViewport.y+lensViewport.dy)/lensViewport.h;\n\t\t\n\t\tthis.updateTileBuffers(\n\t\t\tnew Float32Array([-1, -1, 0,  -1, 1, 0,  1, 1, 0,  1, -1, 0]), \n\t\t\tnew Float32Array([ lx, ly,     lx, hy,   hx, hy,   hx, ly]));\n\t\tgl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT,0);\n\n\t\t// Restore old viewport\n\t\tgl.viewport(viewport.x, viewport.x, viewport.dx, viewport.dy);\n\t\t\n\t\treturn done;\n\t}\n\n\tgetLensViewport(transform, viewport) {\n\t\tconst lensC = this.getCurrentCenter();\n\t\tconst l = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__.CoordinateSystem.fromSceneToViewport(lensC, this.camera, this.useGL);\n\t\tconst r = this.getRadius() * transform.z;\n\t\treturn {x: Math.floor(l.x-r)-1, y: Math.floor(l.y-r)-1, dx: Math.ceil(2*r)+2, dy: Math.ceil(2*r)+2, w:viewport.w, h:viewport.h};\n\t}\n\n\tgetOverlayLayerViewport(transform, viewport) {\n\t\tlet result = null;\n\t\tif (this.layers.length == 2) {\n\t\t\t// Get overlay projected viewport\n\t\t\tlet bbox = this.layers[1].boundingBox();\n\t\t\tconst p0v = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__.CoordinateSystem.fromSceneToViewport({x:bbox.xLow, y:bbox.yLow}, this.camera, this.useGL);\n\t\t\tconst p1v = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__.CoordinateSystem.fromSceneToViewport({x:bbox.xHigh, y:bbox.yHigh}, this.camera, this.useGL);\n\t\n\t\t\t// Intersect with window viewport\n\t\t\tconst x0 = Math.min(Math.max(0, Math.floor(p0v.x)), viewport.w);\n\t\t\tconst y0 = Math.min(Math.max(0, Math.floor(p0v.y)), viewport.h);\n\t\t\tconst x1 = Math.min(Math.max(0, Math.ceil(p1v.x)), viewport.w);\n\t\t\tconst y1 = Math.min(Math.max(0, Math.ceil(p1v.y)), viewport.h);\n\n\t\t\tconst width = x1 - x0;\n\t\t\tconst height = y1 - y0;\n\t\t\tresult = {x: x0, y: y0, dx:width, dy: height, w:viewport.w, h:viewport.h};\n\t\t} \n\t\treturn result;\n\t}\n\n\tjoinViewports(v0, v1) {\n\t\tconst xm = Math.min(v0.x, v1.x);\n\t\tconst xM = Math.max(v0.x+v0.dx, v1.x+v1.dx);\n\t\tconst ym = Math.min(v0.y, v1.y);\n\t\tconst yM = Math.max(v0.y+v0.dy, v1.y+v1.dy);\n\t\tconst width = xM - xm;\n\t\tconst height = yM - ym;\n\t\t\n\t\treturn {x:xm, y:ym, dx:width, dy:height, w: v0.w, h: v0.h };\n\t}\n\n\tgetLensInViewportCoords(transform, viewport) {\n\t\tconst lensC = this.getCurrentCenter();\n\t\tconst c = _CoordinateSystem_js__WEBPACK_IMPORTED_MODULE_0__.CoordinateSystem.fromSceneToViewport(lensC, this.camera, this.useGL);\n\t\tconst r = this.getRadius();\n\t\treturn [c.x, c.y, r * transform.z, this.getBorderWidth()];\n\t}\n\n}\n\n_Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer.prototype.types.lens = (options) => { return new LayerLens(options); }\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGF5ZXJMZW5zLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlEO0FBQ3RCO0FBQ2M7QUFDSDs7QUFFOUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFVO0FBQzdCLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHNGQUFvQztBQUNoRDtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzRkFBb0MsRUFBRSx5QkFBeUI7QUFDOUUsZUFBZSxzRkFBb0MsRUFBRSwyQkFBMkI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFlBQVksc0ZBQW9DO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpRUFBNkIsa0JBQWtCOztBQUU3QiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL0xheWVyTGVucy5qcz9kNmRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuL0Nvb3JkaW5hdGVTeXN0ZW0uanMnO1xuaW1wb3J0IHsgTGF5ZXIgfSAgZnJvbSAnLi9MYXllci5qcydcbmltcG9ydCB7TGF5ZXJDb21iaW5lcn0gIGZyb20gJy4vTGF5ZXJDb21iaW5lci5qcydcbmltcG9ydCB7U2hhZGVyTGVuc30gICAgIGZyb20gJy4vU2hhZGVyTGVucy5qcydcblxuLyoqXG4gKiBEaXNwbGF5cyBhIGxlbnMgb24gdGhlIGNhbnZhcy4gXG4gKi9cbmNsYXNzIExheWVyTGVucyBleHRlbmRzIExheWVyQ29tYmluZXIge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0b3ZlcmxheTogdHJ1ZSxcblx0XHRcdHJhZGl1czogMTAwLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IFswLjA3OCwgMC4wNzgsIDAuMDc4LCAxXSxcblx0XHRcdGJvcmRlcldpZHRoOiAxMixcblx0XHRcdGJvcmRlckVuYWJsZTogZmFsc2UsXG5cdFx0XHRkYXNoYm9hcmQ6IG51bGwsXG5cdFx0fSwgb3B0aW9ucyk7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cblx0XHRpZiAoIXRoaXMuY2FtZXJhKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIk1pc3NpbmcgY2FtZXJhXCIpO1xuXHRcdFx0dGhyb3cgXCJNaXNzaW5nIENhbWVyYVwiXG5cdFx0fVxuXHRcdFxuXHRcdC8vIFNoYWRlciBsZW5zIGN1cnJlbnRseSBoYW5kbGVzIHVwIHRvIDIgbGF5ZXJzXG5cdFx0bGV0IHNoYWRlciA9IG5ldyBTaGFkZXJMZW5zKCk7XG5cdFx0aWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PSAyKSBzaGFkZXIuc2V0T3ZlcmxheUxheWVyRW5hYmxlZCh0cnVlKTsgLy9GSVhNRSBJcyBpdCBhIG1vZGU/IENvbnRyb2w/XG5cdFx0dGhpcy5zaGFkZXJzWydsZW5zJ10gPSBzaGFkZXI7XG5cdFx0dGhpcy5zZXRTaGFkZXIoJ2xlbnMnKTtcblxuXHRcdHRoaXMuYWRkQ29udHJvbCgnY2VudGVyJywgWzAsIDBdKTtcblx0XHR0aGlzLmFkZENvbnRyb2woJ3JhZGl1cycsIFt0aGlzLnJhZGl1cywgMF0pO1xuXHRcdHRoaXMuYWRkQ29udHJvbCgnYm9yZGVyQ29sb3InLCB0aGlzLmJvcmRlckNvbG9yKTtcblx0XHR0aGlzLmFkZENvbnRyb2woJ2JvcmRlcldpZHRoJywgW3RoaXMuYm9yZGVyV2lkdGhdKTtcblxuXHRcdHRoaXMub2xkUmFkaXVzID0gLTk5OTk7XG5cdFx0dGhpcy5vbGRDZW50ZXIgPSBbLTk5OTksIC05OTk5XTtcblxuXHRcdHRoaXMudXNlR0wgPSB0cnVlO1xuXG5cdFx0aWYodGhpcy5kYXNoYm9hcmQpIHRoaXMuZGFzaGJvYXJkLmxlbnNMYXllciA9IHRoaXM7XG5cdH1cblxuXHRzZXRWaXNpYmxlKHZpc2libGUpIHtcblx0XHRpZih0aGlzLmRhc2hib2FyZCkge1xuXHRcdFx0aWYodmlzaWJsZSkge1xuXHRcdFx0XHR0aGlzLmRhc2hib2FyZC5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRhc2hib2FyZC5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdH1cblx0XHR9XG5cdFx0c3VwZXIuc2V0VmlzaWJsZSh2aXNpYmxlKTtcblx0fVxuXG5cdHJlbW92ZU92ZXJsYXlMYXllcigpIHtcblx0XHR0aGlzLmxheWVycy5sZW5ndGggPSAxO1xuXHRcdHRoaXMuc2hhZGVyLnNldE92ZXJsYXlMYXllckVuYWJsZWQoZmFsc2UpO1xuXHR9XG5cblx0c2V0QmFzZUxheWVyKGwpIHtcblx0XHR0aGlzLmxheWVyc1swXSA9IGw7XG5cdFx0dGhpcy5lbWl0KCd1cGRhdGUnKTtcblx0fVxuXG5cdHNldE92ZXJsYXlMYXllcihsKSB7XG5cdFx0dGhpcy5sYXllcnNbMV0gPSBsO1xuXHRcdHRoaXMubGF5ZXJzWzFdLnNldFZpc2libGUodHJ1ZSk7XG5cdFx0dGhpcy5zaGFkZXIuc2V0T3ZlcmxheUxheWVyRW5hYmxlZCh0cnVlKTtcblxuXHRcdHRoaXMucmVnZW5lcmF0ZUZyYW1lQnVmZmVycygpO1xuXHR9XG5cblx0cmVnZW5lcmF0ZUZyYW1lQnVmZmVycygpIHtcblx0XHQvLyBSZWdlbmVyYXRlIGZyYW1lIGJ1ZmZlcnNcblx0XHRjb25zdCB3ID0gdGhpcy5sYXlvdXQud2lkdGg7XG5cdFx0Y29uc3QgaCA9IHRoaXMubGF5b3V0LmhlaWdodDtcblx0XHR0aGlzLmRlbGV0ZUZyYW1lYnVmZmVycygpO1xuXHRcdHRoaXMubGF5b3V0LndpZHRoID0gdztcblx0XHR0aGlzLmxheW91dC5oZWlnaHQgPSBoO1xuXHRcdHRoaXMuY3JlYXRlRnJhbWVidWZmZXJzKCk7XG5cdH1cblx0XG5cdHNldFJhZGl1cyhyLCBkZWxheW1zID0gMTAwLCBlYXNpbmc9J2xpbmVhcicpIHtcblx0XHR0aGlzLnNldENvbnRyb2woJ3JhZGl1cycsIFtyLCAwXSwgZGVsYXltcywgZWFzaW5nKTtcblx0fVxuXG5cdGdldFJhZGl1cygpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250cm9sc1sncmFkaXVzJ10uY3VycmVudC52YWx1ZVswXTtcblx0fVxuXG5cdHNldENlbnRlcih4LCB5LCBkZWxheW1zID0gMTAwLCBlYXNpbmc9J2xpbmVhcicpIHtcblx0XHR0aGlzLnNldENvbnRyb2woJ2NlbnRlcicsIFt4LCB5XSwgZGVsYXltcywgZWFzaW5nKTtcblx0fVxuXG5cdGdldEN1cnJlbnRDZW50ZXIoKSB7XG5cdFx0Y29uc3QgcCA9IHRoaXMuY29udHJvbHNbJ2NlbnRlciddLmN1cnJlbnQudmFsdWU7XG5cdFx0cmV0dXJuIHt4OnBbMF0sIHk6cFsxXX07XG5cdH1cblxuXHRnZXRUYXJnZXRDZW50ZXIoKSB7XG5cdFx0Y29uc3QgcCA9IHRoaXMuY29udHJvbHNbJ2NlbnRlciddLnRhcmdldC52YWx1ZTtcblx0XHRyZXR1cm4ge3g6cFswXSwgeTpwWzFdfTtcblx0fVxuXG5cdGdldEJvcmRlckNvbG9yKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRyb2xzWydib3JkZXJDb2xvciddLmN1cnJlbnQudmFsdWU7XG5cdH1cblxuXHRnZXRCb3JkZXJXaWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250cm9sc1snYm9yZGVyV2lkdGgnXS5jdXJyZW50LnZhbHVlWzBdO1xuXHR9XG5cblx0ZHJhdyh0cmFuc2Zvcm0sIHZpZXdwb3J0KSB7XG5cdFx0bGV0IGRvbmUgPSB0aGlzLmludGVycG9sYXRlQ29udHJvbHMoKTtcblxuXHRcdC8vIFVwZGF0ZSBkYXNoYm9hcmQgc2l6ZSAmIHBvc1xuXHRcdGlmICh0aGlzLmRhc2hib2FyZCkge1xuXHRcdFx0Y29uc3QgYyA9IHRoaXMuZ2V0Q3VycmVudENlbnRlcigpO1xuXHRcdFx0Y29uc3QgciA9IHRoaXMuZ2V0UmFkaXVzKCk7XG5cdFx0XHR0aGlzLmRhc2hib2FyZC51cGRhdGUoYy54LCBjLnksIHIpO1xuXHRcdFx0dGhpcy5vbGRDZW50ZXIgPSBjO1xuXHRcdFx0dGhpcy5vbGRSYWRpdXMgPSByO1xuXHRcdH1cblx0XHQvLyBjb25zdCB2bGVucyA9IHRoaXMuZ2V0TGVuc0luVmlld3BvcnRDb29yZHModHJhbnNmb3JtLCB2aWV3cG9ydCk7XG5cdFx0Ly8gdGhpcy5zaGFkZXIuc2V0TGVuc1VuaWZvcm1zKHZsZW5zLCBbdmlld3BvcnQudywgdmlld3BvcnQuaF0sIHRoaXMuYm9yZGVyQ29sb3IpO1xuXHRcdC8vIHRoaXMuZW1pdCgnZHJhdycpO1xuXHRcdC8vIHN1cGVyLmRyYXcodHJhbnNmb3JtLCB2aWV3cG9ydCk7XG5cblx0XHRmb3IobGV0IGxheWVyIG9mIHRoaXMubGF5ZXJzKVxuXHRcdFx0aWYobGF5ZXIuc3RhdHVzICE9ICdyZWFkeScpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdGlmKCF0aGlzLnNoYWRlcilcblx0XHRcdHRocm93IFwiU2hhZGVyIG5vdCBzcGVjaWZpZWQhXCI7XG5cblx0XHRsZXQgZ2wgPSB0aGlzLmdsO1xuXG5cdFx0Ly8gRHJhdyBvbiBhIHJlc3RyaWN0ZWQgdmlld3BvcnQgYXJvdW5kIHRoZSBsZW5zLCB0byBsb3dlciBkb3duIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgdGlsZXNcblx0XHRsZXQgbGVuc1ZpZXdwb3J0ID0gdGhpcy5nZXRMZW5zVmlld3BvcnQodHJhbnNmb3JtLCB2aWV3cG9ydCk7XG5cblx0XHQvLyBJZiBhbiBvdmVybGF5IGlzIHByZXNlbnQsIG1lcmdlIGl0cyB2aWV3cG9ydCB3aXRoIHRoZSBsZW5zIG9uZVxuXHRcdGxldCBvdmVybGF5Vmlld3BvcnQgPSB0aGlzLmdldE92ZXJsYXlMYXllclZpZXdwb3J0KHRyYW5zZm9ybSwgdmlld3BvcnQpO1xuXHRcdGlmIChvdmVybGF5Vmlld3BvcnQgIT0gbnVsbCkge1xuXHRcdFx0bGVuc1ZpZXdwb3J0ID0gdGhpcy5qb2luVmlld3BvcnRzKGxlbnNWaWV3cG9ydCwgb3ZlcmxheVZpZXdwb3J0KTtcblx0XHR9XG5cblx0XHRnbC52aWV3cG9ydChsZW5zVmlld3BvcnQueCwgbGVuc1ZpZXdwb3J0LnksIGxlbnNWaWV3cG9ydC5keCwgbGVuc1ZpZXdwb3J0LmR5KTtcblxuXHRcdC8vIEtlZXAgdGhlIGZyYW13YnVmZmVyIHRvIHRoZSB3aW5kb3cgc2l6ZSBpbiBvcmRlciB0byBhdm9pZCBjaGFuZ2luZyBhdCBlYWNoIHNjYWxlIGV2ZW50XG5cdFx0aWYoIXRoaXMuZnJhbWVidWZmZXJzLmxlbmd0aCB8fCB0aGlzLmxheW91dC53aWR0aCAhPSB2aWV3cG9ydC53IHx8IHRoaXMubGF5b3V0LmhlaWdodCAhPSB2aWV3cG9ydC5oKSB7XG5cdFx0XHR0aGlzLmRlbGV0ZUZyYW1lYnVmZmVycygpO1xuXHRcdFx0dGhpcy5sYXlvdXQud2lkdGggPSB2aWV3cG9ydC53O1xuXHRcdFx0dGhpcy5sYXlvdXQuaGVpZ2h0ID0gdmlld3BvcnQuaDtcblx0XHRcdHRoaXMuY3JlYXRlRnJhbWVidWZmZXJzKCk7XG5cdFx0fVxuXHRcdHZhciBiID0gWzAsIDAsIDAsIDBdO1xuXHRcdGdsLmNsZWFyQ29sb3IoYlswXSwgYlsxXSwgYlsyXSwgYlszXSk7XG5cblx0XHQvLyBEcmF3IHRoZSBsYXllcnMgb25seSB3aXRoaW4gdGhlIHZpZXdwb3J0IGVuY2xvc2luZyB0aGUgbGVuc1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7IGkrKykgeyBcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcnNbaV0pO1xuXHRcdFx0Z2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cdFx0XHR0aGlzLmxheWVyc1tpXS5kcmF3KHRyYW5zZm9ybSwgbGVuc1ZpZXdwb3J0KTtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFNldCBpbiB0aGUgbGVuc1NoYWRlciB0aGUgcHJvcGVyIGxlbnMgcG9zaXRpb24gd3J0IHRoZSB3aW5kb3cgdmlld3BvcnRcblx0XHRjb25zdCB2bCA9IHRoaXMuZ2V0TGVuc0luVmlld3BvcnRDb29yZHModHJhbnNmb3JtLCB2aWV3cG9ydCk7XG5cdFx0dGhpcy5zaGFkZXIuc2V0TGVuc1VuaWZvcm1zKHZsLCBbdmlld3BvcnQudywgdmlld3BvcnQuaF0sIHRoaXMuZ2V0Qm9yZGVyQ29sb3IoKSwgdGhpcy5ib3JkZXJFbmFibGUpO1xuXHRcblx0XHR0aGlzLnByZXBhcmVXZWJHTCgpO1xuXG5cdFx0Ly8gQmluZCBhbGwgdGV4dHVyZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBzaGFkZXJMZW5zXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRnbC51bmlmb3JtMWkodGhpcy5zaGFkZXIuc2FtcGxlcnNbaV0ubG9jYXRpb24sIGkpO1xuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkpO1xuXHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlc1tpXSk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRleHR1cmUgY29vcmRzIG9mIHRoZSBsZW5zVmlld3BvcnQgd2l0aCByZXNwZWN0IHRvIHRoZSBmcmFtZWJ1ZmZlciBzelxuXHRcdGNvbnN0IGx4ID0gbGVuc1ZpZXdwb3J0LngvbGVuc1ZpZXdwb3J0Lnc7XG5cdFx0Y29uc3QgbHkgPSBsZW5zVmlld3BvcnQueS9sZW5zVmlld3BvcnQuaDtcblx0XHRjb25zdCBoeCA9IChsZW5zVmlld3BvcnQueCtsZW5zVmlld3BvcnQuZHgpL2xlbnNWaWV3cG9ydC53O1xuXHRcdGNvbnN0IGh5ID0gKGxlbnNWaWV3cG9ydC55K2xlbnNWaWV3cG9ydC5keSkvbGVuc1ZpZXdwb3J0Lmg7XG5cdFx0XG5cdFx0dGhpcy51cGRhdGVUaWxlQnVmZmVycyhcblx0XHRcdG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgMCwgIC0xLCAxLCAwLCAgMSwgMSwgMCwgIDEsIC0xLCAwXSksIFxuXHRcdFx0bmV3IEZsb2F0MzJBcnJheShbIGx4LCBseSwgICAgIGx4LCBoeSwgICBoeCwgaHksICAgaHgsIGx5XSkpO1xuXHRcdGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULDApO1xuXG5cdFx0Ly8gUmVzdG9yZSBvbGQgdmlld3BvcnRcblx0XHRnbC52aWV3cG9ydCh2aWV3cG9ydC54LCB2aWV3cG9ydC54LCB2aWV3cG9ydC5keCwgdmlld3BvcnQuZHkpO1xuXHRcdFxuXHRcdHJldHVybiBkb25lO1xuXHR9XG5cblx0Z2V0TGVuc1ZpZXdwb3J0KHRyYW5zZm9ybSwgdmlld3BvcnQpIHtcblx0XHRjb25zdCBsZW5zQyA9IHRoaXMuZ2V0Q3VycmVudENlbnRlcigpO1xuXHRcdGNvbnN0IGwgPSBDb29yZGluYXRlU3lzdGVtLmZyb21TY2VuZVRvVmlld3BvcnQobGVuc0MsIHRoaXMuY2FtZXJhLCB0aGlzLnVzZUdMKTtcblx0XHRjb25zdCByID0gdGhpcy5nZXRSYWRpdXMoKSAqIHRyYW5zZm9ybS56O1xuXHRcdHJldHVybiB7eDogTWF0aC5mbG9vcihsLngtciktMSwgeTogTWF0aC5mbG9vcihsLnktciktMSwgZHg6IE1hdGguY2VpbCgyKnIpKzIsIGR5OiBNYXRoLmNlaWwoMipyKSsyLCB3OnZpZXdwb3J0LncsIGg6dmlld3BvcnQuaH07XG5cdH1cblxuXHRnZXRPdmVybGF5TGF5ZXJWaWV3cG9ydCh0cmFuc2Zvcm0sIHZpZXdwb3J0KSB7XG5cdFx0bGV0IHJlc3VsdCA9IG51bGw7XG5cdFx0aWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHQvLyBHZXQgb3ZlcmxheSBwcm9qZWN0ZWQgdmlld3BvcnRcblx0XHRcdGxldCBiYm94ID0gdGhpcy5sYXllcnNbMV0uYm91bmRpbmdCb3goKTtcblx0XHRcdGNvbnN0IHAwdiA9IENvb3JkaW5hdGVTeXN0ZW0uZnJvbVNjZW5lVG9WaWV3cG9ydCh7eDpiYm94LnhMb3csIHk6YmJveC55TG93fSwgdGhpcy5jYW1lcmEsIHRoaXMudXNlR0wpO1xuXHRcdFx0Y29uc3QgcDF2ID0gQ29vcmRpbmF0ZVN5c3RlbS5mcm9tU2NlbmVUb1ZpZXdwb3J0KHt4OmJib3gueEhpZ2gsIHk6YmJveC55SGlnaH0sIHRoaXMuY2FtZXJhLCB0aGlzLnVzZUdMKTtcblx0XG5cdFx0XHQvLyBJbnRlcnNlY3Qgd2l0aCB3aW5kb3cgdmlld3BvcnRcblx0XHRcdGNvbnN0IHgwID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihwMHYueCkpLCB2aWV3cG9ydC53KTtcblx0XHRcdGNvbnN0IHkwID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihwMHYueSkpLCB2aWV3cG9ydC5oKTtcblx0XHRcdGNvbnN0IHgxID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHAxdi54KSksIHZpZXdwb3J0LncpO1xuXHRcdFx0Y29uc3QgeTEgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBNYXRoLmNlaWwocDF2LnkpKSwgdmlld3BvcnQuaCk7XG5cblx0XHRcdGNvbnN0IHdpZHRoID0geDEgLSB4MDtcblx0XHRcdGNvbnN0IGhlaWdodCA9IHkxIC0geTA7XG5cdFx0XHRyZXN1bHQgPSB7eDogeDAsIHk6IHkwLCBkeDp3aWR0aCwgZHk6IGhlaWdodCwgdzp2aWV3cG9ydC53LCBoOnZpZXdwb3J0Lmh9O1xuXHRcdH0gXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGpvaW5WaWV3cG9ydHModjAsIHYxKSB7XG5cdFx0Y29uc3QgeG0gPSBNYXRoLm1pbih2MC54LCB2MS54KTtcblx0XHRjb25zdCB4TSA9IE1hdGgubWF4KHYwLngrdjAuZHgsIHYxLngrdjEuZHgpO1xuXHRcdGNvbnN0IHltID0gTWF0aC5taW4odjAueSwgdjEueSk7XG5cdFx0Y29uc3QgeU0gPSBNYXRoLm1heCh2MC55K3YwLmR5LCB2MS55K3YxLmR5KTtcblx0XHRjb25zdCB3aWR0aCA9IHhNIC0geG07XG5cdFx0Y29uc3QgaGVpZ2h0ID0geU0gLSB5bTtcblx0XHRcblx0XHRyZXR1cm4ge3g6eG0sIHk6eW0sIGR4OndpZHRoLCBkeTpoZWlnaHQsIHc6IHYwLncsIGg6IHYwLmggfTtcblx0fVxuXG5cdGdldExlbnNJblZpZXdwb3J0Q29vcmRzKHRyYW5zZm9ybSwgdmlld3BvcnQpIHtcblx0XHRjb25zdCBsZW5zQyA9IHRoaXMuZ2V0Q3VycmVudENlbnRlcigpO1xuXHRcdGNvbnN0IGMgPSBDb29yZGluYXRlU3lzdGVtLmZyb21TY2VuZVRvVmlld3BvcnQobGVuc0MsIHRoaXMuY2FtZXJhLCB0aGlzLnVzZUdMKTtcblx0XHRjb25zdCByID0gdGhpcy5nZXRSYWRpdXMoKTtcblx0XHRyZXR1cm4gW2MueCwgYy55LCByICogdHJhbnNmb3JtLnosIHRoaXMuZ2V0Qm9yZGVyV2lkdGgoKV07XG5cdH1cblxufVxuXG5MYXllci5wcm90b3R5cGUudHlwZXNbJ2xlbnMnXSA9IChvcHRpb25zKSA9PiB7IHJldHVybiBuZXcgTGF5ZXJMZW5zKG9wdGlvbnMpOyB9XG5cbmV4cG9ydCB7TGF5ZXJMZW5zfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/LayerLens.js\n");

/***/ }),

/***/ "./src/LayerSvgAnnotation.js":
/*!***********************************!*\
  !*** ./src/LayerSvgAnnotation.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LayerSvgAnnotation\": () => (/* binding */ LayerSvgAnnotation)\n/* harmony export */ });\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ \"./src/Util.js\");\n/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer */ \"./src/Layer.js\");\n/* harmony import */ var _Annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Annotation */ \"./src/Annotation.js\");\n/* harmony import */ var _LayerAnnotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LayerAnnotation */ \"./src/LayerAnnotation.js\");\n/* harmony import */ var _CoordinateSystem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CoordinateSystem */ \"./src/CoordinateSystem.js\");\n\n\n\n\n\n\n/**\n * Elements to classify the annotations.\n * @typedef {Object} AnnotationClass\n * @property {color} stroke The CSS color of a line, text or outline SVG element.\n * @property {string} label The class name.\n */\n/**\n * Annotation classes.\n * @typedef {Object.<string, AnnotationClass>} AnnotationClasses\n */\n\n\n/**\n * An annotation layer that draws SVG elements directly on the canvas (outside the WebGL context).\n * \n * Here you will find a tutorial to learn how to build a client-server architecture to manage annotations in OpenLIME. //FIXME\n * \n * Extends {@link LayerAnnotation}.\n */\nclass LayerSvgAnnotation extends _LayerAnnotation__WEBPACK_IMPORTED_MODULE_3__.LayerAnnotation {\n\t/**\n\t * Instantiates a LayerSvgAnnotation object.\n\t * @param {Object} [options] An object literal with options that inherits from {@link LayerAnnotation}.\n \t * @param {AnnotationClasses} options.classes An object literal definying colors and labels of the annotation classes.\n \t * @param {Function} options.onClick The callback to fire when the an annotation is clicked on the canvas. The callback is passed an object containing the selected annotation.\n\t * @param {bool} options.shadow=true Whether to insert SVG elements in a shadow DOM.\n\t */\n\tconstructor(options) {\n\t\toptions = Object.assign({\n\t\t\toverlayElement: null,   //reference to canvas overlayElement. TODO: check if really needed.\n\t\t\tshadow: true,           //svg attached as shadow node (so style apply only the svg layer)\n\t\t\tsvgElement: null, \t\t//the svg layer\n\t\t\tsvgGroup: null,\n\t\t\tonClick: null,\t\t\t//callback function\n\t\t\tclasses: {\n\t\t\t\t'': { style: { stroke: '#000' }, label: '' },\n\t\t\t},\n\t\t\tannotationUpdate: null\n\t\t}, options);\n\t\tsuper(options);\n\t\tfor(const [key, value] of Object.entries(this.classes)) {\n\t\t\tthis.style += `[data-class=${key}] { ` + Object.entries(value.style).map( g => `${g[0]}: ${g[1]};`).join('\\n') + '}';\n\t\t}\n\t\t//this.createOverlaySVGElement();\n\t\t//this.setLayout(this.layout);\n\t}\n\n\t/** @ignore */\n\tcreateOverlaySVGElement() { \n\t\tthis.svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\t\tthis.svgElement.classList.add('openlime-svgoverlay');\n\t\tthis.svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n\t\tthis.svgElement.append(this.svgGroup);\n\n\t\tlet root = this.overlayElement;\n\t\tif (this.shadow)\n\t\t\troot = this.overlayElement.attachShadow({ mode: \"open\" });\n\n\t\tif (this.style) {\n\t\t\tconst style = document.createElement('style');\n\t\t\tstyle.textContent = this.style;\n\t\t\troot.append(style);\n\t\t}\n\t\troot.appendChild(this.svgElement);\n\t}\n\t/*  unused for the moment!!! \n\t\tasync loadSVG(url) {\n\t\t\tvar response = await fetch(url);\n\t\t\tif (!response.ok) {\n\t\t\t\tthis.status = \"Failed loading \" + this.url + \": \" + response.statusText;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet text = await response.text();\n\t\t\tlet parser = new DOMParser();\n\t\t\tthis.svgXML = parser.parseFromString(text, \"image/svg+xml\").documentElement;\n\t\t\tthrow \"if viewbox is set in svgURL should it overwrite options.viewbox or viceversa?\"\n\t\t}\n\t*/\n\n\t/**\n\t * Sets a value that indicates whether the layer is visible.\n\t * @param {bool} visible The value.\n\t */\n\tsetVisible(visible) {\n\t\tif (this.svgElement)\n\t\t\tthis.svgElement.style.display = visible ? 'block' : 'none';\n\t\tsuper.setVisible(visible);\n\t}\n\n\t/** @ignore */\n\tclearSelected() {\n\t\tif (!this.svgElement) this.createOverlaySVGElement();\n\t\t//\t\treturn;\n\t\tthis.svgGroup.querySelectorAll('[data-annotation]').forEach((e) => e.classList.remove('selected'));\n\t\tsuper.clearSelected();\n\t}\n\n\t/**\n\t * Selects/deselects an annotation\n\t * @param {Annotation} anno The annotation.\n\t * @param {bool} on=true Whether to select the annotation.\n\t */\n\tsetSelected(anno, on = true) {\n\t\tfor (let a of this.svgElement.querySelectorAll(`[data-annotation=\"${anno.id}\"]`))\n\t\t\ta.classList.toggle('selected', on);\n\n\t\tsuper.setSelected(anno, on);\n\t}\n\n\t/** @ignore */\n\tnewAnnotation(annotation) {\n\t\tlet svg = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement('svg');\n\t\tif (!annotation)\n\t\t\tannotation = new _Annotation__WEBPACK_IMPORTED_MODULE_2__.Annotation({ element: svg, selector_type: 'SvgSelector' });\n\t\treturn super.newAnnotation(annotation)\n\t}\n\n\t/** @ignore */\n\tdraw(transform, viewport) {\n\t\tif (!this.svgElement)\n\t\t\treturn true;\n\t\tthis.svgElement.setAttribute('viewBox', `${-viewport.w / 2} ${-viewport.h / 2} ${viewport.w} ${viewport.h}`);\n\n\t\tconst svgTransform = this.getSvgGroupTransform(transform);\n\t\tthis.svgGroup.setAttribute(\"transform\",\tsvgTransform);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Return the string containing the transform for drawing the svg group in the proper position\n\t * @param {Transform} transform current transform parameter of the draw function\n\t * @param {bool} inverse when its false return the transform needed to draw the svgGroup\n\t * @returns string with svgroup transform \n\t */\n\tgetSvgGroupTransform(transform, inverse=false) {\n\t\tlet t = this.transform.compose(transform);\n\t\tlet c = this.boundingBox().corner(0);\n\t\t// FIXME CHECK IT: Convert from GL to SVG, but without any scaling. It just needs to reflect around 0,\n\t\tt = _CoordinateSystem__WEBPACK_IMPORTED_MODULE_4__.CoordinateSystem.reflectY(t);\n\t\treturn inverse ?\n\t\t `translate(${-c.x} ${-c.y})  scale(${1/t.z} ${1/t.z}) rotate(${t.a} 0 0) translate(${-t.x} ${-t.y})` :\n\t\t `translate(${t.x} ${t.y}) rotate(${-t.a} 0 0) scale(${t.z} ${t.z}) translate(${c.x} ${c.y})`;\n\t}\n\n\t/** @ignore */\n\tprefetch(transform) {\n\t\tif (!this.svgElement)\n\t\t\tthis.createOverlaySVGElement();\n\n\t\tif (!this.visible) return;\n\t\tif (this.status != 'ready')\n\t\t\treturn;\n\n\t\tif (typeof (this.annotations) == \"string\") return; //FIXME Is it right? Should we use this.status?\n\n\t\tconst bBox = this.boundingBox();\n\t\tthis.svgElement.setAttribute('viewBox', `${bBox.xLow} ${bBox.yLow} ${bBox.xHigh - bBox.xLow} ${bBox.yHigh - bBox.yLow}`);\n\n\t\t//find which annotations needs to be added to the ccanvas, some \n\t\t//indexing whould be used, for the moment we just iterate all of them.\n\n\t\tfor (let anno of this.annotations) {\n\n\t\t\t//TODO check for class visibility and bbox culling (or maybe should go to prefetch?)\n\t\t\tif (!anno.ready && typeof anno.svg == 'string') {\n\t\t\t\tlet parser = new DOMParser();\n\t\t\t\tlet element = parser.parseFromString(anno.svg, \"image/svg+xml\").documentElement;\n\t\t\t\tanno.elements = [...element.children]\n\t\t\t\tanno.ready = true;\n\n\t\t\t\t/*\t\t\t\t} else if(this.svgXML) {\n\t\t\t\t\t\t\t\t\ta.svgElement = this.svgXML.querySelector(`#${a.id}`);\n\t\t\t\t\t\t\t\t\tif(!a.svgElement)\n\t\t\t\t\t\t\t\t\t\tthrow Error(`Could not find element with id: ${id} in svg`);\n\t\t\t\t\t\t\t\t} */\n\t\t\t}\n\n\t\t\tif(this.annotationUpdate)\n    \t\t\t\tthis.annotationUpdate(anno, transform);\n\n\t\t\tif (!anno.needsUpdate)\n\t\t\t\tcontinue;\n\n\t\t\tanno.needsUpdate = false;\n\n\t\t\tfor (let e of this.svgGroup.querySelectorAll(`[data-annotation=\"${anno.id}\"]`))\n\t\t\t\te.remove();\n\n\t\t\tif (!anno.visible)\n\t\t\t\tcontinue;\n\n\t\t\t//second time will be 0 elements, but we need to \n\t\t\t//store somewhere knowledge of which items in the scene and which still not.\n\t\t\tfor (let child of anno.elements) {\n\t\t\t\tlet c = child; //.cloneNode(true);\n\t\t\t\tc.setAttribute('data-annotation', anno.id);\n\t\t\t\tc.setAttribute('data-class', anno.class);\n\n\t\t\t\t//c.setAttribute('data-layer', this.id);\n\t\t\t\tc.classList.add('openlime-annotation');\n\t\t\t\tif (this.selected.has(anno.id))\n\t\t\t\t\tc.classList.add('selected');\n\t\t\t\tthis.svgGroup.appendChild(c);\n\t\t\t\tc.onpointerdown = (e) => {\n\t\t\t\t\tif (e.button == 0) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\tif (this.onClick && this.onClick(anno))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tif (this.selected.has(anno.id))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tthis.clearSelected();\n\t\t\t\t\t\tthis.setSelected(anno, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t//utils\n\n\t\t\t\t/*\t\t\t\tlet parser = new DOMParser();\n\t\t\t\t\t\t\t\tlet use = createElement('use', { 'xlink:href': '#' + a.id,  'stroke-width': 10,  'pointer-events': 'stroke' });\n\t\t\t\t\t\t\t\t//let use = parser.parseFromString(`<use xlink:href=\"${a.id}\" stroke-width=\"10\" pointer-events=\"stroke\"/>`, \"image/svg+xml\");\n\t\t\t\t\t\t\t\tthis.svgGroup.appendChild(use);  */\n\t\t\t}\n\t\t}\n\t}\n}\n\n_Layer__WEBPACK_IMPORTED_MODULE_1__.Layer.prototype.types.svg_annotations = (options) => { return new LayerSvgAnnotation(options); }\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTs7QUFFQSx5RUFBd0Msa0JBQWtCOztBQUU3QiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL0xheWVyU3ZnQW5ub3RhdGlvbi5qcz80ZTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFV0aWwgfSBmcm9tICcuL1V0aWwnXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4vTGF5ZXInXG5pbXBvcnQgeyBBbm5vdGF0aW9uIH0gZnJvbSAnLi9Bbm5vdGF0aW9uJ1xuaW1wb3J0IHsgTGF5ZXJBbm5vdGF0aW9uIH0gZnJvbSAnLi9MYXllckFubm90YXRpb24nXG5pbXBvcnQgeyBDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi9Db29yZGluYXRlU3lzdGVtJztcblxuLyoqXG4gKiBFbGVtZW50cyB0byBjbGFzc2lmeSB0aGUgYW5ub3RhdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbm5vdGF0aW9uQ2xhc3NcbiAqIEBwcm9wZXJ0eSB7Y29sb3J9IHN0cm9rZSBUaGUgQ1NTIGNvbG9yIG9mIGEgbGluZSwgdGV4dCBvciBvdXRsaW5lIFNWRyBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsIFRoZSBjbGFzcyBuYW1lLlxuICovXG4vKipcbiAqIEFubm90YXRpb24gY2xhc3Nlcy5cbiAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZywgQW5ub3RhdGlvbkNsYXNzPn0gQW5ub3RhdGlvbkNsYXNzZXNcbiAqL1xuXG5cbi8qKlxuICogQW4gYW5ub3RhdGlvbiBsYXllciB0aGF0IGRyYXdzIFNWRyBlbGVtZW50cyBkaXJlY3RseSBvbiB0aGUgY2FudmFzIChvdXRzaWRlIHRoZSBXZWJHTCBjb250ZXh0KS5cbiAqIFxuICogSGVyZSB5b3Ugd2lsbCBmaW5kIGEgdHV0b3JpYWwgdG8gbGVhcm4gaG93IHRvIGJ1aWxkIGEgY2xpZW50LXNlcnZlciBhcmNoaXRlY3R1cmUgdG8gbWFuYWdlIGFubm90YXRpb25zIGluIE9wZW5MSU1FLiAvL0ZJWE1FXG4gKiBcbiAqIEV4dGVuZHMge0BsaW5rIExheWVyQW5ub3RhdGlvbn0uXG4gKi9cbmNsYXNzIExheWVyU3ZnQW5ub3RhdGlvbiBleHRlbmRzIExheWVyQW5ub3RhdGlvbiB7XG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZXMgYSBMYXllclN2Z0Fubm90YXRpb24gb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggb3B0aW9ucyB0aGF0IGluaGVyaXRzIGZyb20ge0BsaW5rIExheWVyQW5ub3RhdGlvbn0uXG4gXHQgKiBAcGFyYW0ge0Fubm90YXRpb25DbGFzc2VzfSBvcHRpb25zLmNsYXNzZXMgQW4gb2JqZWN0IGxpdGVyYWwgZGVmaW55aW5nIGNvbG9ycyBhbmQgbGFiZWxzIG9mIHRoZSBhbm5vdGF0aW9uIGNsYXNzZXMuXG4gXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uQ2xpY2sgVGhlIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgYW4gYW5ub3RhdGlvbiBpcyBjbGlja2VkIG9uIHRoZSBjYW52YXMuIFRoZSBjYWxsYmFjayBpcyBwYXNzZWQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIGFubm90YXRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbH0gb3B0aW9ucy5zaGFkb3c9dHJ1ZSBXaGV0aGVyIHRvIGluc2VydCBTVkcgZWxlbWVudHMgaW4gYSBzaGFkb3cgRE9NLlxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdG92ZXJsYXlFbGVtZW50OiBudWxsLCAgIC8vcmVmZXJlbmNlIHRvIGNhbnZhcyBvdmVybGF5RWxlbWVudC4gVE9ETzogY2hlY2sgaWYgcmVhbGx5IG5lZWRlZC5cblx0XHRcdHNoYWRvdzogdHJ1ZSwgICAgICAgICAgIC8vc3ZnIGF0dGFjaGVkIGFzIHNoYWRvdyBub2RlIChzbyBzdHlsZSBhcHBseSBvbmx5IHRoZSBzdmcgbGF5ZXIpXG5cdFx0XHRzdmdFbGVtZW50OiBudWxsLCBcdFx0Ly90aGUgc3ZnIGxheWVyXG5cdFx0XHRzdmdHcm91cDogbnVsbCxcblx0XHRcdG9uQ2xpY2s6IG51bGwsXHRcdFx0Ly9jYWxsYmFjayBmdW5jdGlvblxuXHRcdFx0Y2xhc3Nlczoge1xuXHRcdFx0XHQnJzogeyBzdHlsZTogeyBzdHJva2U6ICcjMDAwJyB9LCBsYWJlbDogJycgfSxcblx0XHRcdH0sXG5cdFx0XHRhbm5vdGF0aW9uVXBkYXRlOiBudWxsXG5cdFx0fSwgb3B0aW9ucyk7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0Zm9yKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNsYXNzZXMpKSB7XG5cdFx0XHR0aGlzLnN0eWxlICs9IGBbZGF0YS1jbGFzcz0ke2tleX1dIHsgYCArIE9iamVjdC5lbnRyaWVzKHZhbHVlLnN0eWxlKS5tYXAoIGcgPT4gYCR7Z1swXX06ICR7Z1sxXX07YCkuam9pbignXFxuJykgKyAnfSc7XG5cdFx0fVxuXHRcdC8vdGhpcy5jcmVhdGVPdmVybGF5U1ZHRWxlbWVudCgpO1xuXHRcdC8vdGhpcy5zZXRMYXlvdXQodGhpcy5sYXlvdXQpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0Y3JlYXRlT3ZlcmxheVNWR0VsZW1lbnQoKSB7IFxuXHRcdHRoaXMuc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG5cdFx0dGhpcy5zdmdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ29wZW5saW1lLXN2Z292ZXJsYXknKTtcblx0XHR0aGlzLnN2Z0dyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdnJyk7XG5cdFx0dGhpcy5zdmdFbGVtZW50LmFwcGVuZCh0aGlzLnN2Z0dyb3VwKTtcblxuXHRcdGxldCByb290ID0gdGhpcy5vdmVybGF5RWxlbWVudDtcblx0XHRpZiAodGhpcy5zaGFkb3cpXG5cdFx0XHRyb290ID0gdGhpcy5vdmVybGF5RWxlbWVudC5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcblxuXHRcdGlmICh0aGlzLnN0eWxlKSB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0XHRzdHlsZS50ZXh0Q29udGVudCA9IHRoaXMuc3R5bGU7XG5cdFx0XHRyb290LmFwcGVuZChzdHlsZSk7XG5cdFx0fVxuXHRcdHJvb3QuYXBwZW5kQ2hpbGQodGhpcy5zdmdFbGVtZW50KTtcblx0fVxuXHQvKiAgdW51c2VkIGZvciB0aGUgbW9tZW50ISEhIFxuXHRcdGFzeW5jIGxvYWRTVkcodXJsKSB7XG5cdFx0XHR2YXIgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuXHRcdFx0aWYgKCFyZXNwb25zZS5vaykge1xuXHRcdFx0XHR0aGlzLnN0YXR1cyA9IFwiRmFpbGVkIGxvYWRpbmcgXCIgKyB0aGlzLnVybCArIFwiOiBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGxldCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXHRcdFx0bGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdHRoaXMuc3ZnWE1MID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCBcImltYWdlL3N2Zyt4bWxcIikuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0dGhyb3cgXCJpZiB2aWV3Ym94IGlzIHNldCBpbiBzdmdVUkwgc2hvdWxkIGl0IG92ZXJ3cml0ZSBvcHRpb25zLnZpZXdib3ggb3IgdmljZXZlcnNhP1wiXG5cdFx0fVxuXHQqL1xuXG5cdC8qKlxuXHQgKiBTZXRzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cblx0ICogQHBhcmFtIHtib29sfSB2aXNpYmxlIFRoZSB2YWx1ZS5cblx0ICovXG5cdHNldFZpc2libGUodmlzaWJsZSkge1xuXHRcdGlmICh0aGlzLnN2Z0VsZW1lbnQpXG5cdFx0XHR0aGlzLnN2Z0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdHN1cGVyLnNldFZpc2libGUodmlzaWJsZSk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRjbGVhclNlbGVjdGVkKCkge1xuXHRcdGlmICghdGhpcy5zdmdFbGVtZW50KSB0aGlzLmNyZWF0ZU92ZXJsYXlTVkdFbGVtZW50KCk7XG5cdFx0Ly9cdFx0cmV0dXJuO1xuXHRcdHRoaXMuc3ZnR3JvdXAucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYW5ub3RhdGlvbl0nKS5mb3JFYWNoKChlKSA9PiBlLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpO1xuXHRcdHN1cGVyLmNsZWFyU2VsZWN0ZWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWxlY3RzL2Rlc2VsZWN0cyBhbiBhbm5vdGF0aW9uXG5cdCAqIEBwYXJhbSB7QW5ub3RhdGlvbn0gYW5ubyBUaGUgYW5ub3RhdGlvbi5cblx0ICogQHBhcmFtIHtib29sfSBvbj10cnVlIFdoZXRoZXIgdG8gc2VsZWN0IHRoZSBhbm5vdGF0aW9uLlxuXHQgKi9cblx0c2V0U2VsZWN0ZWQoYW5ubywgb24gPSB0cnVlKSB7XG5cdFx0Zm9yIChsZXQgYSBvZiB0aGlzLnN2Z0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtYW5ub3RhdGlvbj1cIiR7YW5uby5pZH1cIl1gKSlcblx0XHRcdGEuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnLCBvbik7XG5cblx0XHRzdXBlci5zZXRTZWxlY3RlZChhbm5vLCBvbik7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRuZXdBbm5vdGF0aW9uKGFubm90YXRpb24pIHtcblx0XHRsZXQgc3ZnID0gVXRpbC5jcmVhdGVTVkdFbGVtZW50KCdzdmcnKTtcblx0XHRpZiAoIWFubm90YXRpb24pXG5cdFx0XHRhbm5vdGF0aW9uID0gbmV3IEFubm90YXRpb24oeyBlbGVtZW50OiBzdmcsIHNlbGVjdG9yX3R5cGU6ICdTdmdTZWxlY3RvcicgfSk7XG5cdFx0cmV0dXJuIHN1cGVyLm5ld0Fubm90YXRpb24oYW5ub3RhdGlvbilcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGRyYXcodHJhbnNmb3JtLCB2aWV3cG9ydCkge1xuXHRcdGlmICghdGhpcy5zdmdFbGVtZW50KVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0dGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIGAkey12aWV3cG9ydC53IC8gMn0gJHstdmlld3BvcnQuaCAvIDJ9ICR7dmlld3BvcnQud30gJHt2aWV3cG9ydC5ofWApO1xuXG5cdFx0Y29uc3Qgc3ZnVHJhbnNmb3JtID0gdGhpcy5nZXRTdmdHcm91cFRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXHRcdHRoaXMuc3ZnR3JvdXAuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsXHRzdmdUcmFuc2Zvcm0pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHRyYW5zZm9ybSBmb3IgZHJhd2luZyB0aGUgc3ZnIGdyb3VwIGluIHRoZSBwcm9wZXIgcG9zaXRpb25cblx0ICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSBjdXJyZW50IHRyYW5zZm9ybSBwYXJhbWV0ZXIgb2YgdGhlIGRyYXcgZnVuY3Rpb25cblx0ICogQHBhcmFtIHtib29sfSBpbnZlcnNlIHdoZW4gaXRzIGZhbHNlIHJldHVybiB0aGUgdHJhbnNmb3JtIG5lZWRlZCB0byBkcmF3IHRoZSBzdmdHcm91cFxuXHQgKiBAcmV0dXJucyBzdHJpbmcgd2l0aCBzdmdyb3VwIHRyYW5zZm9ybSBcblx0ICovXG5cdGdldFN2Z0dyb3VwVHJhbnNmb3JtKHRyYW5zZm9ybSwgaW52ZXJzZT1mYWxzZSkge1xuXHRcdGxldCB0ID0gdGhpcy50cmFuc2Zvcm0uY29tcG9zZSh0cmFuc2Zvcm0pO1xuXHRcdGxldCBjID0gdGhpcy5ib3VuZGluZ0JveCgpLmNvcm5lcigwKTtcblx0XHQvLyBGSVhNRSBDSEVDSyBJVDogQ29udmVydCBmcm9tIEdMIHRvIFNWRywgYnV0IHdpdGhvdXQgYW55IHNjYWxpbmcuIEl0IGp1c3QgbmVlZHMgdG8gcmVmbGVjdCBhcm91bmQgMCxcblx0XHR0ID0gQ29vcmRpbmF0ZVN5c3RlbS5yZWZsZWN0WSh0KTtcblx0XHRyZXR1cm4gaW52ZXJzZSA/XG5cdFx0IGB0cmFuc2xhdGUoJHstYy54fSAkey1jLnl9KSAgc2NhbGUoJHsxL3Quen0gJHsxL3Quen0pIHJvdGF0ZSgke3QuYX0gMCAwKSB0cmFuc2xhdGUoJHstdC54fSAkey10Lnl9KWAgOlxuXHRcdCBgdHJhbnNsYXRlKCR7dC54fSAke3QueX0pIHJvdGF0ZSgkey10LmF9IDAgMCkgc2NhbGUoJHt0Lnp9ICR7dC56fSkgdHJhbnNsYXRlKCR7Yy54fSAke2MueX0pYDtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHByZWZldGNoKHRyYW5zZm9ybSkge1xuXHRcdGlmICghdGhpcy5zdmdFbGVtZW50KVxuXHRcdFx0dGhpcy5jcmVhdGVPdmVybGF5U1ZHRWxlbWVudCgpO1xuXG5cdFx0aWYgKCF0aGlzLnZpc2libGUpIHJldHVybjtcblx0XHRpZiAodGhpcy5zdGF0dXMgIT0gJ3JlYWR5Jylcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICh0eXBlb2YgKHRoaXMuYW5ub3RhdGlvbnMpID09IFwic3RyaW5nXCIpIHJldHVybjsgLy9GSVhNRSBJcyBpdCByaWdodD8gU2hvdWxkIHdlIHVzZSB0aGlzLnN0YXR1cz9cblxuXHRcdGNvbnN0IGJCb3ggPSB0aGlzLmJvdW5kaW5nQm94KCk7XG5cdFx0dGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIGAke2JCb3gueExvd30gJHtiQm94LnlMb3d9ICR7YkJveC54SGlnaCAtIGJCb3gueExvd30gJHtiQm94LnlIaWdoIC0gYkJveC55TG93fWApO1xuXG5cdFx0Ly9maW5kIHdoaWNoIGFubm90YXRpb25zIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBjY2FudmFzLCBzb21lIFxuXHRcdC8vaW5kZXhpbmcgd2hvdWxkIGJlIHVzZWQsIGZvciB0aGUgbW9tZW50IHdlIGp1c3QgaXRlcmF0ZSBhbGwgb2YgdGhlbS5cblxuXHRcdGZvciAobGV0IGFubm8gb2YgdGhpcy5hbm5vdGF0aW9ucykge1xuXG5cdFx0XHQvL1RPRE8gY2hlY2sgZm9yIGNsYXNzIHZpc2liaWxpdHkgYW5kIGJib3ggY3VsbGluZyAob3IgbWF5YmUgc2hvdWxkIGdvIHRvIHByZWZldGNoPylcblx0XHRcdGlmICghYW5uby5yZWFkeSAmJiB0eXBlb2YgYW5uby5zdmcgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0bGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0bGV0IGVsZW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGFubm8uc3ZnLCBcImltYWdlL3N2Zyt4bWxcIikuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRhbm5vLmVsZW1lbnRzID0gWy4uLmVsZW1lbnQuY2hpbGRyZW5dXG5cdFx0XHRcdGFubm8ucmVhZHkgPSB0cnVlO1xuXG5cdFx0XHRcdC8qXHRcdFx0XHR9IGVsc2UgaWYodGhpcy5zdmdYTUwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGEuc3ZnRWxlbWVudCA9IHRoaXMuc3ZnWE1MLnF1ZXJ5U2VsZWN0b3IoYCMke2EuaWR9YCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZighYS5zdmdFbGVtZW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBFcnJvcihgQ291bGQgbm90IGZpbmQgZWxlbWVudCB3aXRoIGlkOiAke2lkfSBpbiBzdmdgKTtcblx0XHRcdFx0XHRcdFx0XHR9ICovXG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuYW5ub3RhdGlvblVwZGF0ZSlcbiAgICBcdFx0XHRcdHRoaXMuYW5ub3RhdGlvblVwZGF0ZShhbm5vLCB0cmFuc2Zvcm0pO1xuXG5cdFx0XHRpZiAoIWFubm8ubmVlZHNVcGRhdGUpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRhbm5vLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdGZvciAobGV0IGUgb2YgdGhpcy5zdmdHcm91cC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1hbm5vdGF0aW9uPVwiJHthbm5vLmlkfVwiXWApKVxuXHRcdFx0XHRlLnJlbW92ZSgpO1xuXG5cdFx0XHRpZiAoIWFubm8udmlzaWJsZSlcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vc2Vjb25kIHRpbWUgd2lsbCBiZSAwIGVsZW1lbnRzLCBidXQgd2UgbmVlZCB0byBcblx0XHRcdC8vc3RvcmUgc29tZXdoZXJlIGtub3dsZWRnZSBvZiB3aGljaCBpdGVtcyBpbiB0aGUgc2NlbmUgYW5kIHdoaWNoIHN0aWxsIG5vdC5cblx0XHRcdGZvciAobGV0IGNoaWxkIG9mIGFubm8uZWxlbWVudHMpIHtcblx0XHRcdFx0bGV0IGMgPSBjaGlsZDsgLy8uY2xvbmVOb2RlKHRydWUpO1xuXHRcdFx0XHRjLnNldEF0dHJpYnV0ZSgnZGF0YS1hbm5vdGF0aW9uJywgYW5uby5pZCk7XG5cdFx0XHRcdGMuc2V0QXR0cmlidXRlKCdkYXRhLWNsYXNzJywgYW5uby5jbGFzcyk7XG5cblx0XHRcdFx0Ly9jLnNldEF0dHJpYnV0ZSgnZGF0YS1sYXllcicsIHRoaXMuaWQpO1xuXHRcdFx0XHRjLmNsYXNzTGlzdC5hZGQoJ29wZW5saW1lLWFubm90YXRpb24nKTtcblx0XHRcdFx0aWYgKHRoaXMuc2VsZWN0ZWQuaGFzKGFubm8uaWQpKVxuXHRcdFx0XHRcdGMuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0dGhpcy5zdmdHcm91cC5hcHBlbmRDaGlsZChjKTtcblx0XHRcdFx0Yy5vbnBvaW50ZXJkb3duID0gKGUpID0+IHtcblx0XHRcdFx0XHRpZiAoZS5idXR0b24gPT0gMCkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm9uQ2xpY2sgJiYgdGhpcy5vbkNsaWNrKGFubm8pKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5zZWxlY3RlZC5oYXMoYW5uby5pZCkpXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdHRoaXMuY2xlYXJTZWxlY3RlZCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRTZWxlY3RlZChhbm5vLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vdXRpbHNcblxuXHRcdFx0XHQvKlx0XHRcdFx0bGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0XHRcdFx0XHRsZXQgdXNlID0gY3JlYXRlRWxlbWVudCgndXNlJywgeyAneGxpbms6aHJlZic6ICcjJyArIGEuaWQsICAnc3Ryb2tlLXdpZHRoJzogMTAsICAncG9pbnRlci1ldmVudHMnOiAnc3Ryb2tlJyB9KTtcblx0XHRcdFx0XHRcdFx0XHQvL2xldCB1c2UgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGA8dXNlIHhsaW5rOmhyZWY9XCIke2EuaWR9XCIgc3Ryb2tlLXdpZHRoPVwiMTBcIiBwb2ludGVyLWV2ZW50cz1cInN0cm9rZVwiLz5gLCBcImltYWdlL3N2Zyt4bWxcIik7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zdmdHcm91cC5hcHBlbmRDaGlsZCh1c2UpOyAgKi9cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuTGF5ZXIucHJvdG90eXBlLnR5cGVzWydzdmdfYW5ub3RhdGlvbnMnXSA9IChvcHRpb25zKSA9PiB7IHJldHVybiBuZXcgTGF5ZXJTdmdBbm5vdGF0aW9uKG9wdGlvbnMpOyB9XG5cbmV4cG9ydCB7IExheWVyU3ZnQW5ub3RhdGlvbiB9XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LayerSvgAnnotation.js\n");

/***/ }),

/***/ "./src/Layout.js":
/*!***********************!*\
  !*** ./src/Layout.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Layout\": () => (/* binding */ Layout)\n/* harmony export */ });\n/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox */ \"./src/BoundingBox.js\");\n/* harmony import */ var _Signals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Signals */ \"./src/Signals.js\");\n/* harmony import */ var _Tile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Tile */ \"./src/Tile.js\");\n/* harmony import */ var _CoordinateSystem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CoordinateSystem */ \"./src/CoordinateSystem.js\");\n\n\n\n\n\n// Tile level x y  index ----- tex missing() start/end (tarzoom) ----- time, priority size(byte)\n\n/**\n * A tile represents a single element of a regular grid that subdivides an image.\n * A tile is identified by its position (`x`, `y`) within the grid and the zoom `level` of the image.\n * @typedef {Object} Tile\n * @property {number} level The zoom level of the tile.\n * @property {number} x x position of the tile in the grid.\n * @property {number} y y position of the tile in the grid.\n * @property {number} index Unique tile identifier.\n * @property {number} start The position of the first byte of the tile in the image dataset (used only for tarzoom and itarzoom image formats).\n * @property {number} end The position of the last byte of the tile in the image dataset (used only for tarzoom and itarzoom image formats).\n * @property {number} missing In the case of multi-channel formats (RTI, BRDF), the information content of a tile is distributed over several planes (channels). \n * `missing` represents the number of pending channel data requests.\n * @property {Array} tex A array of WebGLTexture (one texture per channel).\n * @property {time} time Tile creation time (this value is used internally by the cache algorithms).\n * @property {number} priority The priority of the tile (this value is used internally by the cache algorithms).\n * @property {number} size The total size of the tile in bytes (this value is used internally by the cache algorithms).\n */\n\n/**\n* The type of the image. All web single-resolution image types (*jpg*, *png*, *gif*, etc...) are supported\n* as well as the most common multi-resolution image formats (*deepzoom*, *zoomify*, *IIIF*, *google maps*).\n* @typedef {('image'|'deepzoom'|'deepzoom1px'|'google'|'zoomify'|'iiif'|'tarzoom'|'itarzoom')} Layout#Type\n*/\n\n/**\n * The Layout class is responsible for specifying the data formats (images) managed by OpenLIME.\n * All web single-resolution image types (*jpg*, *png*, *gif*, etc...) are supported as well as the most common \n * tiled image formats (*deepzoom*, *zoomify*, *IIIF*, *google maps*), which are suitable for large images.\n * #### Single-resolution images\n * The URL is the address of the file (for instance, 'https://my.example/image.jpg').\n * #### Tiled images\n * They can be specified in a variety of ways depending on the format chosen.\n * * **deepzoom** - The root tile of the image pyramid has a size > 1px (typical value is 254px). It is defined by the URL of the *.dzi* file \n * (for instance, 'https://my.example/image.dzi'). See: {@link https://docs.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc645077(v=vs.95)?redirectedfrom=MSDN DeepZoom}\n * * **deepzoom1px** - The root tile of the image pyramid has a size = 1px. It is defined by the URL of the *.dzi* file \n * (for instance, 'https://my.example/image.dzi'). See: {@link https://docs.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc645077(v=vs.95)?redirectedfrom=MSDN DeepZoom}\n * * **google** - The URL points directly to the directory containing the pyramid of images (for instance, 'https://my.example/image'). \n * The standard does not require any configuration file, so it is mandatory to indicate in the `options` the \n * width and height in pixels of the original image. See: {@link https://www.microimages.com/documentation/TechGuides/78googleMapsStruc.pdf Google Maps}\n * * **zoomify** - The URL indicates the location of Zoomify configuration file (for instance, 'https://my.example/image/ImageProperties.xml').\n * See: {@link http://www.zoomify.com/ZIFFileFormatSpecification.htm Zoomify}\n * * **iiif** - According to the standard, the URL is the address of a IIIF server (for instance, 'https://myiiifserver.example/').\n * See: {@link https://iipimage.sourceforge.io/ IIP Server}, {@link https://iiif.io/api/image/3.0/ IIIF }\n * * **tarzoom** and **itarzoom** - This is a custom format of the OpenLIME framework. It can be described as the TAR of a DeepZoom (all the DeepZoom image pyramid is stored in a single file).\n * It takes advantage of the fact that current web servers are able to handle partial-content HTTP requests. Tarzoom facilitates\n * the work of the server, which is not penalised by having to manage a file system with many small files. The URL is the address of the *.tzi* file \n * (for instance, 'https://my.example/image.tzi'). Warning: tarzoom|itarzoom may not work on older web servers.\n */\nclass Layout {\n\t/**\n\t* Creates a Layout, a container for a raster image.\n    * A layout is defined by a `url` of the image and a `type`.\n    * Additionally, an object literal with Layout `options` can be specified.\n    * Signals are triggered when the layout is ready to be drawn or its size is modified.\n\t* @param {string} url URL of the image.\n \t* @param {Layout#Type} type The type of the image.\n \t* @param {Object} [options] An object literal describing the layout content.\n \t* @param {number} options.width The total width of the original, unsplit image. This parameter must only be specified for the 'google' layout type. \n \t* @param {number} options.height The total height of the original, unsplit image. This parameter must only be specified for the 'google' layout type.\n \t* @param {string} options.suffix='jpg' The filename suffix of the tiles.\n \t* @param {string} options.subdomains='abc' The ('a'|'b'|'c') *s* subdomain of a Google template URL (for instance: 'https:{s}.my.example//{z}/{x}/{y}.png').\n\t*/\n\tconstructor(url, type, options) {\n\n\t\t\n\t\tif (type == 'image') {\n\t\t\tthis.init(url, type, options);\n\t\t\tthis.setDefaults(type);\n\t\t} else if(type in this.types)\n\t\t\treturn this.types[type](url, type, options);\n\t\telse if(type == null)\n\t\t\treturn;\n\t\telse\n\t\t\tthrow \"Layout type: \" + type + \" unknown, or module not loaded\";\n\t}\n\n\tsetDefaults(type) {\n\t\tObject.assign(this, {\n\t\t\ttype: type,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tsuffix: 'jpg',\n\t\t\turls: [],\n\t\t\tstatus: null,\n\t\t\tsubdomains: 'abc'\n\t\t});\n\t}\n\n\tinit(url, type, options) {\n\t\tif(options)\n\t\t\tObject.assign(this, options);\n\n\t\tif(typeof(url) == 'string')\n\t\t\tthis.setUrls([url]);\n\t}\n\n\t/** @ignore */\n\tsetUrls(urls) {\n\t\t/**\n\t\t* The event is fired when a layout is ready to be drawn(the single-resolution image is downloaded or the multi-resolution structure has been initialized).\n\t\t* @event Layout#ready\n\t\t*/\n\t\tthis.urls = urls;\n\t\tthis.getTileURL = (rasterid, tile) => { return this.urls[rasterid]; }\n\t\tthis.status = 'ready';\n\t\tthis.emit('ready');\n\t}\n\n\t\t/**\n\t * Gets the URL of a specific tile. The function must be implemented for each layout type supported by OpenLIME.\n\t * @param {number} id The channel id.\n\t * @param {Tile} tile The tile.\n\t */\n\t getTileURL(id, tile) {\n\t\tthrow Error(\"Layout not defined or ready.\");\n\t}\n\n\t/**\n\t * Gets the layout bounding box.\n\t * @returns {BoundingBox} The layout bounding box.\n\t */\n\tboundingBox() {\n\t\t//if(!this.width) throw \"Layout not initialized still\";\n\t\treturn new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({xLow:-this.width/2, yLow: -this.height/2, xHigh: this.width/2, yHigh: this.height/2});\n\t}\n\n\t/**\n\t* Returns the coordinates of the tile (in [0, 0, w h] image coordinate system) and the texture coords associated. \n \t* @returns the tile coordinates (image coords and texture coords) \n \t*/\n\ttileCoords(tile) {\n\t\tlet w = this.width;\n\t\tlet h = this.height;\n\t\t//careful: here y is inverted due to textures not being flipped on load (Firefox fault!).\n\t\tvar tcoords = new Float32Array([0, 1,     0, 0,     1, 0,     1, 1]);\n\n\t\treturn { \n\t\t\tcoords: new Float32Array([-w/2, -h/2, 0,  -w/2, h/2, 0,  w/2, h/2, 0,  w/2, -h/2, 0]),\n\t\t\ttcoords: tcoords \n\t\t};\n\t}\n\n\tnewTile(index) {\n\t\tlet tile = new _Tile__WEBPACK_IMPORTED_MODULE_2__.Tile();\n\t\ttile.index = index;\n\t\treturn tile;\n\t}\n\n\t/** returns the list of tiles required for a rendering, sorted by priority, max */\n\tneeded(viewport, transform, layerTransform, border, bias, tiles, maxtiles = 8) {\n\t\t//FIXME should check if image is withing the viewport (+ border)\n\t\tlet tile = tiles.get(0) || this.newTile(0); //{ index, x, y, missing, tex: [], level };\n\t\ttile.time = performance.now();\n\t\ttile.priority = 10;\n\n\t\tif (tile.missing === null) // || tile.missing != 0 && !this.requested[index])\n\t\t\treturn [tile];\n\t\treturn [];\n\t}\n\n\t/** returns the list of tiles available for a rendering */\n\tavailable(viewport, transform, layerTransform, border, bias, tiles) {\n\t\t//FIXME should check if image is withing the viewport (+ border)\n\t\tlet torender = {};\n\n\t\tif (tiles.has(0) && tiles.get(0).missing == 0) \n\t\t\ttorender[0] = tiles.get(0); //{ index: index, level: level, x: x >> d, y: y >> d, complete: true };\n\t\treturn torender;\n\t}\n\n\tgetViewportBox(viewport, transform, layerT) {\n\t\tconst boxViewport = new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox({xLow:viewport.x, yLow:viewport.y, xHigh:viewport.x+viewport.dx, yHigh:viewport.y+viewport.dy});\n\t\treturn _CoordinateSystem__WEBPACK_IMPORTED_MODULE_3__.CoordinateSystem.fromViewportBoxToImageBox(boxViewport, transform, viewport, layerT, {w:this.width, h:this.height});\n\t}\n}\n\nLayout.prototype.types = {}\n\n;(0,_Signals__WEBPACK_IMPORTED_MODULE_1__.addSignals)(Layout, 'ready', 'updateSize');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGF5b3V0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ0w7QUFDVDtBQUN3Qjs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1GQUFtRjtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVMsa0RBQWtELEdBQUc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGFBQWE7QUFDekIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUSx5R0FBeUcsRUFBRSxjQUFjLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN2SjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFXLEVBQUUsb0ZBQW9GO0FBQzlHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVDQUFJO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixxREFBVyxFQUFFLDZGQUE2RjtBQUNwSSxTQUFTLHlGQUEwQyw0Q0FBNEMsNEJBQTRCO0FBQzNIO0FBQ0E7O0FBRUE7O0FBRUEscURBQVU7O0FBRU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9MYXlvdXQuanM/Nzk0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gXCIuL0JvdW5kaW5nQm94XCI7XG5pbXBvcnQgeyBhZGRTaWduYWxzIH0gZnJvbSBcIi4vU2lnbmFsc1wiO1xuaW1wb3J0IHsgVGlsZSB9IGZyb20gXCIuL1RpbGVcIjtcbmltcG9ydCB7IENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tIFwiLi9Db29yZGluYXRlU3lzdGVtXCI7XG5cbi8vIFRpbGUgbGV2ZWwgeCB5ICBpbmRleCAtLS0tLSB0ZXggbWlzc2luZygpIHN0YXJ0L2VuZCAodGFyem9vbSkgLS0tLS0gdGltZSwgcHJpb3JpdHkgc2l6ZShieXRlKVxuXG4vKipcbiAqIEEgdGlsZSByZXByZXNlbnRzIGEgc2luZ2xlIGVsZW1lbnQgb2YgYSByZWd1bGFyIGdyaWQgdGhhdCBzdWJkaXZpZGVzIGFuIGltYWdlLlxuICogQSB0aWxlIGlzIGlkZW50aWZpZWQgYnkgaXRzIHBvc2l0aW9uIChgeGAsIGB5YCkgd2l0aGluIHRoZSBncmlkIGFuZCB0aGUgem9vbSBgbGV2ZWxgIG9mIHRoZSBpbWFnZS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdGlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIHRpbGUgaW4gdGhlIGdyaWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIHRoZSBncmlkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4IFVuaXF1ZSB0aWxlIGlkZW50aWZpZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnQgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBieXRlIG9mIHRoZSB0aWxlIGluIHRoZSBpbWFnZSBkYXRhc2V0ICh1c2VkIG9ubHkgZm9yIHRhcnpvb20gYW5kIGl0YXJ6b29tIGltYWdlIGZvcm1hdHMpLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZCBUaGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgYnl0ZSBvZiB0aGUgdGlsZSBpbiB0aGUgaW1hZ2UgZGF0YXNldCAodXNlZCBvbmx5IGZvciB0YXJ6b29tIGFuZCBpdGFyem9vbSBpbWFnZSBmb3JtYXRzKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXNzaW5nIEluIHRoZSBjYXNlIG9mIG11bHRpLWNoYW5uZWwgZm9ybWF0cyAoUlRJLCBCUkRGKSwgdGhlIGluZm9ybWF0aW9uIGNvbnRlbnQgb2YgYSB0aWxlIGlzIGRpc3RyaWJ1dGVkIG92ZXIgc2V2ZXJhbCBwbGFuZXMgKGNoYW5uZWxzKS4gXG4gKiBgbWlzc2luZ2AgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgY2hhbm5lbCBkYXRhIHJlcXVlc3RzLlxuICogQHByb3BlcnR5IHtBcnJheX0gdGV4IEEgYXJyYXkgb2YgV2ViR0xUZXh0dXJlIChvbmUgdGV4dHVyZSBwZXIgY2hhbm5lbCkuXG4gKiBAcHJvcGVydHkge3RpbWV9IHRpbWUgVGlsZSBjcmVhdGlvbiB0aW1lICh0aGlzIHZhbHVlIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgY2FjaGUgYWxnb3JpdGhtcykuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJpb3JpdHkgVGhlIHByaW9yaXR5IG9mIHRoZSB0aWxlICh0aGlzIHZhbHVlIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgY2FjaGUgYWxnb3JpdGhtcykuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZSBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgdGlsZSBpbiBieXRlcyAodGhpcyB2YWx1ZSBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIGNhY2hlIGFsZ29yaXRobXMpLlxuICovXG5cbi8qKlxuKiBUaGUgdHlwZSBvZiB0aGUgaW1hZ2UuIEFsbCB3ZWIgc2luZ2xlLXJlc29sdXRpb24gaW1hZ2UgdHlwZXMgKCpqcGcqLCAqcG5nKiwgKmdpZiosIGV0Yy4uLikgYXJlIHN1cHBvcnRlZFxuKiBhcyB3ZWxsIGFzIHRoZSBtb3N0IGNvbW1vbiBtdWx0aS1yZXNvbHV0aW9uIGltYWdlIGZvcm1hdHMgKCpkZWVwem9vbSosICp6b29taWZ5KiwgKklJSUYqLCAqZ29vZ2xlIG1hcHMqKS5cbiogQHR5cGVkZWYgeygnaW1hZ2UnfCdkZWVwem9vbSd8J2RlZXB6b29tMXB4J3wnZ29vZ2xlJ3wnem9vbWlmeSd8J2lpaWYnfCd0YXJ6b29tJ3wnaXRhcnpvb20nKX0gTGF5b3V0I1R5cGVcbiovXG5cbi8qKlxuICogVGhlIExheW91dCBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3Igc3BlY2lmeWluZyB0aGUgZGF0YSBmb3JtYXRzIChpbWFnZXMpIG1hbmFnZWQgYnkgT3BlbkxJTUUuXG4gKiBBbGwgd2ViIHNpbmdsZS1yZXNvbHV0aW9uIGltYWdlIHR5cGVzICgqanBnKiwgKnBuZyosICpnaWYqLCBldGMuLi4pIGFyZSBzdXBwb3J0ZWQgYXMgd2VsbCBhcyB0aGUgbW9zdCBjb21tb24gXG4gKiB0aWxlZCBpbWFnZSBmb3JtYXRzICgqZGVlcHpvb20qLCAqem9vbWlmeSosICpJSUlGKiwgKmdvb2dsZSBtYXBzKiksIHdoaWNoIGFyZSBzdWl0YWJsZSBmb3IgbGFyZ2UgaW1hZ2VzLlxuICogIyMjIyBTaW5nbGUtcmVzb2x1dGlvbiBpbWFnZXNcbiAqIFRoZSBVUkwgaXMgdGhlIGFkZHJlc3Mgb2YgdGhlIGZpbGUgKGZvciBpbnN0YW5jZSwgJ2h0dHBzOi8vbXkuZXhhbXBsZS9pbWFnZS5qcGcnKS5cbiAqICMjIyMgVGlsZWQgaW1hZ2VzXG4gKiBUaGV5IGNhbiBiZSBzcGVjaWZpZWQgaW4gYSB2YXJpZXR5IG9mIHdheXMgZGVwZW5kaW5nIG9uIHRoZSBmb3JtYXQgY2hvc2VuLlxuICogKiAqKmRlZXB6b29tKiogLSBUaGUgcm9vdCB0aWxlIG9mIHRoZSBpbWFnZSBweXJhbWlkIGhhcyBhIHNpemUgPiAxcHggKHR5cGljYWwgdmFsdWUgaXMgMjU0cHgpLiBJdCBpcyBkZWZpbmVkIGJ5IHRoZSBVUkwgb2YgdGhlICouZHppKiBmaWxlIFxuICogKGZvciBpbnN0YW5jZSwgJ2h0dHBzOi8vbXkuZXhhbXBsZS9pbWFnZS5kemknKS4gU2VlOiB7QGxpbmsgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvd2luZG93cy9zaWx2ZXJsaWdodC9kb3RuZXQtd2luZG93cy1zaWx2ZXJsaWdodC9jYzY0NTA3Nyh2PXZzLjk1KT9yZWRpcmVjdGVkZnJvbT1NU0ROIERlZXBab29tfVxuICogKiAqKmRlZXB6b29tMXB4KiogLSBUaGUgcm9vdCB0aWxlIG9mIHRoZSBpbWFnZSBweXJhbWlkIGhhcyBhIHNpemUgPSAxcHguIEl0IGlzIGRlZmluZWQgYnkgdGhlIFVSTCBvZiB0aGUgKi5kemkqIGZpbGUgXG4gKiAoZm9yIGluc3RhbmNlLCAnaHR0cHM6Ly9teS5leGFtcGxlL2ltYWdlLmR6aScpLiBTZWU6IHtAbGluayBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wcmV2aW91cy12ZXJzaW9ucy93aW5kb3dzL3NpbHZlcmxpZ2h0L2RvdG5ldC13aW5kb3dzLXNpbHZlcmxpZ2h0L2NjNjQ1MDc3KHY9dnMuOTUpP3JlZGlyZWN0ZWRmcm9tPU1TRE4gRGVlcFpvb219XG4gKiAqICoqZ29vZ2xlKiogLSBUaGUgVVJMIHBvaW50cyBkaXJlY3RseSB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIHB5cmFtaWQgb2YgaW1hZ2VzIChmb3IgaW5zdGFuY2UsICdodHRwczovL215LmV4YW1wbGUvaW1hZ2UnKS4gXG4gKiBUaGUgc3RhbmRhcmQgZG9lcyBub3QgcmVxdWlyZSBhbnkgY29uZmlndXJhdGlvbiBmaWxlLCBzbyBpdCBpcyBtYW5kYXRvcnkgdG8gaW5kaWNhdGUgaW4gdGhlIGBvcHRpb25zYCB0aGUgXG4gKiB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuIFNlZToge0BsaW5rIGh0dHBzOi8vd3d3Lm1pY3JvaW1hZ2VzLmNvbS9kb2N1bWVudGF0aW9uL1RlY2hHdWlkZXMvNzhnb29nbGVNYXBzU3RydWMucGRmIEdvb2dsZSBNYXBzfVxuICogKiAqKnpvb21pZnkqKiAtIFRoZSBVUkwgaW5kaWNhdGVzIHRoZSBsb2NhdGlvbiBvZiBab29taWZ5IGNvbmZpZ3VyYXRpb24gZmlsZSAoZm9yIGluc3RhbmNlLCAnaHR0cHM6Ly9teS5leGFtcGxlL2ltYWdlL0ltYWdlUHJvcGVydGllcy54bWwnKS5cbiAqIFNlZToge0BsaW5rIGh0dHA6Ly93d3cuem9vbWlmeS5jb20vWklGRmlsZUZvcm1hdFNwZWNpZmljYXRpb24uaHRtIFpvb21pZnl9XG4gKiAqICoqaWlpZioqIC0gQWNjb3JkaW5nIHRvIHRoZSBzdGFuZGFyZCwgdGhlIFVSTCBpcyB0aGUgYWRkcmVzcyBvZiBhIElJSUYgc2VydmVyIChmb3IgaW5zdGFuY2UsICdodHRwczovL215aWlpZnNlcnZlci5leGFtcGxlLycpLlxuICogU2VlOiB7QGxpbmsgaHR0cHM6Ly9paXBpbWFnZS5zb3VyY2Vmb3JnZS5pby8gSUlQIFNlcnZlcn0sIHtAbGluayBodHRwczovL2lpaWYuaW8vYXBpL2ltYWdlLzMuMC8gSUlJRiB9XG4gKiAqICoqdGFyem9vbSoqIGFuZCAqKml0YXJ6b29tKiogLSBUaGlzIGlzIGEgY3VzdG9tIGZvcm1hdCBvZiB0aGUgT3BlbkxJTUUgZnJhbWV3b3JrLiBJdCBjYW4gYmUgZGVzY3JpYmVkIGFzIHRoZSBUQVIgb2YgYSBEZWVwWm9vbSAoYWxsIHRoZSBEZWVwWm9vbSBpbWFnZSBweXJhbWlkIGlzIHN0b3JlZCBpbiBhIHNpbmdsZSBmaWxlKS5cbiAqIEl0IHRha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IGN1cnJlbnQgd2ViIHNlcnZlcnMgYXJlIGFibGUgdG8gaGFuZGxlIHBhcnRpYWwtY29udGVudCBIVFRQIHJlcXVlc3RzLiBUYXJ6b29tIGZhY2lsaXRhdGVzXG4gKiB0aGUgd29yayBvZiB0aGUgc2VydmVyLCB3aGljaCBpcyBub3QgcGVuYWxpc2VkIGJ5IGhhdmluZyB0byBtYW5hZ2UgYSBmaWxlIHN5c3RlbSB3aXRoIG1hbnkgc21hbGwgZmlsZXMuIFRoZSBVUkwgaXMgdGhlIGFkZHJlc3Mgb2YgdGhlICoudHppKiBmaWxlIFxuICogKGZvciBpbnN0YW5jZSwgJ2h0dHBzOi8vbXkuZXhhbXBsZS9pbWFnZS50emknKS4gV2FybmluZzogdGFyem9vbXxpdGFyem9vbSBtYXkgbm90IHdvcmsgb24gb2xkZXIgd2ViIHNlcnZlcnMuXG4gKi9cbmNsYXNzIExheW91dCB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBMYXlvdXQsIGEgY29udGFpbmVyIGZvciBhIHJhc3RlciBpbWFnZS5cbiAgICAqIEEgbGF5b3V0IGlzIGRlZmluZWQgYnkgYSBgdXJsYCBvZiB0aGUgaW1hZ2UgYW5kIGEgYHR5cGVgLlxuICAgICogQWRkaXRpb25hbGx5LCBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIExheW91dCBgb3B0aW9uc2AgY2FuIGJlIHNwZWNpZmllZC5cbiAgICAqIFNpZ25hbHMgYXJlIHRyaWdnZXJlZCB3aGVuIHRoZSBsYXlvdXQgaXMgcmVhZHkgdG8gYmUgZHJhd24gb3IgaXRzIHNpemUgaXMgbW9kaWZpZWQuXG5cdCogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgb2YgdGhlIGltYWdlLlxuIFx0KiBAcGFyYW0ge0xheW91dCNUeXBlfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBpbWFnZS5cbiBcdCogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCBkZXNjcmliaW5nIHRoZSBsYXlvdXQgY29udGVudC5cbiBcdCogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggVGhlIHRvdGFsIHdpZHRoIG9mIHRoZSBvcmlnaW5hbCwgdW5zcGxpdCBpbWFnZS4gVGhpcyBwYXJhbWV0ZXIgbXVzdCBvbmx5IGJlIHNwZWNpZmllZCBmb3IgdGhlICdnb29nbGUnIGxheW91dCB0eXBlLiBcbiBcdCogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IFRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIG9yaWdpbmFsLCB1bnNwbGl0IGltYWdlLiBUaGlzIHBhcmFtZXRlciBtdXN0IG9ubHkgYmUgc3BlY2lmaWVkIGZvciB0aGUgJ2dvb2dsZScgbGF5b3V0IHR5cGUuXG4gXHQqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN1ZmZpeD0nanBnJyBUaGUgZmlsZW5hbWUgc3VmZml4IG9mIHRoZSB0aWxlcy5cbiBcdCogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ViZG9tYWlucz0nYWJjJyBUaGUgKCdhJ3wnYid8J2MnKSAqcyogc3ViZG9tYWluIG9mIGEgR29vZ2xlIHRlbXBsYXRlIFVSTCAoZm9yIGluc3RhbmNlOiAnaHR0cHM6e3N9Lm15LmV4YW1wbGUvL3t6fS97eH0ve3l9LnBuZycpLlxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIHR5cGUsIG9wdGlvbnMpIHtcblxuXHRcdFxuXHRcdGlmICh0eXBlID09ICdpbWFnZScpIHtcblx0XHRcdHRoaXMuaW5pdCh1cmwsIHR5cGUsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5zZXREZWZhdWx0cyh0eXBlKTtcblx0XHR9IGVsc2UgaWYodHlwZSBpbiB0aGlzLnR5cGVzKVxuXHRcdFx0cmV0dXJuIHRoaXMudHlwZXNbdHlwZV0odXJsLCB0eXBlLCBvcHRpb25zKTtcblx0XHRlbHNlIGlmKHR5cGUgPT0gbnVsbClcblx0XHRcdHJldHVybjtcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyBcIkxheW91dCB0eXBlOiBcIiArIHR5cGUgKyBcIiB1bmtub3duLCBvciBtb2R1bGUgbm90IGxvYWRlZFwiO1xuXHR9XG5cblx0c2V0RGVmYXVsdHModHlwZSkge1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywge1xuXHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwLFxuXHRcdFx0c3VmZml4OiAnanBnJyxcblx0XHRcdHVybHM6IFtdLFxuXHRcdFx0c3RhdHVzOiBudWxsLFxuXHRcdFx0c3ViZG9tYWluczogJ2FiYydcblx0XHR9KTtcblx0fVxuXG5cdGluaXQodXJsLCB0eXBlLCBvcHRpb25zKSB7XG5cdFx0aWYob3B0aW9ucylcblx0XHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cblx0XHRpZih0eXBlb2YodXJsKSA9PSAnc3RyaW5nJylcblx0XHRcdHRoaXMuc2V0VXJscyhbdXJsXSk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRzZXRVcmxzKHVybHMpIHtcblx0XHQvKipcblx0XHQqIFRoZSBldmVudCBpcyBmaXJlZCB3aGVuIGEgbGF5b3V0IGlzIHJlYWR5IHRvIGJlIGRyYXduKHRoZSBzaW5nbGUtcmVzb2x1dGlvbiBpbWFnZSBpcyBkb3dubG9hZGVkIG9yIHRoZSBtdWx0aS1yZXNvbHV0aW9uIHN0cnVjdHVyZSBoYXMgYmVlbiBpbml0aWFsaXplZCkuXG5cdFx0KiBAZXZlbnQgTGF5b3V0I3JlYWR5XG5cdFx0Ki9cblx0XHR0aGlzLnVybHMgPSB1cmxzO1xuXHRcdHRoaXMuZ2V0VGlsZVVSTCA9IChyYXN0ZXJpZCwgdGlsZSkgPT4geyByZXR1cm4gdGhpcy51cmxzW3Jhc3RlcmlkXTsgfVxuXHRcdHRoaXMuc3RhdHVzID0gJ3JlYWR5Jztcblx0XHR0aGlzLmVtaXQoJ3JlYWR5Jyk7XG5cdH1cblxuXHRcdC8qKlxuXHQgKiBHZXRzIHRoZSBVUkwgb2YgYSBzcGVjaWZpYyB0aWxlLiBUaGUgZnVuY3Rpb24gbXVzdCBiZSBpbXBsZW1lbnRlZCBmb3IgZWFjaCBsYXlvdXQgdHlwZSBzdXBwb3J0ZWQgYnkgT3BlbkxJTUUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCBUaGUgY2hhbm5lbCBpZC5cblx0ICogQHBhcmFtIHtUaWxlfSB0aWxlIFRoZSB0aWxlLlxuXHQgKi9cblx0IGdldFRpbGVVUkwoaWQsIHRpbGUpIHtcblx0XHR0aHJvdyBFcnJvcihcIkxheW91dCBub3QgZGVmaW5lZCBvciByZWFkeS5cIik7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgbGF5b3V0IGJvdW5kaW5nIGJveC5cblx0ICogQHJldHVybnMge0JvdW5kaW5nQm94fSBUaGUgbGF5b3V0IGJvdW5kaW5nIGJveC5cblx0ICovXG5cdGJvdW5kaW5nQm94KCkge1xuXHRcdC8vaWYoIXRoaXMud2lkdGgpIHRocm93IFwiTGF5b3V0IG5vdCBpbml0aWFsaXplZCBzdGlsbFwiO1xuXHRcdHJldHVybiBuZXcgQm91bmRpbmdCb3goe3hMb3c6LXRoaXMud2lkdGgvMiwgeUxvdzogLXRoaXMuaGVpZ2h0LzIsIHhIaWdoOiB0aGlzLndpZHRoLzIsIHlIaWdoOiB0aGlzLmhlaWdodC8yfSk7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdGlsZSAoaW4gWzAsIDAsIHcgaF0gaW1hZ2UgY29vcmRpbmF0ZSBzeXN0ZW0pIGFuZCB0aGUgdGV4dHVyZSBjb29yZHMgYXNzb2NpYXRlZC4gXG4gXHQqIEByZXR1cm5zIHRoZSB0aWxlIGNvb3JkaW5hdGVzIChpbWFnZSBjb29yZHMgYW5kIHRleHR1cmUgY29vcmRzKSBcbiBcdCovXG5cdHRpbGVDb29yZHModGlsZSkge1xuXHRcdGxldCB3ID0gdGhpcy53aWR0aDtcblx0XHRsZXQgaCA9IHRoaXMuaGVpZ2h0O1xuXHRcdC8vY2FyZWZ1bDogaGVyZSB5IGlzIGludmVydGVkIGR1ZSB0byB0ZXh0dXJlcyBub3QgYmVpbmcgZmxpcHBlZCBvbiBsb2FkIChGaXJlZm94IGZhdWx0ISkuXG5cdFx0dmFyIHRjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAgICAgMCwgMCwgICAgIDEsIDAsICAgICAxLCAxXSk7XG5cblx0XHRyZXR1cm4geyBcblx0XHRcdGNvb3JkczogbmV3IEZsb2F0MzJBcnJheShbLXcvMiwgLWgvMiwgMCwgIC13LzIsIGgvMiwgMCwgIHcvMiwgaC8yLCAwLCAgdy8yLCAtaC8yLCAwXSksXG5cdFx0XHR0Y29vcmRzOiB0Y29vcmRzIFxuXHRcdH07XG5cdH1cblxuXHRuZXdUaWxlKGluZGV4KSB7XG5cdFx0bGV0IHRpbGUgPSBuZXcgVGlsZSgpO1xuXHRcdHRpbGUuaW5kZXggPSBpbmRleDtcblx0XHRyZXR1cm4gdGlsZTtcblx0fVxuXG5cdC8qKiByZXR1cm5zIHRoZSBsaXN0IG9mIHRpbGVzIHJlcXVpcmVkIGZvciBhIHJlbmRlcmluZywgc29ydGVkIGJ5IHByaW9yaXR5LCBtYXggKi9cblx0bmVlZGVkKHZpZXdwb3J0LCB0cmFuc2Zvcm0sIGxheWVyVHJhbnNmb3JtLCBib3JkZXIsIGJpYXMsIHRpbGVzLCBtYXh0aWxlcyA9IDgpIHtcblx0XHQvL0ZJWE1FIHNob3VsZCBjaGVjayBpZiBpbWFnZSBpcyB3aXRoaW5nIHRoZSB2aWV3cG9ydCAoKyBib3JkZXIpXG5cdFx0bGV0IHRpbGUgPSB0aWxlcy5nZXQoMCkgfHwgdGhpcy5uZXdUaWxlKDApOyAvL3sgaW5kZXgsIHgsIHksIG1pc3NpbmcsIHRleDogW10sIGxldmVsIH07XG5cdFx0dGlsZS50aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0dGlsZS5wcmlvcml0eSA9IDEwO1xuXG5cdFx0aWYgKHRpbGUubWlzc2luZyA9PT0gbnVsbCkgLy8gfHwgdGlsZS5taXNzaW5nICE9IDAgJiYgIXRoaXMucmVxdWVzdGVkW2luZGV4XSlcblx0XHRcdHJldHVybiBbdGlsZV07XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0LyoqIHJldHVybnMgdGhlIGxpc3Qgb2YgdGlsZXMgYXZhaWxhYmxlIGZvciBhIHJlbmRlcmluZyAqL1xuXHRhdmFpbGFibGUodmlld3BvcnQsIHRyYW5zZm9ybSwgbGF5ZXJUcmFuc2Zvcm0sIGJvcmRlciwgYmlhcywgdGlsZXMpIHtcblx0XHQvL0ZJWE1FIHNob3VsZCBjaGVjayBpZiBpbWFnZSBpcyB3aXRoaW5nIHRoZSB2aWV3cG9ydCAoKyBib3JkZXIpXG5cdFx0bGV0IHRvcmVuZGVyID0ge307XG5cblx0XHRpZiAodGlsZXMuaGFzKDApICYmIHRpbGVzLmdldCgwKS5taXNzaW5nID09IDApIFxuXHRcdFx0dG9yZW5kZXJbMF0gPSB0aWxlcy5nZXQoMCk7IC8veyBpbmRleDogaW5kZXgsIGxldmVsOiBsZXZlbCwgeDogeCA+PiBkLCB5OiB5ID4+IGQsIGNvbXBsZXRlOiB0cnVlIH07XG5cdFx0cmV0dXJuIHRvcmVuZGVyO1xuXHR9XG5cblx0Z2V0Vmlld3BvcnRCb3godmlld3BvcnQsIHRyYW5zZm9ybSwgbGF5ZXJUKSB7XG5cdFx0Y29uc3QgYm94Vmlld3BvcnQgPSBuZXcgQm91bmRpbmdCb3goe3hMb3c6dmlld3BvcnQueCwgeUxvdzp2aWV3cG9ydC55LCB4SGlnaDp2aWV3cG9ydC54K3ZpZXdwb3J0LmR4LCB5SGlnaDp2aWV3cG9ydC55K3ZpZXdwb3J0LmR5fSk7XG5cdFx0cmV0dXJuIENvb3JkaW5hdGVTeXN0ZW0uZnJvbVZpZXdwb3J0Qm94VG9JbWFnZUJveChib3hWaWV3cG9ydCwgdHJhbnNmb3JtLCB2aWV3cG9ydCwgbGF5ZXJULCB7dzp0aGlzLndpZHRoLCBoOnRoaXMuaGVpZ2h0fSk7XG5cdH1cbn1cblxuTGF5b3V0LnByb3RvdHlwZS50eXBlcyA9IHt9XG5cbmFkZFNpZ25hbHMoTGF5b3V0LCAncmVhZHknLCAndXBkYXRlU2l6ZScpO1xuXG5leHBvcnQgeyBMYXlvdXQgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Layout.js\n");

/***/ }),

/***/ "./src/PointerManager.js":
/*!*******************************!*\
  !*** ./src/PointerManager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PointerManager\": () => (/* binding */ PointerManager)\n/* harmony export */ });\n/**\n * A **PointerManager** is a high-level class for handling simultaneous events from a DOM `target`. \n * It captures PointerEvent (MouseEvent and TouchEvent) generated by the `target`, classifies them as \"gestures\" and provides a simple interface\n * to work with them. \n * \n * The high-level events (gestures) that are detected and emitted are:\n * * `fingerHover(e)` It is fired when a pointing device is used to move the cursor on the target \n * * `fingerSingleTap(e)` It is fired when the user presses a mouse button quickly or touches the screen shortly with a finger\n * * `fingerDoubleTap(e)` It is fired when the user quickly presses a mouse button twice or shortly touches the screen with a finger twice.\n * * `fingerHold(e)` It is fired when the user keeps pressing a mouse button or touching the screen longer than a threshold (600 ms).\n * * `mouseWheel(e)` It is fired when the user rotates the mouse wheel button.\n * * `panStart(e)` It is fired when the pan gesture is starting.\n * * `panMove(e)` It is fired when the pan gesture is in progress.\n * * `panEnd(e)` It is fired when the pan gesture is finished.\n * * `pinchStart(e1, e2)` It is fired when the pinch gesture is starting.\n * * `pinchMove(e1, e2)` It is fired when the pinch gesture is in progress.\n * * `pinchEnd(e1, e2)` It is fired when the pinch gesture is finished.\n * \n * In the following example a `pointerManager` object is created and connected to the `canvas`. Then a callback to handle a fingerSingleTap and a fingerHold event is defined\n * and connected to the `pointerManager`.\n * ```\n * const canvas = document.querySelector('canvas');\n * const pointerManager = new PointerManager(canvas);\n * const handler = {\n *     priority: 10,\n *     fingerSingleTap: (e) => {\n *         console.log(\"SINGLE TAP in \", e.clientX, e.clientY);\n *     });\n *     fingerHold: (e) => {\n *         console.log(\"FINGER HOLD in \", e.clientX, e.clientY);\n *     });\n * };\n * pointerManager.onEvent(handler);\n * ```\n */\nclass PointerManager {\n    /**\n     * Instatiates a PointerManager object.\n     * @param {HTMLElement} target The DOM element from which the events are generated\n     * @param {Object} [options] An object literal with class parameters.\n     * @param {number} options.diagonal=27 The diagonal of the screen (in inches).\n     * @param {number} options.pinchMaxInterval=200 fingerDown event max distance in time to trigger a pinch (in ms).\n     */\n    constructor(target, options) {\n\n        this.target = target;\n\n        Object.assign(this, {\n            diagonal: 27,                // Standard monitor 27\"\n            pinchMaxInterval: 200        // in ms, fingerDown event max distance in time to trigger a pinch.\n        });\n\n        if (options)\n            Object.assign(this, options);\n\n        this.idleTimeout = null;\n        this.idleTime = 60; //in seconds\n        this.idling = false;\n\n        this.currentPointers = [];\n        this.eventObservers = new Map();\n        this.ppmm = PointerManager.getPPMM(this.diagonal);\n\n        this.target.style.touchAction = \"none\";\n        this.target.addEventListener('pointerdown', (e) => this.handleEvent(e), false);\n        this.target.addEventListener('pointermove', (e) => this.handleEvent(e), false);\n        this.target.addEventListener('pointerup', (e) => this.handleEvent(e), false);\n        this.target.addEventListener('pointercancel', (e) => this.handleEvent(e), false);\n        this.target.addEventListener('wheel', (e) => this.handleEvent(e), false);\n    }\n\n    ///////////////////////////////////////////////////////////\n    /// Constants\n    static get ANYPOINTER() { return -1; }\n\n    ///////////////////////////////////////////////////////////\n    /// Utilities\n\n    static splitStr(str) {\n        return str.trim().split(/\\s+/g);\n    }\n\n    static getPPMM(diagonal) {\n        // sqrt(w^2 + h^2) / diagonal / 1in\n        return Math.round(Math.sqrt(screen.width **2  + screen.height **2) / diagonal / 25.4);\n    }\n\n    ///////////////////////////////////////////////////////////\n    /// Class interface\n\n    // register pointer handlers.\n    on(eventTypes, obj, idx = PointerManager.ANYPOINTER) {\n        eventTypes = PointerManager.splitStr(eventTypes);\n\n        if (typeof (obj) == 'function') {\n            obj = Object.fromEntries(eventTypes.map(e => [e, obj]));\n            obj.priority = -1000;\n        }\n\n        eventTypes.forEach(eventType => {\n            if (idx == PointerManager.ANYPOINTER) {\n                this.broadcastOn(eventType, obj);\n            } else {\n                const p = this.currentPointers[idx];\n                if (!p) {\n                    throw new Error(\"Bad Index\");\n                }\n                p.on(eventType, obj);\n            }\n        });\n        return obj;\n    }\n\n    // unregister pointer handlers\n    off(eventTypes, callback, idx = PointerManager.ANYPOINTER) {\n        if (idx == PointerManager.ANYPOINTER) {\n            this.broadcastOff(eventTypes, callback);\n        } else {\n            PointerManager.splitStr(eventTypes).forEach(eventType => {\n                const p = this.currentPointers[idx];\n                if (!p) {\n                    throw new Error(\"Bad Index\");\n                }\n                p.off(eventType, callback);\n            });\n        }\n    }\n\n    /* Registers the callbacks */\n    onEvent(handler) {\n        const cb_properties = ['fingerHover', 'fingerSingleTap', 'fingerDoubleTap', 'fingerHold', 'mouseWheel', 'wentIdle', 'activeAgain'];\n        if (!handler.hasOwnProperty('priority'))\n            throw new Error(\"Event handler has not priority property\");\n\n        if (!cb_properties.some((e) => typeof (handler[e]) == 'function'))\n            throw new Error(\"Event handler properties are wrong or missing\");\n\n        for (let e of cb_properties)\n            if (typeof (handler[e]) == 'function') {\n                this.on(e, handler);\n            }\n        if(handler.panStart)\n            this.onPan(handler);\n        if(handler.pinchStart)\n            this.onPinch(handler);\n    }\n\n    /* Registers the Pan callbacks */\n    onPan(handler) {\n        const cb_properties = ['panStart', 'panMove', 'panEnd'];\n        if (!handler.hasOwnProperty('priority'))\n            throw new Error(\"Event handler has not priority property\");\n\n        if (!cb_properties.every((e) => typeof (handler[e]) == 'function'))\n            throw new Error(\"Pan handler is missing one of this functions: panStart, panMove or panEnd\");\n\n        handler.fingerMovingStart = (e) => {\n            handler.panStart(e);\n            if (!e.defaultPrevented) return;\n             this.on('fingerMoving', (e1) => {\n                handler.panMove(e1);\n            }, e.idx);\n            this.on('fingerMovingEnd', (e2) => {\n                handler.panEnd(e2);\n            }, e.idx);\n        }\n        this.on('fingerMovingStart', handler);\n    }\n\n    /* Registers the Pinch callbacks */\n    onPinch(handler) {\n        const cb_properties = ['pinchStart', 'pinchMove', 'pinchEnd'];\n        if (!handler.hasOwnProperty('priority'))\n            throw new Error(\"Event handler has not priority property\");\n\n        if (!cb_properties.every((e) => typeof (handler[e]) == 'function'))\n            throw new Error(\"Pinch handler is missing one of this functions: pinchStart, pinchMove or pinchEnd\");\n\n        handler.fingerDown = (e1) => {\n            //find other pointers not in moving status\n            const filtered = this.currentPointers.filter(cp => cp && cp.idx != e1.idx && cp.status == cp.stateEnum.DETECT);\n            if (filtered.length == 0) return;\n\n            //for each pointer search for the last fingerDown event.\n            const fingerDownEvents = [];\n            for (let cp of filtered) {\n                let down = null;\n                for (let e of cp.eventHistory.toArray())\n                    if (e.fingerType == 'fingerDown')\n                        down = e;\n                if (down)\n                    fingerDownEvents.push(down);\n            }\n            //we start from the closest one\n            //TODO maybe we should sort by distance instead.\n            fingerDownEvents.sort((a, b) => b.timeStamp - a.timeStamp);\n            for (let e2 of fingerDownEvents) {\n                if (e1.timeStamp - e2.timeStamp > this.pinchMaxInterval) break; \n\n                handler.pinchStart(e1, e2);\n                if (!e1.defaultPrevented) break;\n\n                clearTimeout(this.currentPointers[e1.idx].timeout);\n                clearTimeout(this.currentPointers[e2.idx].timeout);\n\n                this.on('fingerMovingStart', (e) => e.preventDefault(), e1.idx); //we need to capture this event (pan conflict)\n                this.on('fingerMovingStart', (e) => e.preventDefault(), e2.idx);\n                this.on('fingerMoving',      (e) => e2 && handler.pinchMove(e1 = e, e2), e1.idx); //we need to assign e1 and e2, to keep last position.\n                this.on('fingerMoving',      (e) => e1 && handler.pinchMove(e1, e2 = e), e2.idx);\n\n                this.on('fingerMovingEnd', (e) => {\n                    if (e2)\n                        handler.pinchEnd(e, e2);\n                    e1 = e2 = null;\n                }, e1.idx);\n                this.on('fingerMovingEnd', (e) => {\n                    if (e1)\n                        handler.pinchEnd(e1, e);\n                    e1 = e2 = null;\n                }, e2.idx);\n\n                break;\n            }\n        }\n        this.on('fingerDown', handler);\n    }\n    ///////////////////////////////////////////////////////////\n    /// Implementation stuff\n\n    // register broadcast handlers\n    broadcastOn(eventType, obj) {\n        const handlers = this.eventObservers.get(eventType);\n        if (handlers)\n            handlers.push(obj);\n        else\n            this.eventObservers.set(eventType, [obj]);\n    }\n\n    // unregister broadcast handlers\n    broadcastOff(eventTypes, obj) {\n        PointerManager.splitStr(eventTypes).forEach(eventType => {\n            if (this.eventObservers.has(eventType)) {\n                if (!obj) {\n                    this.eventObservers.delete(eventType);\n                } else {\n                    const handlers = this.eventObservers.get(eventType);\n                    const index = handlers.indexOf(obj);\n                    if (index > -1) {\n                        handlers.splice(index, 1);\n                    }\n                    if (handlers.length == 0) {\n                        this.eventObservers.delete(eventType);\n                    }\n                }\n            }\n        });\n    }\n\n    // emit broadcast events\n    broadcast(e) {\n        if (!this.eventObservers.has(e.fingerType)) return;\n        this.eventObservers.get(e.fingerType)\n            .sort((a, b) => b.priority - a.priority)\n            .every(obj => {\n                obj[e.fingerType](e);\n                return !e.defaultPrevented;\n            });  // the first obj returning a defaultPrevented event breaks the every loop\n    }\n\n    addCurrPointer(cp) {\n        let result = -1;\n        for (let i = 0; i < this.currentPointers.length && result < 0; i++) {\n            if (this.currentPointers[i] == null) {\n                result = i;\n            }\n        }\n        if (result < 0) {\n            this.currentPointers.push(cp);\n            result = this.currentPointers.length - 1;\n        } else {\n            this.currentPointers[result] = cp;\n        }\n\n        return result;\n    }\n\n    removeCurrPointer(index) {\n        this.currentPointers[index] = null;\n        while ((this.currentPointers.length > 0) && (this.currentPointers[this.currentPointers.length - 1] == null)) {\n            this.currentPointers.pop();\n        }\n    }\n\n    handleEvent(e) {\n        //IDLING MANAGEMENT\n        if(this.idling) {\n            this.broadcast({ fingerType: 'activeAgain' });\n            this.idling = false;\n\n        } else {\n            if(this.idleTimeout)\n                clearTimeout(this.idleTimeout);\n\n            this.idleTimeout = setTimeout(() => {\n                this.broadcast({ fingerType: 'wentIdle'});\n                this.idling = true;\n            }, this.idleTime*1000);\n        }\n\n        if (e.type == 'pointerdown') this.target.setPointerCapture(e.pointerId);\n        if (e.type == 'pointercancel') console.log(e);\n\n        let handled = false;\n        for (let i = 0; i < this.currentPointers.length && !handled; i++) {\n            const cp = this.currentPointers[i];\n            if (cp) {\n                handled = cp.handleEvent(e);\n                if (cp.isDone())\n                    this.removeCurrPointer(i);\n            }\n        }\n        if (!handled) {\n            const cp = new SinglePointerHandler(this, e.pointerId, { ppmm: this.ppmm });\n            handled = cp.handleEvent(e);\n        }\n        //e.preventDefault();\n    }\n\n}\n\nclass SinglePointerHandler {\n    constructor(parent, pointerId, options) {\n\n        this.parent = parent;\n        this.pointerId = pointerId;\n\n        Object.assign(this, {\n            ppmm: 3, // 27in screen 1920x1080 = 3 ppmm\n        });\n        if (options)\n            Object.assign(this, options);\n\n        this.eventHistory = new CircularBuffer(10);\n        this.isActive = false;\n        this.startTap = 0;\n        this.threshold = 15; // 15mm\n\n        this.eventObservers = new Map();\n        this.isDown = false;\n        this.done = false;\n\n        this.stateEnum = {\n            IDLE: 0,\n            DETECT: 1,\n            HOVER: 2,\n            MOVING_START: 3,\n            MOVING: 4,\n            MOVING_END: 5,\n            HOLD: 6,\n            TAPS_DETECT: 7,\n            SINGLE_TAP: 8,\n            DOUBLE_TAP_DETECT: 9,\n            DOUBLE_TAP: 10,\n        };\n        this.status = this.stateEnum.IDLE;\n        this.timeout = null;\n        this.holdTimeoutThreshold = 600;\n        this.tapTimeoutThreshold = 100;\n        this.oldDownPos = { clientX: 0, clientY: 0 };\n        this.movingThreshold = 1; // 1mm\n        this.idx = this.parent.addCurrPointer(this);\n    }\n\n    ///////////////////////////////////////////////////////////\n    /// Utilities\n\n    static distance(x0, y0, x1, y1) {\n        return Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2);\n    }\n\n    distanceMM(x0, y0, x1, y1) {\n        return SinglePointerHandler.distance(x0, y0, x1, y1) / this.ppmm;\n    }\n\n    ///////////////////////////////////////////////////////////\n    /// Class interface\n\n    on(eventType, obj) {\n        this.eventObservers.set(eventType, obj);\n    }\n\n    off(eventType) {\n        if (this.eventObservers.has(eventType)) {\n            this.eventObservers.delete(eventType);\n        }\n    }\n\n    ///////////////////////////////////////////////////////////\n    /// Implementation stuff\n\n    addToHistory(e) {\n        this.eventHistory.push(e);\n    }\n\n    prevPointerEvent() {\n        return this.eventHistory.last();\n    }\n\n    handlePointerDown(e) {\n        this.startTap = e.timeStamp;\n    }\n\n    handlePointerUp(e) {\n        const tapDuration = e.timeStamp - this.startTap;\n    }\n\n    isLikelySamePointer(e) {\n        let result = this.pointerId == e.pointerId;\n        if (!result && !this.isDown && e.type == \"pointerdown\") {\n            const prevP = this.prevPointerEvent();\n            if (prevP) {\n                result = (e.pointerType == prevP.pointerType) && this.distanceMM(e.clientX, e.clientY, prevP.clientX, prevP.clientY) < this.threshold;\n            }\n        }\n        return result;\n    }\n\n    // emit+broadcast\n    emit(e) {\n        if (this.eventObservers.has(e.fingerType)) {\n            this.eventObservers.get(e.fingerType)[e.fingerType](e);\n            if (e.defaultPrevented) return;\n        }\n        this.parent.broadcast(e);\n    }\n\n    // output Event, speed is computed only on pointermove\n    createOutputEvent(e, type) {\n        const result = e;\n        result.fingerType = type;\n        result.originSrc = this.originSrc;\n        result.speedX = 0;\n        result.speedY = 0;\n        result.idx = this.idx;\n        const prevP = this.prevPointerEvent();\n        if (prevP && (e.type == 'pointermove')) {\n            const dt = result.timeStamp - prevP.timeStamp;\n            if (dt > 0) {\n                result.speedX = (result.clientX - prevP.clientX) / dt * 1000.0;  // px/s\n                result.speedY = (result.clientY - prevP.clientY) / dt * 1000.0;  // px/s\n            }\n        }\n        return result;\n    }\n\n    // Finite State Machine\n    processEvent(e) {\n        let distance = 0;\n        if (e.type == \"pointerdown\") {\n            this.oldDownPos.clientX = e.clientX;\n            this.oldDownPos.clientY = e.clientY;\n            this.isDown = true;\n        }\n        if (e.type == \"pointerup\" || e.type == \"pointercancel\") this.isDown = false;\n        if (e.type == \"pointermove\" && this.isDown) {\n            distance = this.distanceMM(e.clientX, e.clientY, this.oldDownPos.clientX, this.oldDownPos.clientY)\n        }\n\n        if (e.type == \"wheel\") {\n            this.emit(this.createOutputEvent(e, 'mouseWheel'));\n            return;\n        }\n\n        switch (this.status) {\n            case this.stateEnum.HOVER:\n            case this.stateEnum.IDLE:\n                if (e.type == 'pointermove') {\n                    this.emit(this.createOutputEvent(e, 'fingerHover'));\n                    this.status = this.stateEnum.HOVER;\n                    this.originSrc = e.composedPath()[0];\n                } else if (e.type == 'pointerdown') {\n                    this.status = this.stateEnum.DETECT;\n                    this.emit(this.createOutputEvent(e, 'fingerDown'));\n                    if (e.defaultPrevented) { // An observer captured the fingerDown event\n                        this.status = this.stateEnum.MOVING;\n                        break;\n                    }\n                    this.originSrc = e.composedPath()[0];\n                    this.timeout = setTimeout(() => {\n                        this.emit(this.createOutputEvent(e, 'fingerHold'));\n                        if(e.defaultPrevented) this.status = this.stateEnum.IDLE;\n                    }, this.holdTimeoutThreshold);\n                }\n                break;\n            case this.stateEnum.DETECT:\n                if (e.type == 'pointercancel') { /// For Firefox\n                    clearTimeout(this.timeout);\n                    this.status = this.stateEnum.IDLE;\n                    this.emit(this.createOutputEvent(e, 'fingerHold'));\n                } else if (e.type == 'pointermove' && distance > this.movingThreshold) {\n                    clearTimeout(this.timeout);\n                    this.status = this.stateEnum.MOVING;\n                    this.emit(this.createOutputEvent(e, 'fingerMovingStart'));\n                } else if (e.type == 'pointerup') {\n                    clearTimeout(this.timeout);\n                    this.status = this.stateEnum.TAPS_DETECT;\n                    this.timeout = setTimeout(() => {\n                        this.status = this.stateEnum.IDLE;\n                        this.emit(this.createOutputEvent(e, 'fingerSingleTap'));\n                    }, this.tapTimeoutThreshold);\n                }\n                break;\n            case this.stateEnum.TAPS_DETECT:\n                if (e.type == 'pointerdown') {\n                    clearTimeout(this.timeout);\n                    this.status = this.stateEnum.DOUBLE_TAP_DETECT;\n                    this.timeout = setTimeout(() => {\n                        this.emit(this.createOutputEvent(e, 'fingerHold'));\n                        if(e.defaultPrevented) this.status = this.stateEnum.IDLE;\n                    }, this.tapTimeoutThreshold);\n                } else if (e.type == 'pointermove' && distance > this.movingThreshold) {\n                    clearTimeout(this.timeout);\n                    this.status = this.stateEnum.IDLE;\n                    this.emit(this.createOutputEvent(e, 'fingerHover'));\n                }\n                break;\n            case this.stateEnum.DOUBLE_TAP_DETECT:\n                if (e.type == 'pointerup' || e.type == 'pointercancel') {\n                    clearTimeout(this.timeout);\n                    this.status = this.stateEnum.IDLE;\n                    this.emit(this.createOutputEvent(e, 'fingerDoubleTap'));\n                }\n                break;\n            case this.stateEnum.DOUBLE_TAP_DETECT:\n                if (e.type == 'pointermove' && distance > this.movingThreshold) {\n                    this.status = this.stateEnum.MOVING;\n                    this.emit(this.createOutputEvent(e, 'fingerMovingStart'));\n                }\n                break;\n            case this.stateEnum.MOVING:\n                if (e.type == 'pointermove') {\n                    // Remain MOVING\n                    this.emit(this.createOutputEvent(e, 'fingerMoving'));\n                } else if (e.type == 'pointerup' || e.type == 'pointercancel') {\n                    this.status = this.stateEnum.IDLE;\n                    this.emit(this.createOutputEvent(e, 'fingerMovingEnd'));\n                }\n                break;\n            default:\n                console.log(\"ERROR \" + this.status);\n                console.log(e);\n                break;\n        }\n\n        this.addToHistory(e);\n    }\n\n    handleEvent(e) {\n        let result = false;\n        if (this.isLikelySamePointer(e)) {\n            this.pointerId = e.pointerId; //it's mine\n            this.processEvent(e);\n            result = true;\n        }\n        return result;\n    }\n\n    isDone() {\n        return this.status == this.stateEnum.IDLE;\n    }\n\n}\n\nclass CircularBuffer {\n    constructor(capacity) {\n        if (typeof capacity != \"number\" || !Number.isInteger(capacity) || capacity < 1)\n            throw new TypeError(\"Invalid capacity\");\n        this.buffer = new Array(capacity);\n        this.capacity = capacity;\n        this.first = 0;\n        this.size = 0;\n    }\n\n    clear() {\n        this.first = 0;\n        this.size = 0;\n    }\n\n    empty() {\n        return this.size == 0;\n    }\n\n    size() {\n        return this.size;\n    }\n\n    capacity() {\n        return this.capacity;\n    }\n\n    first() {\n        let result = null;\n        if (this.size > 0) result = this.buffer[this.first];\n        return result;\n    }\n\n    last() {\n        let result = null;\n        if (this.size > 0) result = this.buffer[(this.first + this.size - 1) % this.capacity];\n        return result;\n    }\n\n    enqueue(v) {\n        this.first = (this.first > 0) ? this.first - 1 : this.first = this.capacity - 1;\n        this.buffer[this.first] = v;\n        if (this.size < this.capacity) this.size++;\n    }\n\n    push(v) {\n        if (this.size == this.capacity) {\n            this.buffer[this.first] = v;\n            this.first = (this.first + 1) % this.capacity;\n        } else {\n            this.buffer[(this.first + this.size) % this.capacity] = v;\n            this.size++;\n        }\n    }\n\n    dequeue() {\n        if (this.size == 0) throw new RangeError(\"Dequeue on empty buffer\");\n        const v = this.buffer[(this.first + this.size - 1) % this.capacity];\n        this.size--;\n        return v;\n    }\n\n    pop() {\n        return this.dequeue();\n    }\n\n    shift() {\n        if (this.size == 0) throw new RangeError(\"Shift on empty buffer\");\n        const v = this.buffer[this.first];\n        if (this.first == this.capacity - 1) this.first = 0; else this.first++;\n        this.size--;\n        return v;\n    }\n\n    get(start, end) {\n        if (this.size == 0 && start == 0 && (end == undefined || end == 0)) return [];\n        if (typeof start != \"number\" || !Number.isInteger(start) || start < 0) throw new TypeError(\"Invalid start value\");\n        if (start >= this.size) throw new RangeError(\"Start index past end of buffer: \" + start);\n\n        if (end == undefined) return this.buffer[(this.first + start) % this.capacity];\n\n        if (typeof end != \"number\" || !Number.isInteger(end) || end < 0) throw new TypeError(\"Invalid end value\");\n        if (end >= this.size) throw new RangeError(\"End index past end of buffer: \" + end);\n\n        if (this.first + start >= this.capacity) {\n            start -= this.capacity;\n            end -= this.capacity;\n        }\n        if (this.first + end < this.capacity)\n            return this.buffer.slice(this.first + start, this.first + end + 1);\n        else\n            return this.buffer.slice(this.first + start, this.capacity).concat(this.buffer.slice(0, this.first + end + 1 - this.capacity));\n    }\n\n    toArray() {\n        if (this.size == 0) return [];\n        return this.get(0, this.size - 1);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9Qb2ludGVyTWFuYWdlci5qcz80YzQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSAqKlBvaW50ZXJNYW5hZ2VyKiogaXMgYSBoaWdoLWxldmVsIGNsYXNzIGZvciBoYW5kbGluZyBzaW11bHRhbmVvdXMgZXZlbnRzIGZyb20gYSBET00gYHRhcmdldGAuIFxuICogSXQgY2FwdHVyZXMgUG9pbnRlckV2ZW50IChNb3VzZUV2ZW50IGFuZCBUb3VjaEV2ZW50KSBnZW5lcmF0ZWQgYnkgdGhlIGB0YXJnZXRgLCBjbGFzc2lmaWVzIHRoZW0gYXMgXCJnZXN0dXJlc1wiIGFuZCBwcm92aWRlcyBhIHNpbXBsZSBpbnRlcmZhY2VcbiAqIHRvIHdvcmsgd2l0aCB0aGVtLiBcbiAqIFxuICogVGhlIGhpZ2gtbGV2ZWwgZXZlbnRzIChnZXN0dXJlcykgdGhhdCBhcmUgZGV0ZWN0ZWQgYW5kIGVtaXR0ZWQgYXJlOlxuICogKiBgZmluZ2VySG92ZXIoZSlgIEl0IGlzIGZpcmVkIHdoZW4gYSBwb2ludGluZyBkZXZpY2UgaXMgdXNlZCB0byBtb3ZlIHRoZSBjdXJzb3Igb24gdGhlIHRhcmdldCBcbiAqICogYGZpbmdlclNpbmdsZVRhcChlKWAgSXQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEgbW91c2UgYnV0dG9uIHF1aWNrbHkgb3IgdG91Y2hlcyB0aGUgc2NyZWVuIHNob3J0bHkgd2l0aCBhIGZpbmdlclxuICogKiBgZmluZ2VyRG91YmxlVGFwKGUpYCBJdCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHF1aWNrbHkgcHJlc3NlcyBhIG1vdXNlIGJ1dHRvbiB0d2ljZSBvciBzaG9ydGx5IHRvdWNoZXMgdGhlIHNjcmVlbiB3aXRoIGEgZmluZ2VyIHR3aWNlLlxuICogKiBgZmluZ2VySG9sZChlKWAgSXQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBrZWVwcyBwcmVzc2luZyBhIG1vdXNlIGJ1dHRvbiBvciB0b3VjaGluZyB0aGUgc2NyZWVuIGxvbmdlciB0aGFuIGEgdGhyZXNob2xkICg2MDAgbXMpLlxuICogKiBgbW91c2VXaGVlbChlKWAgSXQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciByb3RhdGVzIHRoZSBtb3VzZSB3aGVlbCBidXR0b24uXG4gKiAqIGBwYW5TdGFydChlKWAgSXQgaXMgZmlyZWQgd2hlbiB0aGUgcGFuIGdlc3R1cmUgaXMgc3RhcnRpbmcuXG4gKiAqIGBwYW5Nb3ZlKGUpYCBJdCBpcyBmaXJlZCB3aGVuIHRoZSBwYW4gZ2VzdHVyZSBpcyBpbiBwcm9ncmVzcy5cbiAqICogYHBhbkVuZChlKWAgSXQgaXMgZmlyZWQgd2hlbiB0aGUgcGFuIGdlc3R1cmUgaXMgZmluaXNoZWQuXG4gKiAqIGBwaW5jaFN0YXJ0KGUxLCBlMilgIEl0IGlzIGZpcmVkIHdoZW4gdGhlIHBpbmNoIGdlc3R1cmUgaXMgc3RhcnRpbmcuXG4gKiAqIGBwaW5jaE1vdmUoZTEsIGUyKWAgSXQgaXMgZmlyZWQgd2hlbiB0aGUgcGluY2ggZ2VzdHVyZSBpcyBpbiBwcm9ncmVzcy5cbiAqICogYHBpbmNoRW5kKGUxLCBlMilgIEl0IGlzIGZpcmVkIHdoZW4gdGhlIHBpbmNoIGdlc3R1cmUgaXMgZmluaXNoZWQuXG4gKiBcbiAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSBhIGBwb2ludGVyTWFuYWdlcmAgb2JqZWN0IGlzIGNyZWF0ZWQgYW5kIGNvbm5lY3RlZCB0byB0aGUgYGNhbnZhc2AuIFRoZW4gYSBjYWxsYmFjayB0byBoYW5kbGUgYSBmaW5nZXJTaW5nbGVUYXAgYW5kIGEgZmluZ2VySG9sZCBldmVudCBpcyBkZWZpbmVkXG4gKiBhbmQgY29ubmVjdGVkIHRvIHRoZSBgcG9pbnRlck1hbmFnZXJgLlxuICogYGBgXG4gKiBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAqIGNvbnN0IHBvaW50ZXJNYW5hZ2VyID0gbmV3IFBvaW50ZXJNYW5hZ2VyKGNhbnZhcyk7XG4gKiBjb25zdCBoYW5kbGVyID0ge1xuICogICAgIHByaW9yaXR5OiAxMCxcbiAqICAgICBmaW5nZXJTaW5nbGVUYXA6IChlKSA9PiB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiU0lOR0xFIFRBUCBpbiBcIiwgZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICogICAgIH0pO1xuICogICAgIGZpbmdlckhvbGQ6IChlKSA9PiB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiRklOR0VSIEhPTEQgaW4gXCIsIGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAqICAgICB9KTtcbiAqIH07XG4gKiBwb2ludGVyTWFuYWdlci5vbkV2ZW50KGhhbmRsZXIpO1xuICogYGBgXG4gKi9cbmNsYXNzIFBvaW50ZXJNYW5hZ2VyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YXRpYXRlcyBhIFBvaW50ZXJNYW5hZ2VyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IGZyb20gd2hpY2ggdGhlIGV2ZW50cyBhcmUgZ2VuZXJhdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGNsYXNzIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZGlhZ29uYWw9MjcgVGhlIGRpYWdvbmFsIG9mIHRoZSBzY3JlZW4gKGluIGluY2hlcykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucGluY2hNYXhJbnRlcnZhbD0yMDAgZmluZ2VyRG93biBldmVudCBtYXggZGlzdGFuY2UgaW4gdGltZSB0byB0cmlnZ2VyIGEgcGluY2ggKGluIG1zKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICAgIGRpYWdvbmFsOiAyNywgICAgICAgICAgICAgICAgLy8gU3RhbmRhcmQgbW9uaXRvciAyN1wiXG4gICAgICAgICAgICBwaW5jaE1heEludGVydmFsOiAyMDAgICAgICAgIC8vIGluIG1zLCBmaW5nZXJEb3duIGV2ZW50IG1heCBkaXN0YW5jZSBpbiB0aW1lIHRvIHRyaWdnZXIgYSBwaW5jaC5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmlkbGVUaW1lID0gNjA7IC8vaW4gc2Vjb25kc1xuICAgICAgICB0aGlzLmlkbGluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucHBtbSA9IFBvaW50ZXJNYW5hZ2VyLmdldFBQTU0odGhpcy5kaWFnb25hbCk7XG5cbiAgICAgICAgdGhpcy50YXJnZXQuc3R5bGUudG91Y2hBY3Rpb24gPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCAoZSkgPT4gdGhpcy5oYW5kbGVFdmVudChlKSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIChlKSA9PiB0aGlzLmhhbmRsZUV2ZW50KGUpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIChlKSA9PiB0aGlzLmhhbmRsZUV2ZW50KGUpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCAoZSkgPT4gdGhpcy5oYW5kbGVFdmVudChlKSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlKSA9PiB0aGlzLmhhbmRsZUV2ZW50KGUpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8gQ29uc3RhbnRzXG4gICAgc3RhdGljIGdldCBBTllQT0lOVEVSKCkgeyByZXR1cm4gLTE7IH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vIFV0aWxpdGllc1xuXG4gICAgc3RhdGljIHNwbGl0U3RyKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UFBNTShkaWFnb25hbCkge1xuICAgICAgICAvLyBzcXJ0KHdeMiArIGheMikgLyBkaWFnb25hbCAvIDFpblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoc2NyZWVuLndpZHRoICoqMiAgKyBzY3JlZW4uaGVpZ2h0ICoqMikgLyBkaWFnb25hbCAvIDI1LjQpO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vIENsYXNzIGludGVyZmFjZVxuXG4gICAgLy8gcmVnaXN0ZXIgcG9pbnRlciBoYW5kbGVycy5cbiAgICBvbihldmVudFR5cGVzLCBvYmosIGlkeCA9IFBvaW50ZXJNYW5hZ2VyLkFOWVBPSU5URVIpIHtcbiAgICAgICAgZXZlbnRUeXBlcyA9IFBvaW50ZXJNYW5hZ2VyLnNwbGl0U3RyKGV2ZW50VHlwZXMpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqID0gT2JqZWN0LmZyb21FbnRyaWVzKGV2ZW50VHlwZXMubWFwKGUgPT4gW2UsIG9ial0pKTtcbiAgICAgICAgICAgIG9iai5wcmlvcml0eSA9IC0xMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRUeXBlcy5mb3JFYWNoKGV2ZW50VHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4ID09IFBvaW50ZXJNYW5hZ2VyLkFOWVBPSU5URVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdE9uKGV2ZW50VHlwZSwgb2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuY3VycmVudFBvaW50ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBJbmRleFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcC5vbihldmVudFR5cGUsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8vIHVucmVnaXN0ZXIgcG9pbnRlciBoYW5kbGVyc1xuICAgIG9mZihldmVudFR5cGVzLCBjYWxsYmFjaywgaWR4ID0gUG9pbnRlck1hbmFnZXIuQU5ZUE9JTlRFUikge1xuICAgICAgICBpZiAoaWR4ID09IFBvaW50ZXJNYW5hZ2VyLkFOWVBPSU5URVIpIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0T2ZmKGV2ZW50VHlwZXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFBvaW50ZXJNYW5hZ2VyLnNwbGl0U3RyKGV2ZW50VHlwZXMpLmZvckVhY2goZXZlbnRUeXBlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5jdXJyZW50UG9pbnRlcnNbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIEluZGV4XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLm9mZihldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogUmVnaXN0ZXJzIHRoZSBjYWxsYmFja3MgKi9cbiAgICBvbkV2ZW50KGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgY2JfcHJvcGVydGllcyA9IFsnZmluZ2VySG92ZXInLCAnZmluZ2VyU2luZ2xlVGFwJywgJ2ZpbmdlckRvdWJsZVRhcCcsICdmaW5nZXJIb2xkJywgJ21vdXNlV2hlZWwnLCAnd2VudElkbGUnLCAnYWN0aXZlQWdhaW4nXTtcbiAgICAgICAgaWYgKCFoYW5kbGVyLmhhc093blByb3BlcnR5KCdwcmlvcml0eScpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaGFuZGxlciBoYXMgbm90IHByaW9yaXR5IHByb3BlcnR5XCIpO1xuXG4gICAgICAgIGlmICghY2JfcHJvcGVydGllcy5zb21lKChlKSA9PiB0eXBlb2YgKGhhbmRsZXJbZV0pID09ICdmdW5jdGlvbicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaGFuZGxlciBwcm9wZXJ0aWVzIGFyZSB3cm9uZyBvciBtaXNzaW5nXCIpO1xuXG4gICAgICAgIGZvciAobGV0IGUgb2YgY2JfcHJvcGVydGllcylcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGhhbmRsZXJbZV0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKGUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZihoYW5kbGVyLnBhblN0YXJ0KVxuICAgICAgICAgICAgdGhpcy5vblBhbihoYW5kbGVyKTtcbiAgICAgICAgaWYoaGFuZGxlci5waW5jaFN0YXJ0KVxuICAgICAgICAgICAgdGhpcy5vblBpbmNoKGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qIFJlZ2lzdGVycyB0aGUgUGFuIGNhbGxiYWNrcyAqL1xuICAgIG9uUGFuKGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgY2JfcHJvcGVydGllcyA9IFsncGFuU3RhcnQnLCAncGFuTW92ZScsICdwYW5FbmQnXTtcbiAgICAgICAgaWYgKCFoYW5kbGVyLmhhc093blByb3BlcnR5KCdwcmlvcml0eScpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaGFuZGxlciBoYXMgbm90IHByaW9yaXR5IHByb3BlcnR5XCIpO1xuXG4gICAgICAgIGlmICghY2JfcHJvcGVydGllcy5ldmVyeSgoZSkgPT4gdHlwZW9mIChoYW5kbGVyW2VdKSA9PSAnZnVuY3Rpb24nKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhbiBoYW5kbGVyIGlzIG1pc3Npbmcgb25lIG9mIHRoaXMgZnVuY3Rpb25zOiBwYW5TdGFydCwgcGFuTW92ZSBvciBwYW5FbmRcIik7XG5cbiAgICAgICAgaGFuZGxlci5maW5nZXJNb3ZpbmdTdGFydCA9IChlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyLnBhblN0YXJ0KGUpO1xuICAgICAgICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgICAgICAgICB0aGlzLm9uKCdmaW5nZXJNb3ZpbmcnLCAoZTEpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnBhbk1vdmUoZTEpO1xuICAgICAgICAgICAgfSwgZS5pZHgpO1xuICAgICAgICAgICAgdGhpcy5vbignZmluZ2VyTW92aW5nRW5kJywgKGUyKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5wYW5FbmQoZTIpO1xuICAgICAgICAgICAgfSwgZS5pZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub24oJ2Zpbmdlck1vdmluZ1N0YXJ0JywgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyogUmVnaXN0ZXJzIHRoZSBQaW5jaCBjYWxsYmFja3MgKi9cbiAgICBvblBpbmNoKGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgY2JfcHJvcGVydGllcyA9IFsncGluY2hTdGFydCcsICdwaW5jaE1vdmUnLCAncGluY2hFbmQnXTtcbiAgICAgICAgaWYgKCFoYW5kbGVyLmhhc093blByb3BlcnR5KCdwcmlvcml0eScpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaGFuZGxlciBoYXMgbm90IHByaW9yaXR5IHByb3BlcnR5XCIpO1xuXG4gICAgICAgIGlmICghY2JfcHJvcGVydGllcy5ldmVyeSgoZSkgPT4gdHlwZW9mIChoYW5kbGVyW2VdKSA9PSAnZnVuY3Rpb24nKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBpbmNoIGhhbmRsZXIgaXMgbWlzc2luZyBvbmUgb2YgdGhpcyBmdW5jdGlvbnM6IHBpbmNoU3RhcnQsIHBpbmNoTW92ZSBvciBwaW5jaEVuZFwiKTtcblxuICAgICAgICBoYW5kbGVyLmZpbmdlckRvd24gPSAoZTEpID0+IHtcbiAgICAgICAgICAgIC8vZmluZCBvdGhlciBwb2ludGVycyBub3QgaW4gbW92aW5nIHN0YXR1c1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB0aGlzLmN1cnJlbnRQb2ludGVycy5maWx0ZXIoY3AgPT4gY3AgJiYgY3AuaWR4ICE9IGUxLmlkeCAmJiBjcC5zdGF0dXMgPT0gY3Auc3RhdGVFbnVtLkRFVEVDVCk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyZWQubGVuZ3RoID09IDApIHJldHVybjtcblxuICAgICAgICAgICAgLy9mb3IgZWFjaCBwb2ludGVyIHNlYXJjaCBmb3IgdGhlIGxhc3QgZmluZ2VyRG93biBldmVudC5cbiAgICAgICAgICAgIGNvbnN0IGZpbmdlckRvd25FdmVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNwIG9mIGZpbHRlcmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvd24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgb2YgY3AuZXZlbnRIaXN0b3J5LnRvQXJyYXkoKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZmluZ2VyVHlwZSA9PSAnZmluZ2VyRG93bicpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duID0gZTtcbiAgICAgICAgICAgICAgICBpZiAoZG93bilcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VyRG93bkV2ZW50cy5wdXNoKGRvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy93ZSBzdGFydCBmcm9tIHRoZSBjbG9zZXN0IG9uZVxuICAgICAgICAgICAgLy9UT0RPIG1heWJlIHdlIHNob3VsZCBzb3J0IGJ5IGRpc3RhbmNlIGluc3RlYWQuXG4gICAgICAgICAgICBmaW5nZXJEb3duRXZlbnRzLnNvcnQoKGEsIGIpID0+IGIudGltZVN0YW1wIC0gYS50aW1lU3RhbXApO1xuICAgICAgICAgICAgZm9yIChsZXQgZTIgb2YgZmluZ2VyRG93bkV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlMS50aW1lU3RhbXAgLSBlMi50aW1lU3RhbXAgPiB0aGlzLnBpbmNoTWF4SW50ZXJ2YWwpIGJyZWFrOyBcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIucGluY2hTdGFydChlMSwgZTIpO1xuICAgICAgICAgICAgICAgIGlmICghZTEuZGVmYXVsdFByZXZlbnRlZCkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50UG9pbnRlcnNbZTEuaWR4XS50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50UG9pbnRlcnNbZTIuaWR4XS50aW1lb3V0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Zpbmdlck1vdmluZ1N0YXJ0JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSwgZTEuaWR4KTsgLy93ZSBuZWVkIHRvIGNhcHR1cmUgdGhpcyBldmVudCAocGFuIGNvbmZsaWN0KVxuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Zpbmdlck1vdmluZ1N0YXJ0JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSwgZTIuaWR4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdmaW5nZXJNb3ZpbmcnLCAgICAgIChlKSA9PiBlMiAmJiBoYW5kbGVyLnBpbmNoTW92ZShlMSA9IGUsIGUyKSwgZTEuaWR4KTsgLy93ZSBuZWVkIHRvIGFzc2lnbiBlMSBhbmQgZTIsIHRvIGtlZXAgbGFzdCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdmaW5nZXJNb3ZpbmcnLCAgICAgIChlKSA9PiBlMSAmJiBoYW5kbGVyLnBpbmNoTW92ZShlMSwgZTIgPSBlKSwgZTIuaWR4KTtcblxuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Zpbmdlck1vdmluZ0VuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIucGluY2hFbmQoZSwgZTIpO1xuICAgICAgICAgICAgICAgICAgICBlMSA9IGUyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCBlMS5pZHgpO1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Zpbmdlck1vdmluZ0VuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIucGluY2hFbmQoZTEsIGUpO1xuICAgICAgICAgICAgICAgICAgICBlMSA9IGUyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCBlMi5pZHgpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbignZmluZ2VyRG93bicsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLyBJbXBsZW1lbnRhdGlvbiBzdHVmZlxuXG4gICAgLy8gcmVnaXN0ZXIgYnJvYWRjYXN0IGhhbmRsZXJzXG4gICAgYnJvYWRjYXN0T24oZXZlbnRUeXBlLCBvYmopIHtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmV2ZW50T2JzZXJ2ZXJzLmdldChldmVudFR5cGUpO1xuICAgICAgICBpZiAoaGFuZGxlcnMpXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9iaik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlcnMuc2V0KGV2ZW50VHlwZSwgW29ial0pO1xuICAgIH1cblxuICAgIC8vIHVucmVnaXN0ZXIgYnJvYWRjYXN0IGhhbmRsZXJzXG4gICAgYnJvYWRjYXN0T2ZmKGV2ZW50VHlwZXMsIG9iaikge1xuICAgICAgICBQb2ludGVyTWFuYWdlci5zcGxpdFN0cihldmVudFR5cGVzKS5mb3JFYWNoKGV2ZW50VHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVycy5oYXMoZXZlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlcnMuZGVsZXRlKGV2ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmV2ZW50T2JzZXJ2ZXJzLmdldChldmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGhhbmRsZXJzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXJzLmRlbGV0ZShldmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBlbWl0IGJyb2FkY2FzdCBldmVudHNcbiAgICBicm9hZGNhc3QoZSkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRPYnNlcnZlcnMuaGFzKGUuZmluZ2VyVHlwZSkpIHJldHVybjtcbiAgICAgICAgdGhpcy5ldmVudE9ic2VydmVycy5nZXQoZS5maW5nZXJUeXBlKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KVxuICAgICAgICAgICAgLmV2ZXJ5KG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgb2JqW2UuZmluZ2VyVHlwZV0oZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlLmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgICAgICB9KTsgIC8vIHRoZSBmaXJzdCBvYmogcmV0dXJuaW5nIGEgZGVmYXVsdFByZXZlbnRlZCBldmVudCBicmVha3MgdGhlIGV2ZXJ5IGxvb3BcbiAgICB9XG5cbiAgICBhZGRDdXJyUG9pbnRlcihjcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jdXJyZW50UG9pbnRlcnMubGVuZ3RoICYmIHJlc3VsdCA8IDA7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBvaW50ZXJzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVycy5wdXNoKGNwKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY3VycmVudFBvaW50ZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVyc1tyZXN1bHRdID0gY3A7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlbW92ZUN1cnJQb2ludGVyKGluZGV4KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzW2luZGV4XSA9IG51bGw7XG4gICAgICAgIHdoaWxlICgodGhpcy5jdXJyZW50UG9pbnRlcnMubGVuZ3RoID4gMCkgJiYgKHRoaXMuY3VycmVudFBvaW50ZXJzW3RoaXMuY3VycmVudFBvaW50ZXJzLmxlbmd0aCAtIDFdID09IG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVycy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgICAgLy9JRExJTkcgTUFOQUdFTUVOVFxuICAgICAgICBpZih0aGlzLmlkbGluZykge1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3QoeyBmaW5nZXJUeXBlOiAnYWN0aXZlQWdhaW4nIH0pO1xuICAgICAgICAgICAgdGhpcy5pZGxpbmcgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYodGhpcy5pZGxlVGltZW91dClcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dCk7XG5cbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdCh7IGZpbmdlclR5cGU6ICd3ZW50SWRsZSd9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkbGluZyA9IHRydWU7XG4gICAgICAgICAgICB9LCB0aGlzLmlkbGVUaW1lKjEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PSAncG9pbnRlcmRvd24nKSB0aGlzLnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gJ3BvaW50ZXJjYW5jZWwnKSBjb25zb2xlLmxvZyhlKTtcblxuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY3VycmVudFBvaW50ZXJzLmxlbmd0aCAmJiAhaGFuZGxlZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjcCA9IHRoaXMuY3VycmVudFBvaW50ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGNwKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IGNwLmhhbmRsZUV2ZW50KGUpO1xuICAgICAgICAgICAgICAgIGlmIChjcC5pc0RvbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDdXJyUG9pbnRlcihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNwID0gbmV3IFNpbmdsZVBvaW50ZXJIYW5kbGVyKHRoaXMsIGUucG9pbnRlcklkLCB7IHBwbW06IHRoaXMucHBtbSB9KTtcbiAgICAgICAgICAgIGhhbmRsZWQgPSBjcC5oYW5kbGVFdmVudChlKTtcbiAgICAgICAgfVxuICAgICAgICAvL2UucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbn1cblxuY2xhc3MgU2luZ2xlUG9pbnRlckhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgcG9pbnRlcklkLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucG9pbnRlcklkID0gcG9pbnRlcklkO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgcHBtbTogMywgLy8gMjdpbiBzY3JlZW4gMTkyMHgxMDgwID0gMyBwcG1tXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucylcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5ldmVudEhpc3RvcnkgPSBuZXcgQ2lyY3VsYXJCdWZmZXIoMTApO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnRUYXAgPSAwO1xuICAgICAgICB0aGlzLnRocmVzaG9sZCA9IDE1OyAvLyAxNW1tXG5cbiAgICAgICAgdGhpcy5ldmVudE9ic2VydmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5zdGF0ZUVudW0gPSB7XG4gICAgICAgICAgICBJRExFOiAwLFxuICAgICAgICAgICAgREVURUNUOiAxLFxuICAgICAgICAgICAgSE9WRVI6IDIsXG4gICAgICAgICAgICBNT1ZJTkdfU1RBUlQ6IDMsXG4gICAgICAgICAgICBNT1ZJTkc6IDQsXG4gICAgICAgICAgICBNT1ZJTkdfRU5EOiA1LFxuICAgICAgICAgICAgSE9MRDogNixcbiAgICAgICAgICAgIFRBUFNfREVURUNUOiA3LFxuICAgICAgICAgICAgU0lOR0xFX1RBUDogOCxcbiAgICAgICAgICAgIERPVUJMRV9UQVBfREVURUNUOiA5LFxuICAgICAgICAgICAgRE9VQkxFX1RBUDogMTAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0ZUVudW0uSURMRTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob2xkVGltZW91dFRocmVzaG9sZCA9IDYwMDtcbiAgICAgICAgdGhpcy50YXBUaW1lb3V0VGhyZXNob2xkID0gMTAwO1xuICAgICAgICB0aGlzLm9sZERvd25Qb3MgPSB7IGNsaWVudFg6IDAsIGNsaWVudFk6IDAgfTtcbiAgICAgICAgdGhpcy5tb3ZpbmdUaHJlc2hvbGQgPSAxOyAvLyAxbW1cbiAgICAgICAgdGhpcy5pZHggPSB0aGlzLnBhcmVudC5hZGRDdXJyUG9pbnRlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLyBVdGlsaXRpZXNcblxuICAgIHN0YXRpYyBkaXN0YW5jZSh4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MSAtIHgwKSAqKiAyICsgKHkxIC0geTApICoqIDIpO1xuICAgIH1cblxuICAgIGRpc3RhbmNlTU0oeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgcmV0dXJuIFNpbmdsZVBvaW50ZXJIYW5kbGVyLmRpc3RhbmNlKHgwLCB5MCwgeDEsIHkxKSAvIHRoaXMucHBtbTtcbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLyBDbGFzcyBpbnRlcmZhY2VcblxuICAgIG9uKGV2ZW50VHlwZSwgb2JqKSB7XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlcnMuc2V0KGV2ZW50VHlwZSwgb2JqKTtcbiAgICB9XG5cbiAgICBvZmYoZXZlbnRUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXJzLmRlbGV0ZShldmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8gSW1wbGVtZW50YXRpb24gc3R1ZmZcblxuICAgIGFkZFRvSGlzdG9yeShlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIaXN0b3J5LnB1c2goZSk7XG4gICAgfVxuXG4gICAgcHJldlBvaW50ZXJFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRIaXN0b3J5Lmxhc3QoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVQb2ludGVyRG93bihlKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUYXAgPSBlLnRpbWVTdGFtcDtcbiAgICB9XG5cbiAgICBoYW5kbGVQb2ludGVyVXAoZSkge1xuICAgICAgICBjb25zdCB0YXBEdXJhdGlvbiA9IGUudGltZVN0YW1wIC0gdGhpcy5zdGFydFRhcDtcbiAgICB9XG5cbiAgICBpc0xpa2VseVNhbWVQb2ludGVyKGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucG9pbnRlcklkID09IGUucG9pbnRlcklkO1xuICAgICAgICBpZiAoIXJlc3VsdCAmJiAhdGhpcy5pc0Rvd24gJiYgZS50eXBlID09IFwicG9pbnRlcmRvd25cIikge1xuICAgICAgICAgICAgY29uc3QgcHJldlAgPSB0aGlzLnByZXZQb2ludGVyRXZlbnQoKTtcbiAgICAgICAgICAgIGlmIChwcmV2UCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChlLnBvaW50ZXJUeXBlID09IHByZXZQLnBvaW50ZXJUeXBlKSAmJiB0aGlzLmRpc3RhbmNlTU0oZS5jbGllbnRYLCBlLmNsaWVudFksIHByZXZQLmNsaWVudFgsIHByZXZQLmNsaWVudFkpIDwgdGhpcy50aHJlc2hvbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBlbWl0K2Jyb2FkY2FzdFxuICAgIGVtaXQoZSkge1xuICAgICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVycy5oYXMoZS5maW5nZXJUeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudE9ic2VydmVycy5nZXQoZS5maW5nZXJUeXBlKVtlLmZpbmdlclR5cGVdKGUpO1xuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50LmJyb2FkY2FzdChlKTtcbiAgICB9XG5cbiAgICAvLyBvdXRwdXQgRXZlbnQsIHNwZWVkIGlzIGNvbXB1dGVkIG9ubHkgb24gcG9pbnRlcm1vdmVcbiAgICBjcmVhdGVPdXRwdXRFdmVudChlLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGU7XG4gICAgICAgIHJlc3VsdC5maW5nZXJUeXBlID0gdHlwZTtcbiAgICAgICAgcmVzdWx0Lm9yaWdpblNyYyA9IHRoaXMub3JpZ2luU3JjO1xuICAgICAgICByZXN1bHQuc3BlZWRYID0gMDtcbiAgICAgICAgcmVzdWx0LnNwZWVkWSA9IDA7XG4gICAgICAgIHJlc3VsdC5pZHggPSB0aGlzLmlkeDtcbiAgICAgICAgY29uc3QgcHJldlAgPSB0aGlzLnByZXZQb2ludGVyRXZlbnQoKTtcbiAgICAgICAgaWYgKHByZXZQICYmIChlLnR5cGUgPT0gJ3BvaW50ZXJtb3ZlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gcmVzdWx0LnRpbWVTdGFtcCAtIHByZXZQLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIGlmIChkdCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BlZWRYID0gKHJlc3VsdC5jbGllbnRYIC0gcHJldlAuY2xpZW50WCkgLyBkdCAqIDEwMDAuMDsgIC8vIHB4L3NcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BlZWRZID0gKHJlc3VsdC5jbGllbnRZIC0gcHJldlAuY2xpZW50WSkgLyBkdCAqIDEwMDAuMDsgIC8vIHB4L3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEZpbml0ZSBTdGF0ZSBNYWNoaW5lXG4gICAgcHJvY2Vzc0V2ZW50KGUpIHtcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gMDtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcInBvaW50ZXJkb3duXCIpIHtcbiAgICAgICAgICAgIHRoaXMub2xkRG93blBvcy5jbGllbnRYID0gZS5jbGllbnRYO1xuICAgICAgICAgICAgdGhpcy5vbGREb3duUG9zLmNsaWVudFkgPSBlLmNsaWVudFk7XG4gICAgICAgICAgICB0aGlzLmlzRG93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudHlwZSA9PSBcInBvaW50ZXJ1cFwiIHx8IGUudHlwZSA9PSBcInBvaW50ZXJjYW5jZWxcIikgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcInBvaW50ZXJtb3ZlXCIgJiYgdGhpcy5pc0Rvd24pIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZU1NKGUuY2xpZW50WCwgZS5jbGllbnRZLCB0aGlzLm9sZERvd25Qb3MuY2xpZW50WCwgdGhpcy5vbGREb3duUG9zLmNsaWVudFkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09IFwid2hlZWxcIikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuY3JlYXRlT3V0cHV0RXZlbnQoZSwgJ21vdXNlV2hlZWwnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuc3RhdGVFbnVtLkhPVkVSOlxuICAgICAgICAgICAgY2FzZSB0aGlzLnN0YXRlRW51bS5JRExFOlxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gJ3BvaW50ZXJtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jcmVhdGVPdXRwdXRFdmVudChlLCAnZmluZ2VySG92ZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0ZUVudW0uSE9WRVI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luU3JjID0gZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSAncG9pbnRlcmRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0ZUVudW0uREVURUNUO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jcmVhdGVPdXRwdXRFdmVudChlLCAnZmluZ2VyRG93bicpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyAvLyBBbiBvYnNlcnZlciBjYXB0dXJlZCB0aGUgZmluZ2VyRG93biBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXRlRW51bS5NT1ZJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblNyYyA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KHRoaXMuY3JlYXRlT3V0cHV0RXZlbnQoZSwgJ2ZpbmdlckhvbGQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlLmRlZmF1bHRQcmV2ZW50ZWQpIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0ZUVudW0uSURMRTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5ob2xkVGltZW91dFRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLnN0YXRlRW51bS5ERVRFQ1Q6XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PSAncG9pbnRlcmNhbmNlbCcpIHsgLy8vIEZvciBGaXJlZm94XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdGVFbnVtLklETEU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNyZWF0ZU91dHB1dEV2ZW50KGUsICdmaW5nZXJIb2xkJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09ICdwb2ludGVybW92ZScgJiYgZGlzdGFuY2UgPiB0aGlzLm1vdmluZ1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXRlRW51bS5NT1ZJTkc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNyZWF0ZU91dHB1dEV2ZW50KGUsICdmaW5nZXJNb3ZpbmdTdGFydCcpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSAncG9pbnRlcnVwJykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXRlRW51bS5UQVBTX0RFVEVDVDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdGVFbnVtLklETEU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jcmVhdGVPdXRwdXRFdmVudChlLCAnZmluZ2VyU2luZ2xlVGFwJykpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnRhcFRpbWVvdXRUaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5zdGF0ZUVudW0uVEFQU19ERVRFQ1Q6XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PSAncG9pbnRlcmRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdGVFbnVtLkRPVUJMRV9UQVBfREVURUNUO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNyZWF0ZU91dHB1dEV2ZW50KGUsICdmaW5nZXJIb2xkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS5kZWZhdWx0UHJldmVudGVkKSB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdGVFbnVtLklETEU7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMudGFwVGltZW91dFRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT0gJ3BvaW50ZXJtb3ZlJyAmJiBkaXN0YW5jZSA+IHRoaXMubW92aW5nVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdGVFbnVtLklETEU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNyZWF0ZU91dHB1dEV2ZW50KGUsICdmaW5nZXJIb3ZlcicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuc3RhdGVFbnVtLkRPVUJMRV9UQVBfREVURUNUOlxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gJ3BvaW50ZXJ1cCcgfHwgZS50eXBlID09ICdwb2ludGVyY2FuY2VsJykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXRlRW51bS5JRExFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jcmVhdGVPdXRwdXRFdmVudChlLCAnZmluZ2VyRG91YmxlVGFwJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5zdGF0ZUVudW0uRE9VQkxFX1RBUF9ERVRFQ1Q6XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PSAncG9pbnRlcm1vdmUnICYmIGRpc3RhbmNlID4gdGhpcy5tb3ZpbmdUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXRlRW51bS5NT1ZJTkc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLmNyZWF0ZU91dHB1dEV2ZW50KGUsICdmaW5nZXJNb3ZpbmdTdGFydCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuc3RhdGVFbnVtLk1PVklORzpcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09ICdwb2ludGVybW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtYWluIE1PVklOR1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jcmVhdGVPdXRwdXRFdmVudChlLCAnZmluZ2VyTW92aW5nJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09ICdwb2ludGVydXAnIHx8IGUudHlwZSA9PSAncG9pbnRlcmNhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXRlRW51bS5JRExFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jcmVhdGVPdXRwdXRFdmVudChlLCAnZmluZ2VyTW92aW5nRW5kJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUiBcIiArIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkVG9IaXN0b3J5KGUpO1xuICAgIH1cblxuICAgIGhhbmRsZUV2ZW50KGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc0xpa2VseVNhbWVQb2ludGVyKGUpKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJJZCA9IGUucG9pbnRlcklkOyAvL2l0J3MgbWluZVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXZlbnQoZSk7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaXNEb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT0gdGhpcy5zdGF0ZUVudW0uSURMRTtcbiAgICB9XG5cbn1cblxuY2xhc3MgQ2lyY3VsYXJCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhcGFjaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgIT0gXCJudW1iZXJcIiB8fCAhTnVtYmVyLmlzSW50ZWdlcihjYXBhY2l0eSkgfHwgY2FwYWNpdHkgPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgY2FwYWNpdHlcIik7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KGNhcGFjaXR5KTtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgICB0aGlzLmZpcnN0ID0gMDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT0gMDtcbiAgICB9XG5cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cblxuICAgIGNhcGFjaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYXBhY2l0eTtcbiAgICB9XG5cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiAwKSByZXN1bHQgPSB0aGlzLmJ1ZmZlclt0aGlzLmZpcnN0XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsYXN0KCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA+IDApIHJlc3VsdCA9IHRoaXMuYnVmZmVyWyh0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMSkgJSB0aGlzLmNhcGFjaXR5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBlbnF1ZXVlKHYpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9ICh0aGlzLmZpcnN0ID4gMCkgPyB0aGlzLmZpcnN0IC0gMSA6IHRoaXMuZmlyc3QgPSB0aGlzLmNhcGFjaXR5IC0gMTtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5maXJzdF0gPSB2O1xuICAgICAgICBpZiAodGhpcy5zaXplIDwgdGhpcy5jYXBhY2l0eSkgdGhpcy5zaXplKys7XG4gICAgfVxuXG4gICAgcHVzaCh2KSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT0gdGhpcy5jYXBhY2l0eSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5maXJzdF0gPSB2O1xuICAgICAgICAgICAgdGhpcy5maXJzdCA9ICh0aGlzLmZpcnN0ICsgMSkgJSB0aGlzLmNhcGFjaXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbKHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpICUgdGhpcy5jYXBhY2l0eV0gPSB2O1xuICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXF1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID09IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGVxdWV1ZSBvbiBlbXB0eSBidWZmZXJcIik7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmJ1ZmZlclsodGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDEpICUgdGhpcy5jYXBhY2l0eV07XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBwb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcXVldWUoKTtcbiAgICB9XG5cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PSAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNoaWZ0IG9uIGVtcHR5IGJ1ZmZlclwiKTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuYnVmZmVyW3RoaXMuZmlyc3RdO1xuICAgICAgICBpZiAodGhpcy5maXJzdCA9PSB0aGlzLmNhcGFjaXR5IC0gMSkgdGhpcy5maXJzdCA9IDA7IGVsc2UgdGhpcy5maXJzdCsrO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgZ2V0KHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PSAwICYmIHN0YXJ0ID09IDAgJiYgKGVuZCA9PSB1bmRlZmluZWQgfHwgZW5kID09IDApKSByZXR1cm4gW107XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgIT0gXCJudW1iZXJcIiB8fCAhTnVtYmVyLmlzSW50ZWdlcihzdGFydCkgfHwgc3RhcnQgPCAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGFydCB2YWx1ZVwiKTtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRoaXMuc2l6ZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdGFydCBpbmRleCBwYXN0IGVuZCBvZiBidWZmZXI6IFwiICsgc3RhcnQpO1xuXG4gICAgICAgIGlmIChlbmQgPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5idWZmZXJbKHRoaXMuZmlyc3QgKyBzdGFydCkgJSB0aGlzLmNhcGFjaXR5XTtcblxuICAgICAgICBpZiAodHlwZW9mIGVuZCAhPSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVuZCkgfHwgZW5kIDwgMCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZW5kIHZhbHVlXCIpO1xuICAgICAgICBpZiAoZW5kID49IHRoaXMuc2l6ZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbmQgaW5kZXggcGFzdCBlbmQgb2YgYnVmZmVyOiBcIiArIGVuZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZmlyc3QgKyBzdGFydCA+PSB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgICAgICBzdGFydCAtPSB0aGlzLmNhcGFjaXR5O1xuICAgICAgICAgICAgZW5kIC09IHRoaXMuY2FwYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlyc3QgKyBlbmQgPCB0aGlzLmNhcGFjaXR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMuZmlyc3QgKyBzdGFydCwgdGhpcy5maXJzdCArIGVuZCArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5maXJzdCArIHN0YXJ0LCB0aGlzLmNhcGFjaXR5KS5jb25jYXQodGhpcy5idWZmZXIuc2xpY2UoMCwgdGhpcy5maXJzdCArIGVuZCArIDEgLSB0aGlzLmNhcGFjaXR5KSk7XG4gICAgfVxuXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PSAwKSByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgwLCB0aGlzLnNpemUgLSAxKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgUG9pbnRlck1hbmFnZXIgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/PointerManager.js\n");

/***/ }),

/***/ "./src/Raster.js":
/*!***********************!*\
  !*** ./src/Raster.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Raster\": () => (/* binding */ Raster)\n/* harmony export */ });\n/**\n * An Raster Format describes the way that the images in textures and renderbuffers store their data.\n * * 'vec3' format must be specified if the image is RGB (without alpha).\n * * 'vec4' is related to RGBA images.\n * * 'float' is for file containg coefficients.\n * @typedef {('vec3'|'vec4'|'float')} Raster#Format\n */\n\n/**\n * Raster is a provider of image and/or plane of coefficients.\n * It support all file formats supported by {@link Layout}.\n * \n * An object literal with Raster `options` can be specified.\n *  * @param {Object} [options] An object literal describing the raster content.\n * @param {Raster#Format} options.format='vec3' The color format of the image.\n */\n\nclass Raster {\n\n\tconstructor(options) {\n\n\t\tObject.assign(this, { \n\t\t\tformat: 'vec3', \n\t\t });\n\n\t\tObject.assign(this, options);\n\t}\n\n\t/**\n\t * Gets a tile.\n\t * @param {Tile} tile A tile.\n\t * @param {WebGLRenderingContext} gl The WebGL rendering context .\n\t * @returns {'[tex, size]'} A pair (tex,size).\n\t */\n\tasync loadImage(tile, gl) {\n\t\tlet img;\n\t\tlet cors = (new URL(tile.url, window.location.href)).origin !== window.location.origin;\n\t\tif (tile.end || typeof createImageBitmap == 'undefined') {\n\t\t\tlet options = {};\n\t\t\toptions.headers = { range: `bytes=${tile.start}-${tile.end}`, 'Accept-Encoding': 'indentity', mode: cors? 'cors' : 'same-origin' };\n\t\t\tlet response = await fetch(tile.url, options);\n\t\t\tif (!response.ok) {\n\t\t\t\tcallback(\"Failed loading \" + tile.url + \": \" + response.statusText);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (response.status != 206)\n\t\t\t\tthrow \"The server doesn't support partial content requests (206).\";\n\n\t\t\tlet blob = await response.blob();\n\t\t\timg = await this.blobToImage(blob, gl);\n\t\t} else {\n\t\t\timg = document.createElement('img');\n\t\t\tif (cors) img.crossOrigin=\"\";\n\t\t\timg.onerror = function (e) { console.log(\"Texture loading error!\"); };\n\t\t\timg.src = tile.url;\n\t\t\tawait new Promise((resolve, reject) => { img.onload = () => resolve() });\n\t\t}\n\t\tlet tex = this.loadTexture(gl, img);\n\t\t//TODO 3 is not accurate for type of image, when changing from rgb to grayscale, fix this value.\n\t\tlet size = img.width * img.height * 3;\n\t\treturn [tex, size];\t\n\t}\n\n\t/** @ignore */\n\tasync blobToImage(blob, gl) {\n\t\tlet tex, img;\n\t\tif(typeof createImageBitmap != 'undefined') {\n\t\t\tvar isFirefox = typeof InstallTrigger !== 'undefined';\n\t\t\t//firefox does not support options for this call, BUT the image is automatically flipped.\n\t\t\tif(isFirefox)\n\t\t\t\timg = await createImageBitmap(blob); \n\t\t\telse\n\t\t\t\timg = await createImageBitmap(blob, { imageOrientation1: 'flipY' });\n\n\t\t} else { //fallback for IOS\n\t\t\tlet urlCreator = window.URL || window.webkitURL;\n\t\t\timg = document.createElement('img');\n\t\t\timg.onerror = function(e) { console.log(\"Texture loading error!\"); };\n\t\t\timg.src = urlCreator.createObjectURL(blob);\n\n\t\t\tawait new Promise((resolve, reject) => { img.onload = () => resolve() });\n\t\t\turlCreator.revokeObjectURL(img.src);\n\t\t\t\n\t\t}\n\t\treturn img;\t\t\n\t}\n\n\t/** @ignore */\n\tloadTexture(gl, img) {\n\t\tthis.width = img.width;  //this will be useful for layout image.\n\t\tthis.height = img.height;\n\n\t\tvar tex = gl.createTexture();\n\t\tgl.bindTexture(gl.TEXTURE_2D, tex);\n\t\tgl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\tgl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); //_MIPMAP_LINEAR);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\tlet glFormat = gl.RGBA;\n\t\tswitch(this.format) {\n\t\t\tcase 'vec3':\n\t\t\t\tglFormat = gl.RGB;\n\t\t\t\tbreak;\n\t\t\tcase 'vec4':\n\t\t\t\tglFormat = gl.RGBA;\n\t\t\t\tbreak;\n\t\t\tcase 'float':\n\t\t\t\tglFormat = gl.LUMINANCE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t} \n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, img);\n\t\treturn tex;\n\t}\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUmFzdGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsV0FBVyxlQUFlO0FBQzFCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLHVCQUF1QjtBQUNuQyxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQixXQUFXLEdBQUcsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0Qjs7QUFFdEUsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQSw0Q0FBNEMsOEJBQThCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9SYXN0ZXIuanM/OTg1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFuIFJhc3RlciBGb3JtYXQgZGVzY3JpYmVzIHRoZSB3YXkgdGhhdCB0aGUgaW1hZ2VzIGluIHRleHR1cmVzIGFuZCByZW5kZXJidWZmZXJzIHN0b3JlIHRoZWlyIGRhdGEuXG4gKiAqICd2ZWMzJyBmb3JtYXQgbXVzdCBiZSBzcGVjaWZpZWQgaWYgdGhlIGltYWdlIGlzIFJHQiAod2l0aG91dCBhbHBoYSkuXG4gKiAqICd2ZWM0JyBpcyByZWxhdGVkIHRvIFJHQkEgaW1hZ2VzLlxuICogKiAnZmxvYXQnIGlzIGZvciBmaWxlIGNvbnRhaW5nIGNvZWZmaWNpZW50cy5cbiAqIEB0eXBlZGVmIHsoJ3ZlYzMnfCd2ZWM0J3wnZmxvYXQnKX0gUmFzdGVyI0Zvcm1hdFxuICovXG5cbi8qKlxuICogUmFzdGVyIGlzIGEgcHJvdmlkZXIgb2YgaW1hZ2UgYW5kL29yIHBsYW5lIG9mIGNvZWZmaWNpZW50cy5cbiAqIEl0IHN1cHBvcnQgYWxsIGZpbGUgZm9ybWF0cyBzdXBwb3J0ZWQgYnkge0BsaW5rIExheW91dH0uXG4gKiBcbiAqIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggUmFzdGVyIGBvcHRpb25zYCBjYW4gYmUgc3BlY2lmaWVkLlxuICogICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCBkZXNjcmliaW5nIHRoZSByYXN0ZXIgY29udGVudC5cbiAqIEBwYXJhbSB7UmFzdGVyI0Zvcm1hdH0gb3B0aW9ucy5mb3JtYXQ9J3ZlYzMnIFRoZSBjb2xvciBmb3JtYXQgb2YgdGhlIGltYWdlLlxuICovXG5cbmNsYXNzIFJhc3RlciB7XG5cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7IFxuXHRcdFx0Zm9ybWF0OiAndmVjMycsIFxuXHRcdCB9KTtcblxuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhIHRpbGUuXG5cdCAqIEBwYXJhbSB7VGlsZX0gdGlsZSBBIHRpbGUuXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQgLlxuXHQgKiBAcmV0dXJucyB7J1t0ZXgsIHNpemVdJ30gQSBwYWlyICh0ZXgsc2l6ZSkuXG5cdCAqL1xuXHRhc3luYyBsb2FkSW1hZ2UodGlsZSwgZ2wpIHtcblx0XHRsZXQgaW1nO1xuXHRcdGxldCBjb3JzID0gKG5ldyBVUkwodGlsZS51cmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSkub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuXHRcdGlmICh0aWxlLmVuZCB8fCB0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGxldCBvcHRpb25zID0ge307XG5cdFx0XHRvcHRpb25zLmhlYWRlcnMgPSB7IHJhbmdlOiBgYnl0ZXM9JHt0aWxlLnN0YXJ0fS0ke3RpbGUuZW5kfWAsICdBY2NlcHQtRW5jb2RpbmcnOiAnaW5kZW50aXR5JywgbW9kZTogY29ycz8gJ2NvcnMnIDogJ3NhbWUtb3JpZ2luJyB9O1xuXHRcdFx0bGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGlsZS51cmwsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKCFyZXNwb25zZS5vaykge1xuXHRcdFx0XHRjYWxsYmFjayhcIkZhaWxlZCBsb2FkaW5nIFwiICsgdGlsZS51cmwgKyBcIjogXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzICE9IDIwNilcblx0XHRcdFx0dGhyb3cgXCJUaGUgc2VydmVyIGRvZXNuJ3Qgc3VwcG9ydCBwYXJ0aWFsIGNvbnRlbnQgcmVxdWVzdHMgKDIwNikuXCI7XG5cblx0XHRcdGxldCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuXHRcdFx0aW1nID0gYXdhaXQgdGhpcy5ibG9iVG9JbWFnZShibG9iLCBnbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXHRcdFx0aWYgKGNvcnMpIGltZy5jcm9zc09yaWdpbj1cIlwiO1xuXHRcdFx0aW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkgeyBjb25zb2xlLmxvZyhcIlRleHR1cmUgbG9hZGluZyBlcnJvciFcIik7IH07XG5cdFx0XHRpbWcuc3JjID0gdGlsZS51cmw7XG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7IGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCkgfSk7XG5cdFx0fVxuXHRcdGxldCB0ZXggPSB0aGlzLmxvYWRUZXh0dXJlKGdsLCBpbWcpO1xuXHRcdC8vVE9ETyAzIGlzIG5vdCBhY2N1cmF0ZSBmb3IgdHlwZSBvZiBpbWFnZSwgd2hlbiBjaGFuZ2luZyBmcm9tIHJnYiB0byBncmF5c2NhbGUsIGZpeCB0aGlzIHZhbHVlLlxuXHRcdGxldCBzaXplID0gaW1nLndpZHRoICogaW1nLmhlaWdodCAqIDM7XG5cdFx0cmV0dXJuIFt0ZXgsIHNpemVdO1x0XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRhc3luYyBibG9iVG9JbWFnZShibG9iLCBnbCkge1xuXHRcdGxldCB0ZXgsIGltZztcblx0XHRpZih0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgIT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXHRcdFx0Ly9maXJlZm94IGRvZXMgbm90IHN1cHBvcnQgb3B0aW9ucyBmb3IgdGhpcyBjYWxsLCBCVVQgdGhlIGltYWdlIGlzIGF1dG9tYXRpY2FsbHkgZmxpcHBlZC5cblx0XHRcdGlmKGlzRmlyZWZveClcblx0XHRcdFx0aW1nID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7IFxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRpbWcgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCB7IGltYWdlT3JpZW50YXRpb24xOiAnZmxpcFknIH0pO1xuXG5cdFx0fSBlbHNlIHsgLy9mYWxsYmFjayBmb3IgSU9TXG5cdFx0XHRsZXQgdXJsQ3JlYXRvciA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblx0XHRcdGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXHRcdFx0aW1nLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7IGNvbnNvbGUubG9nKFwiVGV4dHVyZSBsb2FkaW5nIGVycm9yIVwiKTsgfTtcblx0XHRcdGltZy5zcmMgPSB1cmxDcmVhdG9yLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRcdFx0YXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4geyBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSgpIH0pO1xuXHRcdFx0dXJsQ3JlYXRvci5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7XG5cdFx0XHRcblx0XHR9XG5cdFx0cmV0dXJuIGltZztcdFx0XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRsb2FkVGV4dHVyZShnbCwgaW1nKSB7XG5cdFx0dGhpcy53aWR0aCA9IGltZy53aWR0aDsgIC8vdGhpcyB3aWxsIGJlIHVzZWZ1bCBmb3IgbGF5b3V0IGltYWdlLlxuXHRcdHRoaXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuXHRcdHZhciB0ZXggPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4KTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTsgLy9fTUlQTUFQX0xJTkVBUik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0bGV0IGdsRm9ybWF0ID0gZ2wuUkdCQTtcblx0XHRzd2l0Y2godGhpcy5mb3JtYXQpIHtcblx0XHRcdGNhc2UgJ3ZlYzMnOlxuXHRcdFx0XHRnbEZvcm1hdCA9IGdsLlJHQjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd2ZWM0Jzpcblx0XHRcdFx0Z2xGb3JtYXQgPSBnbC5SR0JBO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Zsb2F0Jzpcblx0XHRcdFx0Z2xGb3JtYXQgPSBnbC5MVU1JTkFOQ0U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0YnJlYWs7XG5cdFx0fSBcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcblx0XHRyZXR1cm4gdGV4O1xuXHR9XG59XG5cbmV4cG9ydCB7IFJhc3RlciB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Raster.js\n");

/***/ }),

/***/ "./src/Ruler.js":
/*!**********************!*\
  !*** ./src/Ruler.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ruler\": () => (/* binding */ Ruler)\n/* harmony export */ });\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ \"./src/Util.js\");\n/* harmony import */ var _ScaleBar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ScaleBar */ \"./src/ScaleBar.js\");\n\n\n\n\n/* color is specified in the css under the .openlime-ruler selector */\n\nclass Ruler extends _ScaleBar__WEBPACK_IMPORTED_MODULE_1__.Units {\n\tconstructor(viewer, pixelSize, options) {\n\t\tsuper(options);\n\t\tObject.assign(this, {\n\t\t\tviewer: viewer,\n\t\t\tcamera: viewer.camera,\n\t\t\toverlay: viewer.overlayElement,\n\t\t\tpixelSize: pixelSize,\n\t\t\tenabled: false,\n\t\t\tpriority: 100,\n\t\t\tmeasure: null, //current measure\n\t\t\thistory: [],  //past measures\n\t\t\tfontSize: 18,\n\t\t\tmarkerSize: 8,\n\t\t\tcursor: \"crosshair\",\n\n\t\t\tsvg: null,\n\t\t\tfirst: null,\n\t\t\tsecond: null\n\t\t});\n\t\tif(options)\n\t\t\tObject.assign(this, options);\n\t}\n\t\n\tstart() {\n\t\tthis.enabled = true;\n\t\tthis.previousCursor = this.overlay.style.cursor;\n\t\tthis.overlay.style.cursor = this.cursor;\n\n\t\tif(!this.svg) {\n\t\t\tthis.svg = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement('svg', { class: 'openlime-ruler'} );\n\t\t\tthis.svgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n\t\t\tthis.svg.append(this.svgGroup);\n\t\t\tthis.overlay.appendChild(this.svg);\n\t\t\tthis.viewer.addEvent('draw', () => this.update());\n\t\t\tthis.update();\n\t\t}\n\t}\n\n\tend() {\n\t\tthis.enabled = false;\n\t\tthis.overlay.style.cursor = this.previousCursor;\n\t\tthis.clear();\n\t}\n\t\n\tclear() {\n\t\tthis.svgGroup.replaceChildren([]);\n\t\tthis.measure = null;\n\t\tthis.history = [];\n\t}\n\n\t/*finish() {\n\t\tlet m = this.measure;\n\t\tm.line = Util.createSVGElement('line', { x1: m.x1, y1: m.y1, x2: m.x2, y2: m.y2 });\n\t\tthis.svgGroup.appendChild(m.line);\n\n\t\tm.text = Util.createSVGElement('text');\n\t\tm.text.textContent = this.format(this.length(m));\n\t\tthis.svgGroup.appendChild(m.text);\n\n\t\tthis.history.push(m);\n\t\tthis.measure = null;\n\t\tthis.update();\n\t}*/\n\n\t/** @ignore */\n\tupdate() {\n\t\tif(!this.history.length)\n\t\t\treturn;\n\t\t//if not enabled skip\n\t\tlet t = this.camera.getGlCurrentTransform(performance.now());\n\t\tlet viewport = this.camera.glViewport();\n\t\tthis.svg.setAttribute('viewBox', `${-viewport.w / 2} ${-viewport.h / 2} ${viewport.w} ${viewport.h}`);\n\t\tlet c = {x:0, y:0}; //this.boundingBox().corner(0);\n\t\tthis.svgGroup.setAttribute(\"transform\",\n\t\t\t`translate(${t.x} ${t.y}) rotate(${-t.a} 0 0) scale(${t.z} ${t.z}) translate(${c.x} ${c.y})`);\n\n\t\tfor(let m of this.history) \n\t\t\tthis.updateMeasure(m, t);\n\t}\n\n\t/** @ignore */\n\tcreateMarker(x, y) {\n\t\tlet m = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement(\"path\");\n\t\tthis.svgGroup.appendChild(m);\n\t\treturn m;\n\t}\n\n\t/** @ignore */\n\tupdateMarker(marker, x, y, size) {\n\t\tlet d = `M ${x-size} ${y} L ${x+size} ${y} M ${x} ${y-size} L ${x} ${y+size}`;\n\t\tmarker.setAttribute('d', d);\n\t}\n\n\t/** @ignore */\n\tupdateText(measure, fontsize) {\n\t\tmeasure.text.setAttribute('font-size', fontsize + \"px\");\n\t\t\n\t\tlet dx = measure.x1 - measure.x2;\n\t\tlet dy = measure.y1 - measure.y2;\n\n\t\tlet length = Math.sqrt(dx*dx + dy*dy);\n\t\tif(length > 0) {\n\t\t\tdx /= length;\n\t\t\tdy /= length;\n\t\t}\n\t\tif(dx < 0) {\n\t\t\tdx = -dx;\n\t\t\tdy = -dy;\n\t\t}\n\n\t\tlet mx = (measure.x1 + measure.x2)/2;\n\t\tlet my = (measure.y1 + measure.y2)/2;\n\t\tif(dy/dx < 0) {\n\t\t\tmx -= 0.25*dy*fontsize;\n\t\t\tmy += dx*fontsize;\n\t\t} else {\n\t\t\tmy -= 0.25*fontsize;\n\t\t\tmx += 0.25*fontsize;\n\t\t}\n\t\tmeasure.text.setAttribute('x', mx);\n\t\tmeasure.text.setAttribute('y', my);\n\t\tmeasure.text.textContent = this.format(length*this.pixelSize);\n\t}\n\n\t/** @ignore */\n\tcreateMeasure(x, y) {\n\t\tlet m = {\n\t\t\tmarker1: this.createMarker(x, y), \n\t\t\tx1: x, y1: y,\n\t\t\tmarker2: this.createMarker(x, y), \n\t\t\tx2: x, y2: y\n\t\t};\n\t\tm.line = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement('line', { x1: m.x1, y1: m.y1, x2: m.x2, y2: m.y2 });\n\t\tthis.svgGroup.appendChild(m.line);\n\n\t\tm.text = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement('text');\n\t\tm.text.textContent = '';\n\t\tthis.svgGroup.appendChild(m.text);\n\n\t\treturn m;\n\t}\n\n\t/** @ignore */\n\tupdateMeasure(measure, transform) {\n\t\tlet markersize = window.devicePixelRatio*this.markerSize/transform.z;\n\n\t\tthis.updateMarker(measure.marker1, measure.x1, measure.y1, markersize);\n\n\t\tthis.updateMarker(measure.marker2, measure.x2, measure.y2, markersize);\n\n\t\tlet fontsize = window.devicePixelRatio*this.fontSize/transform.z;\n\t\tthis.updateText(measure, fontsize);\n\n\t\tfor(let p of ['x1', 'y1', 'x2', 'y2'])\n\t\t\tmeasure.line.setAttribute(p, measure[p]);\n\t}\n\n\t/** @ignore */\n\tfingerSingleTap(e) { \n\t\tif(!this.enabled)\n\t\t\treturn false;\n\n\t\tlet transform = this.camera.getCurrentTransform(performance.now())\n\t\tlet {x, y}  = this.camera.mapToScene(e.layerX, e.layerY, transform);\n\n\t\t\n\t\tif(!this.measure) {\n\t\t\tthis.measure = this.createMeasure(x, y);\n\t\t\tthis.history.push(this.measure);\n\t\t} else {\n\t\t\tthis.measure.x2 = x;\n\t\t\tthis.measure.y2 = y;\n\t\t\tthis.measure = null;\n\t\t}\n\t\tthis.update();\n\t\te.preventDefault();\n\t}\n\t/** @ignore */\n\tfingerHover(e) {\n\t\tif(!this.enabled || !this.measure)\n\t\t\treturn false;\n\n\t\tlet transform = this.camera.getCurrentTransform(performance.now())\n\t\tlet {x, y}  = this.camera.mapToScene(e.layerX, e.layerY, transform);\n\t\tthis.measure.x2 = x;\n\t\tthis.measure.y2 = y;\n\t\tthis.update();\t\n\t\te.preventDefault();\n\t}\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUnVsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZCO0FBQ0s7OztBQUdsQzs7QUFFQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsd0RBQXFCLFVBQVUseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyx3Q0FBd0M7QUFDbkY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxFQUFFLFdBQVc7QUFDckcsV0FBVyxXQUFXO0FBQ3RCO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxJQUFJLFdBQVcsTUFBTSxhQUFhLEtBQUssRUFBRSxJQUFJLGNBQWMsS0FBSyxFQUFFLElBQUk7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx3REFBcUI7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsRUFBRSxHQUFHLElBQUksUUFBUSxFQUFFLEdBQUcsSUFBSSxHQUFHLEVBQUUsUUFBUSxJQUFJLEdBQUcsRUFBRSxPQUFPO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFxQixXQUFXLHdDQUF3QztBQUNuRjs7QUFFQSxXQUFXLHdEQUFxQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxPQUFPOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLE9BQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvUnVsZXIuanM/M2ZlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVdGlsIH0gZnJvbSAnLi9VdGlsJ1xuaW1wb3J0IHsgVW5pdHMgfSBmcm9tICcuL1NjYWxlQmFyJ1xuXG5cbi8qIGNvbG9yIGlzIHNwZWNpZmllZCBpbiB0aGUgY3NzIHVuZGVyIHRoZSAub3BlbmxpbWUtcnVsZXIgc2VsZWN0b3IgKi9cblxuY2xhc3MgUnVsZXIgZXh0ZW5kcyBVbml0cyB7XG5cdGNvbnN0cnVjdG9yKHZpZXdlciwgcGl4ZWxTaXplLCBvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XG5cdFx0XHR2aWV3ZXI6IHZpZXdlcixcblx0XHRcdGNhbWVyYTogdmlld2VyLmNhbWVyYSxcblx0XHRcdG92ZXJsYXk6IHZpZXdlci5vdmVybGF5RWxlbWVudCxcblx0XHRcdHBpeGVsU2l6ZTogcGl4ZWxTaXplLFxuXHRcdFx0ZW5hYmxlZDogZmFsc2UsXG5cdFx0XHRwcmlvcml0eTogMTAwLFxuXHRcdFx0bWVhc3VyZTogbnVsbCwgLy9jdXJyZW50IG1lYXN1cmVcblx0XHRcdGhpc3Rvcnk6IFtdLCAgLy9wYXN0IG1lYXN1cmVzXG5cdFx0XHRmb250U2l6ZTogMTgsXG5cdFx0XHRtYXJrZXJTaXplOiA4LFxuXHRcdFx0Y3Vyc29yOiBcImNyb3NzaGFpclwiLFxuXG5cdFx0XHRzdmc6IG51bGwsXG5cdFx0XHRmaXJzdDogbnVsbCxcblx0XHRcdHNlY29uZDogbnVsbFxuXHRcdH0pO1xuXHRcdGlmKG9wdGlvbnMpXG5cdFx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXHR9XG5cdFxuXHRzdGFydCgpIHtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMucHJldmlvdXNDdXJzb3IgPSB0aGlzLm92ZXJsYXkuc3R5bGUuY3Vyc29yO1xuXHRcdHRoaXMub3ZlcmxheS5zdHlsZS5jdXJzb3IgPSB0aGlzLmN1cnNvcjtcblxuXHRcdGlmKCF0aGlzLnN2Zykge1xuXHRcdFx0dGhpcy5zdmcgPSBVdGlsLmNyZWF0ZVNWR0VsZW1lbnQoJ3N2ZycsIHsgY2xhc3M6ICdvcGVubGltZS1ydWxlcid9ICk7XG5cdFx0XHR0aGlzLnN2Z0dyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdnJyk7XG5cdFx0XHR0aGlzLnN2Zy5hcHBlbmQodGhpcy5zdmdHcm91cCk7XG5cdFx0XHR0aGlzLm92ZXJsYXkuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuXHRcdFx0dGhpcy52aWV3ZXIuYWRkRXZlbnQoJ2RyYXcnLCAoKSA9PiB0aGlzLnVwZGF0ZSgpKTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0ZW5kKCkge1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMub3ZlcmxheS5zdHlsZS5jdXJzb3IgPSB0aGlzLnByZXZpb3VzQ3Vyc29yO1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXHRcblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5zdmdHcm91cC5yZXBsYWNlQ2hpbGRyZW4oW10pO1xuXHRcdHRoaXMubWVhc3VyZSA9IG51bGw7XG5cdFx0dGhpcy5oaXN0b3J5ID0gW107XG5cdH1cblxuXHQvKmZpbmlzaCgpIHtcblx0XHRsZXQgbSA9IHRoaXMubWVhc3VyZTtcblx0XHRtLmxpbmUgPSBVdGlsLmNyZWF0ZVNWR0VsZW1lbnQoJ2xpbmUnLCB7IHgxOiBtLngxLCB5MTogbS55MSwgeDI6IG0ueDIsIHkyOiBtLnkyIH0pO1xuXHRcdHRoaXMuc3ZnR3JvdXAuYXBwZW5kQ2hpbGQobS5saW5lKTtcblxuXHRcdG0udGV4dCA9IFV0aWwuY3JlYXRlU1ZHRWxlbWVudCgndGV4dCcpO1xuXHRcdG0udGV4dC50ZXh0Q29udGVudCA9IHRoaXMuZm9ybWF0KHRoaXMubGVuZ3RoKG0pKTtcblx0XHR0aGlzLnN2Z0dyb3VwLmFwcGVuZENoaWxkKG0udGV4dCk7XG5cblx0XHR0aGlzLmhpc3RvcnkucHVzaChtKTtcblx0XHR0aGlzLm1lYXN1cmUgPSBudWxsO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0qL1xuXG5cdC8qKiBAaWdub3JlICovXG5cdHVwZGF0ZSgpIHtcblx0XHRpZighdGhpcy5oaXN0b3J5Lmxlbmd0aClcblx0XHRcdHJldHVybjtcblx0XHQvL2lmIG5vdCBlbmFibGVkIHNraXBcblx0XHRsZXQgdCA9IHRoaXMuY2FtZXJhLmdldEdsQ3VycmVudFRyYW5zZm9ybShwZXJmb3JtYW5jZS5ub3coKSk7XG5cdFx0bGV0IHZpZXdwb3J0ID0gdGhpcy5jYW1lcmEuZ2xWaWV3cG9ydCgpO1xuXHRcdHRoaXMuc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIGAkey12aWV3cG9ydC53IC8gMn0gJHstdmlld3BvcnQuaCAvIDJ9ICR7dmlld3BvcnQud30gJHt2aWV3cG9ydC5ofWApO1xuXHRcdGxldCBjID0ge3g6MCwgeTowfTsgLy90aGlzLmJvdW5kaW5nQm94KCkuY29ybmVyKDApO1xuXHRcdHRoaXMuc3ZnR3JvdXAuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsXG5cdFx0XHRgdHJhbnNsYXRlKCR7dC54fSAke3QueX0pIHJvdGF0ZSgkey10LmF9IDAgMCkgc2NhbGUoJHt0Lnp9ICR7dC56fSkgdHJhbnNsYXRlKCR7Yy54fSAke2MueX0pYCk7XG5cblx0XHRmb3IobGV0IG0gb2YgdGhpcy5oaXN0b3J5KSBcblx0XHRcdHRoaXMudXBkYXRlTWVhc3VyZShtLCB0KTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGNyZWF0ZU1hcmtlcih4LCB5KSB7XG5cdFx0bGV0IG0gPSBVdGlsLmNyZWF0ZVNWR0VsZW1lbnQoXCJwYXRoXCIpO1xuXHRcdHRoaXMuc3ZnR3JvdXAuYXBwZW5kQ2hpbGQobSk7XG5cdFx0cmV0dXJuIG07XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR1cGRhdGVNYXJrZXIobWFya2VyLCB4LCB5LCBzaXplKSB7XG5cdFx0bGV0IGQgPSBgTSAke3gtc2l6ZX0gJHt5fSBMICR7eCtzaXplfSAke3l9IE0gJHt4fSAke3ktc2l6ZX0gTCAke3h9ICR7eStzaXplfWA7XG5cdFx0bWFya2VyLnNldEF0dHJpYnV0ZSgnZCcsIGQpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0dXBkYXRlVGV4dChtZWFzdXJlLCBmb250c2l6ZSkge1xuXHRcdG1lYXN1cmUudGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIGZvbnRzaXplICsgXCJweFwiKTtcblx0XHRcblx0XHRsZXQgZHggPSBtZWFzdXJlLngxIC0gbWVhc3VyZS54Mjtcblx0XHRsZXQgZHkgPSBtZWFzdXJlLnkxIC0gbWVhc3VyZS55MjtcblxuXHRcdGxldCBsZW5ndGggPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG5cdFx0aWYobGVuZ3RoID4gMCkge1xuXHRcdFx0ZHggLz0gbGVuZ3RoO1xuXHRcdFx0ZHkgLz0gbGVuZ3RoO1xuXHRcdH1cblx0XHRpZihkeCA8IDApIHtcblx0XHRcdGR4ID0gLWR4O1xuXHRcdFx0ZHkgPSAtZHk7XG5cdFx0fVxuXG5cdFx0bGV0IG14ID0gKG1lYXN1cmUueDEgKyBtZWFzdXJlLngyKS8yO1xuXHRcdGxldCBteSA9IChtZWFzdXJlLnkxICsgbWVhc3VyZS55MikvMjtcblx0XHRpZihkeS9keCA8IDApIHtcblx0XHRcdG14IC09IDAuMjUqZHkqZm9udHNpemU7XG5cdFx0XHRteSArPSBkeCpmb250c2l6ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bXkgLT0gMC4yNSpmb250c2l6ZTtcblx0XHRcdG14ICs9IDAuMjUqZm9udHNpemU7XG5cdFx0fVxuXHRcdG1lYXN1cmUudGV4dC5zZXRBdHRyaWJ1dGUoJ3gnLCBteCk7XG5cdFx0bWVhc3VyZS50ZXh0LnNldEF0dHJpYnV0ZSgneScsIG15KTtcblx0XHRtZWFzdXJlLnRleHQudGV4dENvbnRlbnQgPSB0aGlzLmZvcm1hdChsZW5ndGgqdGhpcy5waXhlbFNpemUpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0Y3JlYXRlTWVhc3VyZSh4LCB5KSB7XG5cdFx0bGV0IG0gPSB7XG5cdFx0XHRtYXJrZXIxOiB0aGlzLmNyZWF0ZU1hcmtlcih4LCB5KSwgXG5cdFx0XHR4MTogeCwgeTE6IHksXG5cdFx0XHRtYXJrZXIyOiB0aGlzLmNyZWF0ZU1hcmtlcih4LCB5KSwgXG5cdFx0XHR4MjogeCwgeTI6IHlcblx0XHR9O1xuXHRcdG0ubGluZSA9IFV0aWwuY3JlYXRlU1ZHRWxlbWVudCgnbGluZScsIHsgeDE6IG0ueDEsIHkxOiBtLnkxLCB4MjogbS54MiwgeTI6IG0ueTIgfSk7XG5cdFx0dGhpcy5zdmdHcm91cC5hcHBlbmRDaGlsZChtLmxpbmUpO1xuXG5cdFx0bS50ZXh0ID0gVXRpbC5jcmVhdGVTVkdFbGVtZW50KCd0ZXh0Jyk7XG5cdFx0bS50ZXh0LnRleHRDb250ZW50ID0gJyc7XG5cdFx0dGhpcy5zdmdHcm91cC5hcHBlbmRDaGlsZChtLnRleHQpO1xuXG5cdFx0cmV0dXJuIG07XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR1cGRhdGVNZWFzdXJlKG1lYXN1cmUsIHRyYW5zZm9ybSkge1xuXHRcdGxldCBtYXJrZXJzaXplID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8qdGhpcy5tYXJrZXJTaXplL3RyYW5zZm9ybS56O1xuXG5cdFx0dGhpcy51cGRhdGVNYXJrZXIobWVhc3VyZS5tYXJrZXIxLCBtZWFzdXJlLngxLCBtZWFzdXJlLnkxLCBtYXJrZXJzaXplKTtcblxuXHRcdHRoaXMudXBkYXRlTWFya2VyKG1lYXN1cmUubWFya2VyMiwgbWVhc3VyZS54MiwgbWVhc3VyZS55MiwgbWFya2Vyc2l6ZSk7XG5cblx0XHRsZXQgZm9udHNpemUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyp0aGlzLmZvbnRTaXplL3RyYW5zZm9ybS56O1xuXHRcdHRoaXMudXBkYXRlVGV4dChtZWFzdXJlLCBmb250c2l6ZSk7XG5cblx0XHRmb3IobGV0IHAgb2YgWyd4MScsICd5MScsICd4MicsICd5MiddKVxuXHRcdFx0bWVhc3VyZS5saW5lLnNldEF0dHJpYnV0ZShwLCBtZWFzdXJlW3BdKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGZpbmdlclNpbmdsZVRhcChlKSB7IFxuXHRcdGlmKCF0aGlzLmVuYWJsZWQpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRsZXQgdHJhbnNmb3JtID0gdGhpcy5jYW1lcmEuZ2V0Q3VycmVudFRyYW5zZm9ybShwZXJmb3JtYW5jZS5ub3coKSlcblx0XHRsZXQge3gsIHl9ICA9IHRoaXMuY2FtZXJhLm1hcFRvU2NlbmUoZS5sYXllclgsIGUubGF5ZXJZLCB0cmFuc2Zvcm0pO1xuXG5cdFx0XG5cdFx0aWYoIXRoaXMubWVhc3VyZSkge1xuXHRcdFx0dGhpcy5tZWFzdXJlID0gdGhpcy5jcmVhdGVNZWFzdXJlKHgsIHkpO1xuXHRcdFx0dGhpcy5oaXN0b3J5LnB1c2godGhpcy5tZWFzdXJlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tZWFzdXJlLngyID0geDtcblx0XHRcdHRoaXMubWVhc3VyZS55MiA9IHk7XG5cdFx0XHR0aGlzLm1lYXN1cmUgPSBudWxsO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0fVxuXHQvKiogQGlnbm9yZSAqL1xuXHRmaW5nZXJIb3ZlcihlKSB7XG5cdFx0aWYoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5tZWFzdXJlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0bGV0IHRyYW5zZm9ybSA9IHRoaXMuY2FtZXJhLmdldEN1cnJlbnRUcmFuc2Zvcm0ocGVyZm9ybWFuY2Uubm93KCkpXG5cdFx0bGV0IHt4LCB5fSAgPSB0aGlzLmNhbWVyYS5tYXBUb1NjZW5lKGUubGF5ZXJYLCBlLmxheWVyWSwgdHJhbnNmb3JtKTtcblx0XHR0aGlzLm1lYXN1cmUueDIgPSB4O1xuXHRcdHRoaXMubWVhc3VyZS55MiA9IHk7XG5cdFx0dGhpcy51cGRhdGUoKTtcdFxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0fVxufTtcblxuZXhwb3J0IHsgUnVsZXIgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Ruler.js\n");

/***/ }),

/***/ "./src/ScaleBar.js":
/*!*************************!*\
  !*** ./src/ScaleBar.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScaleBar\": () => (/* binding */ ScaleBar),\n/* harmony export */   \"Units\": () => (/* binding */ Units)\n/* harmony export */ });\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ \"./src/Util.js\");\n\n\n/* units are those in use, scale and ruler will pick the appropriate unit \n   allUnits contains all of the known units */\n\nclass Units {\n    constructor(options) {\n        this.units = [\"km\", \"m\", \"cm\", \"mm\"],\n        this.allUnits = { \"mm\": 1, \"cm\": 10, \"m\": 1000, \"km\": 1e6, \"in\": 254, \"ft\": 254*12,  }\n        this.precision = 2;\n        if(options)\n            Object.assign(options, this);\n    }\n\n    format(d, unit) {\n\t\tif(d == 0)\n\t\t\treturn '';\n        if(unit)\n            return (d/this.allUnits[unit]).toFixed(this.precision) + unit;\n        \n        let best_u = null;\n        let best_penalty = 100;\n        for(let u of this.units) {\n            let size = this.allUnits[u];\n            let penalty = d <= 0 ? 0 : Math.abs(Math.log10(d/size)-1);\n            if(penalty < best_penalty) {\n                best_u = u;\n                best_penalty = penalty;\n            }\n        }\n        return this.format(d, best_u);\n    }\n}\n\nclass ScaleBar extends Units {\n    constructor(pixelSize, viewer, options) {\n\t\tsuper(options)\n        options = Object.assign(this, {\n            pixelSize: pixelSize,\n            viewer: viewer,\n            width: 200,\n            fontSize: 24,\n\t\t\tprecision: 0\n        }, options);\n\t\tObject.assign(this, options);\n\n\t\tthis.svg = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement('svg', { viewBox: `0 0 ${this.width} 30` });\n\t\tthis.svg.classList.add('openlime-scale');\n\n\t\tthis.line = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement('line', { x1: 5, y1: 26.5, x2:this.width - 5, y2: 26.5 });\n\n\t\tthis.text = _Util__WEBPACK_IMPORTED_MODULE_0__.Util.createSVGElement('text', { x: '50%', y: '16px', 'dominant-basiline': 'middle', 'text-anchor': 'middle' });\n\t\tthis.text.textContent = \"\";\n\t\t\n\t\tthis.svg.appendChild(this.line);\n\t\tthis.svg.appendChild(this.text);\n\t\tthis.viewer.containerElement.appendChild(this.svg);\n\t\tthis.viewer.addEvent('draw', () => { this.updateScale(); });\n    }\n\n\t/** @ignore */\n\tupdateScale() {\n\t\t//let zoom = this.viewer.camera.getCurrentTransform(performance.now()).z;\n\t\tlet zoom = this.viewer.camera.target.z;\n\t\tif (zoom == this.lastScaleZoom)\n\t\t\treturn;\n\t\tthis.lastScaleZoom = zoom;\n\t\tlet s = this.bestLength(this.width/2, this.width, this.pixelSize, zoom);\n\n\t\tlet margin = this.width - s.length;\n\t\tthis.line.setAttribute('x1', margin / 2);\n\t\tthis.line.setAttribute('x2', this.width - margin/2);\n\t\tthis.text.textContent = this.format(s.label);\n\t}\n\t\n\n    //find best length for scale from min -> max\n\t//zoom 2 means a pixel in image is now 2 pixel on screen, scale is\n\t/** @ignore */\n\tbestLength(min, max, pixelSize, zoom) {\n\t\tpixelSize /= zoom;\n\t\t//closest power of 10:\n\t\tlet label10 = Math.pow(10, Math.floor(Math.log(max * pixelSize) / Math.log(10)));\n\t\tlet length10 = label10 / pixelSize;\n\t\tif (length10 > min) return { length: length10, label: label10 };\n\n\t\tlet label20 = label10 * 2;\n\t\tlet length20 = length10 * 2;\n\t\tif (length20 > min) return { length: length20, label: label20 };\n\n\t\tlet label50 = label10 * 5;\n\t\tlet length50 = length10 * 5;\n\n\t\tif (length50 > min) return { length: length50, label: label50 };\n\t\treturn { length: 0, label: 0 }\n\t}\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2NhbGVCYXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsYUFBYSx3REFBcUIsVUFBVSxnQkFBZ0IsWUFBWSxLQUFLO0FBQzdFOztBQUVBLGNBQWMsd0RBQXFCLFdBQVcsOENBQThDOztBQUU1RixjQUFjLHdEQUFxQixXQUFXLDZFQUE2RTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBLCtCQUErQjtBQUMvQixXQUFXO0FBQ1g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL1NjYWxlQmFyLmpzPzU0YjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbCdcblxuLyogdW5pdHMgYXJlIHRob3NlIGluIHVzZSwgc2NhbGUgYW5kIHJ1bGVyIHdpbGwgcGljayB0aGUgYXBwcm9wcmlhdGUgdW5pdCBcbiAgIGFsbFVuaXRzIGNvbnRhaW5zIGFsbCBvZiB0aGUga25vd24gdW5pdHMgKi9cblxuY2xhc3MgVW5pdHMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51bml0cyA9IFtcImttXCIsIFwibVwiLCBcImNtXCIsIFwibW1cIl0sXG4gICAgICAgIHRoaXMuYWxsVW5pdHMgPSB7IFwibW1cIjogMSwgXCJjbVwiOiAxMCwgXCJtXCI6IDEwMDAsIFwia21cIjogMWU2LCBcImluXCI6IDI1NCwgXCJmdFwiOiAyNTQqMTIsICB9XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gMjtcbiAgICAgICAgaWYob3B0aW9ucylcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcyk7XG4gICAgfVxuXG4gICAgZm9ybWF0KGQsIHVuaXQpIHtcblx0XHRpZihkID09IDApXG5cdFx0XHRyZXR1cm4gJyc7XG4gICAgICAgIGlmKHVuaXQpXG4gICAgICAgICAgICByZXR1cm4gKGQvdGhpcy5hbGxVbml0c1t1bml0XSkudG9GaXhlZCh0aGlzLnByZWNpc2lvbikgKyB1bml0O1xuICAgICAgICBcbiAgICAgICAgbGV0IGJlc3RfdSA9IG51bGw7XG4gICAgICAgIGxldCBiZXN0X3BlbmFsdHkgPSAxMDA7XG4gICAgICAgIGZvcihsZXQgdSBvZiB0aGlzLnVuaXRzKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuYWxsVW5pdHNbdV07XG4gICAgICAgICAgICBsZXQgcGVuYWx0eSA9IGQgPD0gMCA/IDAgOiBNYXRoLmFicyhNYXRoLmxvZzEwKGQvc2l6ZSktMSk7XG4gICAgICAgICAgICBpZihwZW5hbHR5IDwgYmVzdF9wZW5hbHR5KSB7XG4gICAgICAgICAgICAgICAgYmVzdF91ID0gdTtcbiAgICAgICAgICAgICAgICBiZXN0X3BlbmFsdHkgPSBwZW5hbHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkLCBiZXN0X3UpO1xuICAgIH1cbn1cblxuY2xhc3MgU2NhbGVCYXIgZXh0ZW5kcyBVbml0cyB7XG4gICAgY29uc3RydWN0b3IocGl4ZWxTaXplLCB2aWV3ZXIsIG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKVxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgICBwaXhlbFNpemU6IHBpeGVsU2l6ZSxcbiAgICAgICAgICAgIHZpZXdlcjogdmlld2VyLFxuICAgICAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgICAgIGZvbnRTaXplOiAyNCxcblx0XHRcdHByZWNpc2lvbjogMFxuICAgICAgICB9LCBvcHRpb25zKTtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5zdmcgPSBVdGlsLmNyZWF0ZVNWR0VsZW1lbnQoJ3N2ZycsIHsgdmlld0JveDogYDAgMCAke3RoaXMud2lkdGh9IDMwYCB9KTtcblx0XHR0aGlzLnN2Zy5jbGFzc0xpc3QuYWRkKCdvcGVubGltZS1zY2FsZScpO1xuXG5cdFx0dGhpcy5saW5lID0gVXRpbC5jcmVhdGVTVkdFbGVtZW50KCdsaW5lJywgeyB4MTogNSwgeTE6IDI2LjUsIHgyOnRoaXMud2lkdGggLSA1LCB5MjogMjYuNSB9KTtcblxuXHRcdHRoaXMudGV4dCA9IFV0aWwuY3JlYXRlU1ZHRWxlbWVudCgndGV4dCcsIHsgeDogJzUwJScsIHk6ICcxNnB4JywgJ2RvbWluYW50LWJhc2lsaW5lJzogJ21pZGRsZScsICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnIH0pO1xuXHRcdHRoaXMudGV4dC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XG5cdFx0dGhpcy5zdmcuYXBwZW5kQ2hpbGQodGhpcy5saW5lKTtcblx0XHR0aGlzLnN2Zy5hcHBlbmRDaGlsZCh0aGlzLnRleHQpO1xuXHRcdHRoaXMudmlld2VyLmNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuXHRcdHRoaXMudmlld2VyLmFkZEV2ZW50KCdkcmF3JywgKCkgPT4geyB0aGlzLnVwZGF0ZVNjYWxlKCk7IH0pO1xuICAgIH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR1cGRhdGVTY2FsZSgpIHtcblx0XHQvL2xldCB6b29tID0gdGhpcy52aWV3ZXIuY2FtZXJhLmdldEN1cnJlbnRUcmFuc2Zvcm0ocGVyZm9ybWFuY2Uubm93KCkpLno7XG5cdFx0bGV0IHpvb20gPSB0aGlzLnZpZXdlci5jYW1lcmEudGFyZ2V0Lno7XG5cdFx0aWYgKHpvb20gPT0gdGhpcy5sYXN0U2NhbGVab29tKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMubGFzdFNjYWxlWm9vbSA9IHpvb207XG5cdFx0bGV0IHMgPSB0aGlzLmJlc3RMZW5ndGgodGhpcy53aWR0aC8yLCB0aGlzLndpZHRoLCB0aGlzLnBpeGVsU2l6ZSwgem9vbSk7XG5cblx0XHRsZXQgbWFyZ2luID0gdGhpcy53aWR0aCAtIHMubGVuZ3RoO1xuXHRcdHRoaXMubGluZS5zZXRBdHRyaWJ1dGUoJ3gxJywgbWFyZ2luIC8gMik7XG5cdFx0dGhpcy5saW5lLnNldEF0dHJpYnV0ZSgneDInLCB0aGlzLndpZHRoIC0gbWFyZ2luLzIpO1xuXHRcdHRoaXMudGV4dC50ZXh0Q29udGVudCA9IHRoaXMuZm9ybWF0KHMubGFiZWwpO1xuXHR9XG5cdFxuXG4gICAgLy9maW5kIGJlc3QgbGVuZ3RoIGZvciBzY2FsZSBmcm9tIG1pbiAtPiBtYXhcblx0Ly96b29tIDIgbWVhbnMgYSBwaXhlbCBpbiBpbWFnZSBpcyBub3cgMiBwaXhlbCBvbiBzY3JlZW4sIHNjYWxlIGlzXG5cdC8qKiBAaWdub3JlICovXG5cdGJlc3RMZW5ndGgobWluLCBtYXgsIHBpeGVsU2l6ZSwgem9vbSkge1xuXHRcdHBpeGVsU2l6ZSAvPSB6b29tO1xuXHRcdC8vY2xvc2VzdCBwb3dlciBvZiAxMDpcblx0XHRsZXQgbGFiZWwxMCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKG1heCAqIHBpeGVsU2l6ZSkgLyBNYXRoLmxvZygxMCkpKTtcblx0XHRsZXQgbGVuZ3RoMTAgPSBsYWJlbDEwIC8gcGl4ZWxTaXplO1xuXHRcdGlmIChsZW5ndGgxMCA+IG1pbikgcmV0dXJuIHsgbGVuZ3RoOiBsZW5ndGgxMCwgbGFiZWw6IGxhYmVsMTAgfTtcblxuXHRcdGxldCBsYWJlbDIwID0gbGFiZWwxMCAqIDI7XG5cdFx0bGV0IGxlbmd0aDIwID0gbGVuZ3RoMTAgKiAyO1xuXHRcdGlmIChsZW5ndGgyMCA+IG1pbikgcmV0dXJuIHsgbGVuZ3RoOiBsZW5ndGgyMCwgbGFiZWw6IGxhYmVsMjAgfTtcblxuXHRcdGxldCBsYWJlbDUwID0gbGFiZWwxMCAqIDU7XG5cdFx0bGV0IGxlbmd0aDUwID0gbGVuZ3RoMTAgKiA1O1xuXG5cdFx0aWYgKGxlbmd0aDUwID4gbWluKSByZXR1cm4geyBsZW5ndGg6IGxlbmd0aDUwLCBsYWJlbDogbGFiZWw1MCB9O1xuXHRcdHJldHVybiB7IGxlbmd0aDogMCwgbGFiZWw6IDAgfVxuXHR9XG59XG5cbmV4cG9ydCB7IFVuaXRzLCBTY2FsZUJhciB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/ScaleBar.js\n");

/***/ }),

/***/ "./src/Shader.js":
/*!***********************!*\
  !*** ./src/Shader.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shader\": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var _Signals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signals.js */ \"./src/Signals.js\");\n\n/**\n * A reference to a 2D texture.\n * @typedef {Object} Shader#Sampler\n * @property {number} id A sampler unique identifier.\n * @property {string} name The sampler name (the texture reference name in the shader program).\n */\n\n/**\n * The `Shader` class allows shader programs to be linked and used.\n * This class supports shader programs written in the OpenGL/ES Shading Language (GLSL/ES) with 2.0 amd 3.0 specifications.\n * \n * The `Shader` class keeps the programmer away from the details of compiling and linking vertex and fragment shaders.\n * The following example creates a fragment shader program using the supplied source code. Once compiled and linked, \n * the shader program is activated in the current WebGLContext.\n * ```\n * const shader = new OpenLIME.Shader({\n *      'label': 'Rgb',\n *      'samplers': [{ id: 0, name: 'kd' }]\n * });\n * // The fragment shader script\n * shader.fragShaderSrc = function (gl) {\n *      let gl2 = !(gl instanceof WebGLRenderingContext);\n *      let str = `${gl2 ? '#version 300 es' : ''}\n *      precision highp float;\n *      precision highp int;\n *\n *      uniform sampler2D kd;\n *      uniform float u_colorFactor;\n *      ...\n *\n *      return str;\n * };\n * // Declares a uniform.\n * shader.uniforms = {\n *      u_colorFactor: { type: 'float', needsUpdate: true, size: 1, value: 0.0 },\n * };\n * // Adds the shader to the Layer and set it as the current one.\n * this.shaders['bw'] = shader;\n * this.setShader('bw');\n * ```\n */\nclass Shader {\n /** \n * Instantiates a Shader class. An object literal with Shader `options` can be specified.\n * @param {Object} [options] An object literal describing the shader content.\n * @param {Array<Shader#Sampler>} options.samplers An array of pointers to 2D textures. \n * @param {Array<string>} options.modes An optional array of labels that identify different shader behaviors.\n */\n  constructor(options) {\n\t\tObject.assign(this, {\n\t\t\tversion: 100,   //check for webglversion. \n\t\t\tsamplers: [],\n\t\t\tuniforms: {},\n\t\t\tlabel: null, \n\t\t\tprogram: null,      //webgl program\n\t\t\tmodes: [],\n\t\t\tmode: null, // The current mode\n\t\t\tneedsUpdate: true,\n\t\t});\n\t\t(0,_Signals_js__WEBPACK_IMPORTED_MODULE_0__.addSignals)(Shader, 'update');\n\t\tObject.assign(this, options);\n\t}\n\t/**\n\t * Sets the current mode of the shader\n\t * @param {string} mode The mode identifier\n\t */\n\tsetMode(mode) {\n\t\tif (this.modes.indexOf(mode) == -1)\n\t\t\tthrow Error(\"Unknown mode: \" + mode);\n\t\tthis.mode = mode;\n\t\tthis.needsUpdate = true;\n\t}\n\n\t/** @ignore */\n\trestoreWebGL(gl) {\n\t\tthis.createProgram(gl);\n\t}\n\n\t/**\n\t * Sets the value of a uniform variable.\n\t * @param {string} name The name of the uniform variable.\n\t * @param {*} value The value to assign.\n\t */\n\tsetUniform(name, value) {\n\t\t/**\n\t\t* The event is fired when a uniform shader variable is changed.\n\t\t* @event Camera#update\n\t\t*/\n\t\tlet u = this.uniforms[name];\n\t\tif(!u)\n\t\t\tthrow new Error(`Unknown '${name}'. It is not a registered uniform.`);\n\t\tif ((typeof (value) == \"number\" || typeof (value) == \"boolean\") && u.value == value) \n\t\t\treturn;\n\t\tif(Array.isArray(value) && Array.isArray(u.value) && value.length == u.value.length) {\n\t\t\tlet equal = true;\n\t\t\tfor(let i = 0; i < value.length; i++)\n\t\t\t\tif(value[i] != u.value[i]) {\n\t\t\t\t\tequal = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(equal)\n\t\t\t\treturn;\n\t\t}\n\n\t\tu.value = value;\n\t\tu.needsUpdate = true;\n\t\tthis.emit('update');\n\t}\n\n\t/** @ignore */\n\tcreateProgram(gl) {\n\n\t\tlet vert = gl.createShader(gl.VERTEX_SHADER);\n\t\tgl.shaderSource(vert, this.vertShaderSrc(gl));\n\n\t\tgl.compileShader(vert);\n\t\tlet compiled = gl.getShaderParameter(vert, gl.COMPILE_STATUS);\n\t\tif(!compiled) {\n\t\t\tconsole.log(gl.getShaderInfoLog(vert));\n\t\t\tthrow Error(\"Failed vertex shader compilation: see console log and ask for support.\");\n\t\t}\n\n\t\tlet frag = gl.createShader(gl.FRAGMENT_SHADER);\n\t\tgl.shaderSource(frag, this.fragShaderSrc(gl));\n\t\tgl.compileShader(frag);\n\n\t\tif(this.program)\n\t\t\tgl.deleteProgram(this.program);\n\n\t\tlet program = gl.createProgram();\n\n\t\tgl.getShaderParameter(frag, gl.COMPILE_STATUS);\n\t\tcompiled = gl.getShaderParameter(frag, gl.COMPILE_STATUS);\n\t\tif(!compiled) {\n\t\t\tconsole.log(this.fragShaderSrc())\n\t\t\tconsole.log(gl.getShaderInfoLog(frag));\n\t\t\tthrow Error(\"Failed fragment shader compilation: see console log and ask for support.\");\n\t\t}\n\n\t\tgl.attachShader(program, vert);\n\t\tgl.attachShader(program, frag);\n\t\tgl.linkProgram(program);\n\n\t\tif ( !gl.getProgramParameter( program, gl.LINK_STATUS) ) {\n\t\t\tvar info = gl.getProgramInfoLog(program);\n\t\t\tthrow new Error('Could not compile WebGL program. \\n\\n' + info);\n\t\t}\n\n\t\t//sampler units;\n\t\tfor(let sampler of this.samplers)\n\t\t\tsampler.location = gl.getUniformLocation(program, sampler.name);\n\n\t\tthis.coordattrib = gl.getAttribLocation(program, \"a_position\");\n\t\tgl.vertexAttribPointer(this.coordattrib, 3, gl.FLOAT, false, 0, 0);\n\t\tgl.enableVertexAttribArray(this.coordattrib);\n\n\t\tthis.texattrib = gl.getAttribLocation(program, \"a_texcoord\");\n\t\tgl.vertexAttribPointer(this.texattrib, 2, gl.FLOAT, false, 0, 0);\n\t\tgl.enableVertexAttribArray(this.texattrib);\n\n\t\tthis.matrixlocation = gl.getUniformLocation(program, \"u_matrix\");\n\n\t\tthis.program = program;\n\t\tthis.needsUpdate = false;\n\n\t\tfor(let uniform of Object.values(this.uniforms)) {\n\t\t\tuniform.location = null;\n\t\t\tuniform.needsUpdate = true;\n\t\t}\n\t}\n\n\t/** @ignore */\n\tupdateUniforms(gl, program) {\n\t\tlet now = performance.now();\n\t\tfor(const [name, uniform] of Object.entries(this.uniforms)) {\n\t\t\tif(!uniform.location)\n\t\t\t\tuniform.location = gl.getUniformLocation(program, name);\n\n\t\t\tif(!uniform.location)  //uniform not used in program\n\t\t\t\tcontinue; \n\n\t\t\tif(uniform.needsUpdate) {\n\t\t\t\tlet value = uniform.value;\n\t\t\t\tswitch(uniform.type) {\n\t\t\t\t\tcase 'vec4':  gl.uniform4fv(uniform.location, value); break;\n\t\t\t\t\tcase 'vec3':  gl.uniform3fv(uniform.location, value); break;\n\t\t\t\t\tcase 'vec2':  gl.uniform2fv(uniform.location, value); break;\n\t\t\t\t\tcase 'float': gl.uniform1f(uniform.location, value); break;\n\t\t\t\t\tcase 'int':   gl.uniform1i (uniform.location, value); break;\n\t\t\t\t\tcase 'bool':  gl.uniform1i (uniform.location, value); break;\n\t\t\t\t\tcase 'mat3':  gl.uniformMatrix3fv (uniform.location, false, value); break;\n\t\t\t\t\tcase 'mat4':  gl.uniformMatrix4fv (uniform.location, false, value); break;\n\t\t\t\t\tdefault: throw Error('Unknown uniform type: ' + u.type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the vertex shader script. By default it only applies the view matrix and passes the texture coordinates to the fragment shader.\n\t * @param {*} gl Thegl context.\n\t * @returns {string} The vertex shader script.\n\t */\n\tvertShaderSrc(gl) {\n\t\tlet gl2 = !(gl instanceof WebGLRenderingContext);\n\t\treturn `${gl2? '#version 300 es':''}\n\nprecision highp float; \nprecision highp int; \n\nuniform mat4 u_matrix;\n${gl2? 'in' : 'attribute'} vec4 a_position;\n${gl2? 'in' : 'attribute'} vec2 a_texcoord;\n\n${gl2? 'out' : 'varying'} vec2 v_texcoord;\n\nvoid main() {\n\tgl_Position = u_matrix * a_position;\n\tv_texcoord = a_texcoord;\n}`;\n\t}\n\n\t/**\n\t * Gets the fragment shader script. This is a virtual function and MUST be redefined in derived classes.\n\t * @param {*} gl Thegl context.\n\t * @returns {string} The vertex shader script.\n\t */\n\t fragShaderSrc(gl) {\n\t\tthrow 'Unimplemented!'\n\t}\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2hhZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUF1RDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLHVEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwwREFBMEQ7QUFDMUQsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCx5RUFBeUU7QUFDekUseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLHlCQUF5QjtBQUMzQixFQUFFLHlCQUF5Qjs7QUFFM0IsRUFBRSx3QkFBd0I7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxHQUFHO0FBQ2YsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdpQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL1NoYWRlci5qcz80Zjg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZFNpZ25hbHMgfSBmcm9tICcuL1NpZ25hbHMuanMnXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgMkQgdGV4dHVyZS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNoYWRlciNTYW1wbGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgQSBzYW1wbGVyIHVuaXF1ZSBpZGVudGlmaWVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIHNhbXBsZXIgbmFtZSAodGhlIHRleHR1cmUgcmVmZXJlbmNlIG5hbWUgaW4gdGhlIHNoYWRlciBwcm9ncmFtKS5cbiAqL1xuXG4vKipcbiAqIFRoZSBgU2hhZGVyYCBjbGFzcyBhbGxvd3Mgc2hhZGVyIHByb2dyYW1zIHRvIGJlIGxpbmtlZCBhbmQgdXNlZC5cbiAqIFRoaXMgY2xhc3Mgc3VwcG9ydHMgc2hhZGVyIHByb2dyYW1zIHdyaXR0ZW4gaW4gdGhlIE9wZW5HTC9FUyBTaGFkaW5nIExhbmd1YWdlIChHTFNML0VTKSB3aXRoIDIuMCBhbWQgMy4wIHNwZWNpZmljYXRpb25zLlxuICogXG4gKiBUaGUgYFNoYWRlcmAgY2xhc3Mga2VlcHMgdGhlIHByb2dyYW1tZXIgYXdheSBmcm9tIHRoZSBkZXRhaWxzIG9mIGNvbXBpbGluZyBhbmQgbGlua2luZyB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGZyYWdtZW50IHNoYWRlciBwcm9ncmFtIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgY29kZS4gT25jZSBjb21waWxlZCBhbmQgbGlua2VkLCBcbiAqIHRoZSBzaGFkZXIgcHJvZ3JhbSBpcyBhY3RpdmF0ZWQgaW4gdGhlIGN1cnJlbnQgV2ViR0xDb250ZXh0LlxuICogYGBgXG4gKiBjb25zdCBzaGFkZXIgPSBuZXcgT3BlbkxJTUUuU2hhZGVyKHtcbiAqICAgICAgJ2xhYmVsJzogJ1JnYicsXG4gKiAgICAgICdzYW1wbGVycyc6IFt7IGlkOiAwLCBuYW1lOiAna2QnIH1dXG4gKiB9KTtcbiAqIC8vIFRoZSBmcmFnbWVudCBzaGFkZXIgc2NyaXB0XG4gKiBzaGFkZXIuZnJhZ1NoYWRlclNyYyA9IGZ1bmN0aW9uIChnbCkge1xuICogICAgICBsZXQgZ2wyID0gIShnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCk7XG4gKiAgICAgIGxldCBzdHIgPSBgJHtnbDIgPyAnI3ZlcnNpb24gMzAwIGVzJyA6ICcnfVxuICogICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gKiAgICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XG4gKlxuICogICAgICB1bmlmb3JtIHNhbXBsZXIyRCBrZDtcbiAqICAgICAgdW5pZm9ybSBmbG9hdCB1X2NvbG9yRmFjdG9yO1xuICogICAgICAuLi5cbiAqXG4gKiAgICAgIHJldHVybiBzdHI7XG4gKiB9O1xuICogLy8gRGVjbGFyZXMgYSB1bmlmb3JtLlxuICogc2hhZGVyLnVuaWZvcm1zID0ge1xuICogICAgICB1X2NvbG9yRmFjdG9yOiB7IHR5cGU6ICdmbG9hdCcsIG5lZWRzVXBkYXRlOiB0cnVlLCBzaXplOiAxLCB2YWx1ZTogMC4wIH0sXG4gKiB9O1xuICogLy8gQWRkcyB0aGUgc2hhZGVyIHRvIHRoZSBMYXllciBhbmQgc2V0IGl0IGFzIHRoZSBjdXJyZW50IG9uZS5cbiAqIHRoaXMuc2hhZGVyc1snYncnXSA9IHNoYWRlcjtcbiAqIHRoaXMuc2V0U2hhZGVyKCdidycpO1xuICogYGBgXG4gKi9cbmNsYXNzIFNoYWRlciB7XG4gLyoqIFxuICogSW5zdGFudGlhdGVzIGEgU2hhZGVyIGNsYXNzLiBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIFNoYWRlciBgb3B0aW9uc2AgY2FuIGJlIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGxpdGVyYWwgZGVzY3JpYmluZyB0aGUgc2hhZGVyIGNvbnRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PFNoYWRlciNTYW1wbGVyPn0gb3B0aW9ucy5zYW1wbGVycyBBbiBhcnJheSBvZiBwb2ludGVycyB0byAyRCB0ZXh0dXJlcy4gXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IG9wdGlvbnMubW9kZXMgQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGFiZWxzIHRoYXQgaWRlbnRpZnkgZGlmZmVyZW50IHNoYWRlciBiZWhhdmlvcnMuXG4gKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywge1xuXHRcdFx0dmVyc2lvbjogMTAwLCAgIC8vY2hlY2sgZm9yIHdlYmdsdmVyc2lvbi4gXG5cdFx0XHRzYW1wbGVyczogW10sXG5cdFx0XHR1bmlmb3Jtczoge30sXG5cdFx0XHRsYWJlbDogbnVsbCwgXG5cdFx0XHRwcm9ncmFtOiBudWxsLCAgICAgIC8vd2ViZ2wgcHJvZ3JhbVxuXHRcdFx0bW9kZXM6IFtdLFxuXHRcdFx0bW9kZTogbnVsbCwgLy8gVGhlIGN1cnJlbnQgbW9kZVxuXHRcdFx0bmVlZHNVcGRhdGU6IHRydWUsXG5cdFx0fSk7XG5cdFx0YWRkU2lnbmFscyhTaGFkZXIsICd1cGRhdGUnKTtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIHNoYWRlclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZSBUaGUgbW9kZSBpZGVudGlmaWVyXG5cdCAqL1xuXHRzZXRNb2RlKG1vZGUpIHtcblx0XHRpZiAodGhpcy5tb2Rlcy5pbmRleE9mKG1vZGUpID09IC0xKVxuXHRcdFx0dGhyb3cgRXJyb3IoXCJVbmtub3duIG1vZGU6IFwiICsgbW9kZSk7XG5cdFx0dGhpcy5tb2RlID0gbW9kZTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHJlc3RvcmVXZWJHTChnbCkge1xuXHRcdHRoaXMuY3JlYXRlUHJvZ3JhbShnbCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgYSB1bmlmb3JtIHZhcmlhYmxlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdW5pZm9ybSB2YXJpYWJsZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuXHQgKi9cblx0c2V0VW5pZm9ybShuYW1lLCB2YWx1ZSkge1xuXHRcdC8qKlxuXHRcdCogVGhlIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSB1bmlmb3JtIHNoYWRlciB2YXJpYWJsZSBpcyBjaGFuZ2VkLlxuXHRcdCogQGV2ZW50IENhbWVyYSN1cGRhdGVcblx0XHQqL1xuXHRcdGxldCB1ID0gdGhpcy51bmlmb3Jtc1tuYW1lXTtcblx0XHRpZighdSlcblx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5rbm93biAnJHtuYW1lfScuIEl0IGlzIG5vdCBhIHJlZ2lzdGVyZWQgdW5pZm9ybS5gKTtcblx0XHRpZiAoKHR5cGVvZiAodmFsdWUpID09IFwibnVtYmVyXCIgfHwgdHlwZW9mICh2YWx1ZSkgPT0gXCJib29sZWFuXCIpICYmIHUudmFsdWUgPT0gdmFsdWUpIFxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkodS52YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09IHUudmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRsZXQgZXF1YWwgPSB0cnVlO1xuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRpZih2YWx1ZVtpXSAhPSB1LnZhbHVlW2ldKSB7XG5cdFx0XHRcdFx0ZXF1YWwgPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0aWYoZXF1YWwpXG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR1LnZhbHVlID0gdmFsdWU7XG5cdFx0dS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5lbWl0KCd1cGRhdGUnKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGNyZWF0ZVByb2dyYW0oZ2wpIHtcblxuXHRcdGxldCB2ZXJ0ID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuXHRcdGdsLnNoYWRlclNvdXJjZSh2ZXJ0LCB0aGlzLnZlcnRTaGFkZXJTcmMoZ2wpKTtcblxuXHRcdGdsLmNvbXBpbGVTaGFkZXIodmVydCk7XG5cdFx0bGV0IGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnQsIGdsLkNPTVBJTEVfU1RBVFVTKTtcblx0XHRpZighY29tcGlsZWQpIHtcblx0XHRcdGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2codmVydCkpO1xuXHRcdFx0dGhyb3cgRXJyb3IoXCJGYWlsZWQgdmVydGV4IHNoYWRlciBjb21waWxhdGlvbjogc2VlIGNvbnNvbGUgbG9nIGFuZCBhc2sgZm9yIHN1cHBvcnQuXCIpO1xuXHRcdH1cblxuXHRcdGxldCBmcmFnID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG5cdFx0Z2wuc2hhZGVyU291cmNlKGZyYWcsIHRoaXMuZnJhZ1NoYWRlclNyYyhnbCkpO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIoZnJhZyk7XG5cblx0XHRpZih0aGlzLnByb2dyYW0pXG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cblx0XHRsZXQgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuXHRcdGdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnLCBnbC5DT01QSUxFX1NUQVRVUyk7XG5cdFx0Y29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZywgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXHRcdGlmKCFjb21waWxlZCkge1xuXHRcdFx0Y29uc29sZS5sb2codGhpcy5mcmFnU2hhZGVyU3JjKCkpXG5cdFx0XHRjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWcpKTtcblx0XHRcdHRocm93IEVycm9yKFwiRmFpbGVkIGZyYWdtZW50IHNoYWRlciBjb21waWxhdGlvbjogc2VlIGNvbnNvbGUgbG9nIGFuZCBhc2sgZm9yIHN1cHBvcnQuXCIpO1xuXHRcdH1cblxuXHRcdGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0KTtcblx0XHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZyk7XG5cdFx0Z2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRpZiAoICFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykgKSB7XG5cdFx0XHR2YXIgaW5mbyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcGlsZSBXZWJHTCBwcm9ncmFtLiBcXG5cXG4nICsgaW5mbyk7XG5cdFx0fVxuXG5cdFx0Ly9zYW1wbGVyIHVuaXRzO1xuXHRcdGZvcihsZXQgc2FtcGxlciBvZiB0aGlzLnNhbXBsZXJzKVxuXHRcdFx0c2FtcGxlci5sb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBzYW1wbGVyLm5hbWUpO1xuXG5cdFx0dGhpcy5jb29yZGF0dHJpYiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuY29vcmRhdHRyaWIsIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5jb29yZGF0dHJpYik7XG5cblx0XHR0aGlzLnRleGF0dHJpYiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV90ZXhjb29yZFwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMudGV4YXR0cmliLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMudGV4YXR0cmliKTtcblxuXHRcdHRoaXMubWF0cml4bG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X21hdHJpeFwiKTtcblxuXHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0Zm9yKGxldCB1bmlmb3JtIG9mIE9iamVjdC52YWx1ZXModGhpcy51bmlmb3JtcykpIHtcblx0XHRcdHVuaWZvcm0ubG9jYXRpb24gPSBudWxsO1xuXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0dXBkYXRlVW5pZm9ybXMoZ2wsIHByb2dyYW0pIHtcblx0XHRsZXQgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0Zm9yKGNvbnN0IFtuYW1lLCB1bmlmb3JtXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnVuaWZvcm1zKSkge1xuXHRcdFx0aWYoIXVuaWZvcm0ubG9jYXRpb24pXG5cdFx0XHRcdHVuaWZvcm0ubG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG5cblx0XHRcdGlmKCF1bmlmb3JtLmxvY2F0aW9uKSAgLy91bmlmb3JtIG5vdCB1c2VkIGluIHByb2dyYW1cblx0XHRcdFx0Y29udGludWU7IFxuXG5cdFx0XHRpZih1bmlmb3JtLm5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XG5cdFx0XHRcdHN3aXRjaCh1bmlmb3JtLnR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICd2ZWM0JzogIGdsLnVuaWZvcm00ZnYodW5pZm9ybS5sb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICd2ZWMzJzogIGdsLnVuaWZvcm0zZnYodW5pZm9ybS5sb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICd2ZWMyJzogIGdsLnVuaWZvcm0yZnYodW5pZm9ybS5sb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdmbG9hdCc6IGdsLnVuaWZvcm0xZih1bmlmb3JtLmxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ludCc6ICAgZ2wudW5pZm9ybTFpICh1bmlmb3JtLmxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2Jvb2wnOiAgZ2wudW5pZm9ybTFpICh1bmlmb3JtLmxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hdDMnOiAgZ2wudW5pZm9ybU1hdHJpeDNmdiAodW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWF0NCc6ICBnbC51bmlmb3JtTWF0cml4NGZ2ICh1bmlmb3JtLmxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpOyBicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBFcnJvcignVW5rbm93biB1bmlmb3JtIHR5cGU6ICcgKyB1LnR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZlcnRleCBzaGFkZXIgc2NyaXB0LiBCeSBkZWZhdWx0IGl0IG9ubHkgYXBwbGllcyB0aGUgdmlldyBtYXRyaXggYW5kIHBhc3NlcyB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyB0byB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuXHQgKiBAcGFyYW0geyp9IGdsIFRoZWdsIGNvbnRleHQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2ZXJ0ZXggc2hhZGVyIHNjcmlwdC5cblx0ICovXG5cdHZlcnRTaGFkZXJTcmMoZ2wpIHtcblx0XHRsZXQgZ2wyID0gIShnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCk7XG5cdFx0cmV0dXJuIGAke2dsMj8gJyN2ZXJzaW9uIDMwMCBlcyc6Jyd9XG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDsgXG5wcmVjaXNpb24gaGlnaHAgaW50OyBcblxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xuJHtnbDI/ICdpbicgOiAnYXR0cmlidXRlJ30gdmVjNCBhX3Bvc2l0aW9uO1xuJHtnbDI/ICdpbicgOiAnYXR0cmlidXRlJ30gdmVjMiBhX3RleGNvb3JkO1xuXG4ke2dsMj8gJ291dCcgOiAndmFyeWluZyd9IHZlYzIgdl90ZXhjb29yZDtcblxudm9pZCBtYWluKCkge1xuXHRnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogYV9wb3NpdGlvbjtcblx0dl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7XG59YDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBmcmFnbWVudCBzaGFkZXIgc2NyaXB0LiBUaGlzIGlzIGEgdmlydHVhbCBmdW5jdGlvbiBhbmQgTVVTVCBiZSByZWRlZmluZWQgaW4gZGVyaXZlZCBjbGFzc2VzLlxuXHQgKiBAcGFyYW0geyp9IGdsIFRoZWdsIGNvbnRleHQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2ZXJ0ZXggc2hhZGVyIHNjcmlwdC5cblx0ICovXG5cdCBmcmFnU2hhZGVyU3JjKGdsKSB7XG5cdFx0dGhyb3cgJ1VuaW1wbGVtZW50ZWQhJ1xuXHR9XG59XG5cblxuZXhwb3J0IHsgU2hhZGVyIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Shader.js\n");

/***/ }),

/***/ "./src/ShaderCombiner.js":
/*!*******************************!*\
  !*** ./src/ShaderCombiner.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderCombiner\": () => (/* binding */ ShaderCombiner)\n/* harmony export */ });\n/* harmony import */ var _Shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader.js */ \"./src/Shader.js\");\n\n\n/**\n * The **ShaderCombiner** class specifies a shader that computes an output texture as a combination of two input textures.\n * It defines four modes (shader behaviors): \n * * 'first' assigns the first texture as output (draws the first texture). The color of each fragment is cout=c1\n * * 'second' assigns the second texture as output (draws the second texture). The color of each fragment is cout=c2\n * * 'mean' calculates the average color of the two textures. The color of each fragment is cout=(c1+c2)/2.0\n * * 'diff' calculates the difference between the color of the textures. Color of each fragment is cout=c2.rgb-c1.rgb\n * \n * Extends {@link Shader}.\n */\nclass ShaderCombiner extends _Shader_js__WEBPACK_IMPORTED_MODULE_0__.Shader {\n\t/**\n\t * Instantiates a **ShaderCombiner** class.\n\t * An object literal with ShaderCombiner `options` can be specified.\n\t * @param {Object} [options] An object literal with options that inherits from {@link Shader}.\n\t */\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\tthis.mode = 'mean', //Lighten Darken Contrast Inversion HSV components LCh components\n\t\tthis.samplers = [\n\t\t\t{ id:0, name:'source1', type:'vec3' },\n\t\t\t{ id:1, name:'source2', type:'vec3' }\n\t\t];\n\n\t\tthis.modes = ['first','second','mean','diff'];\n\t\tthis.operations = {\n\t\t\t'first': 'color = c1;',\n\t\t\t'second': 'color = c2;',\n\t\t\t'mean': 'color = (c1 + c2)/2.0;',\n\t\t\t'diff': 'color = vec4(c2.rgb - c1.rgb, c1.a);'\n\t\t};\n\t}\n\n\t/** @ignore */\n\tfragShaderSrc(gl) {\n\t\tlet gl2 = !(gl instanceof WebGLRenderingContext);\n\t\tlet operation = this.operations[this.mode];\n\t\treturn `${gl2? '#version 300 es' : ''}\n\nprecision highp float; \nprecision highp int; \n\n${gl2? 'in' : 'varying'} vec2 v_texcoord;\n\nuniform sampler2D source1;\nuniform sampler2D source2;\n\n${gl2? 'out' : ''} vec4 color;\n\nvoid main() {\n\tvec4 c1 = texture(source1, v_texcoord);\n\tvec4 c2 = texture(source2, v_texcoord);\n\t${operation};\n\t${gl2?'':'gl_FragColor = color;'}\n}\n`;\n\t}\n\n\t/** @ignore */\n\tvertShaderSrc(gl) {\n\t\tlet gl2 = !(gl instanceof WebGLRenderingContext);\n\t\treturn `${gl2? '#version 300 es':''}\n\nprecision highp float; \nprecision highp int; \n\n${gl2? 'in' : 'attribute'} vec4 a_position;\n${gl2? 'in' : 'attribute'} vec2 a_texcoord;\n\n${gl2? 'out' : 'varying'} vec2 v_texcoord;\n\nvoid main() {\n\tgl_Position = a_position;\n\tv_texcoord = a_texcoord;\n}`;\n\t}\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2hhZGVyQ29tYmluZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQSw2QkFBNkIsOENBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLDZEQUE2RCxhQUFhO0FBQzlGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxtQ0FBbUM7QUFDeEMsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLGtDQUFrQztBQUNsQyxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQSxFQUFFLHVCQUF1Qjs7QUFFekI7QUFDQTs7QUFFQSxFQUFFLGlCQUFpQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUcsNkJBQTZCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7O0FBRUEsRUFBRSx5QkFBeUI7QUFDM0IsRUFBRSx5QkFBeUI7O0FBRTNCLEVBQUUsd0JBQXdCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9TaGFkZXJDb21iaW5lci5qcz9kZDEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4vU2hhZGVyLmpzJ1xuXG4vKipcbiAqIFRoZSAqKlNoYWRlckNvbWJpbmVyKiogY2xhc3Mgc3BlY2lmaWVzIGEgc2hhZGVyIHRoYXQgY29tcHV0ZXMgYW4gb3V0cHV0IHRleHR1cmUgYXMgYSBjb21iaW5hdGlvbiBvZiB0d28gaW5wdXQgdGV4dHVyZXMuXG4gKiBJdCBkZWZpbmVzIGZvdXIgbW9kZXMgKHNoYWRlciBiZWhhdmlvcnMpOiBcbiAqICogJ2ZpcnN0JyBhc3NpZ25zIHRoZSBmaXJzdCB0ZXh0dXJlIGFzIG91dHB1dCAoZHJhd3MgdGhlIGZpcnN0IHRleHR1cmUpLiBUaGUgY29sb3Igb2YgZWFjaCBmcmFnbWVudCBpcyBjb3V0PWMxXG4gKiAqICdzZWNvbmQnIGFzc2lnbnMgdGhlIHNlY29uZCB0ZXh0dXJlIGFzIG91dHB1dCAoZHJhd3MgdGhlIHNlY29uZCB0ZXh0dXJlKS4gVGhlIGNvbG9yIG9mIGVhY2ggZnJhZ21lbnQgaXMgY291dD1jMlxuICogKiAnbWVhbicgY2FsY3VsYXRlcyB0aGUgYXZlcmFnZSBjb2xvciBvZiB0aGUgdHdvIHRleHR1cmVzLiBUaGUgY29sb3Igb2YgZWFjaCBmcmFnbWVudCBpcyBjb3V0PShjMStjMikvMi4wXG4gKiAqICdkaWZmJyBjYWxjdWxhdGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGNvbG9yIG9mIHRoZSB0ZXh0dXJlcy4gQ29sb3Igb2YgZWFjaCBmcmFnbWVudCBpcyBjb3V0PWMyLnJnYi1jMS5yZ2JcbiAqIFxuICogRXh0ZW5kcyB7QGxpbmsgU2hhZGVyfS5cbiAqL1xuY2xhc3MgU2hhZGVyQ29tYmluZXIgZXh0ZW5kcyBTaGFkZXIge1xuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgKipTaGFkZXJDb21iaW5lcioqIGNsYXNzLlxuXHQgKiBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIFNoYWRlckNvbWJpbmVyIGBvcHRpb25zYCBjYW4gYmUgc3BlY2lmaWVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggb3B0aW9ucyB0aGF0IGluaGVyaXRzIGZyb20ge0BsaW5rIFNoYWRlcn0uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cblx0XHR0aGlzLm1vZGUgPSAnbWVhbicsIC8vTGlnaHRlbiBEYXJrZW4gQ29udHJhc3QgSW52ZXJzaW9uIEhTViBjb21wb25lbnRzIExDaCBjb21wb25lbnRzXG5cdFx0dGhpcy5zYW1wbGVycyA9IFtcblx0XHRcdHsgaWQ6MCwgbmFtZTonc291cmNlMScsIHR5cGU6J3ZlYzMnIH0sXG5cdFx0XHR7IGlkOjEsIG5hbWU6J3NvdXJjZTInLCB0eXBlOid2ZWMzJyB9XG5cdFx0XTtcblxuXHRcdHRoaXMubW9kZXMgPSBbJ2ZpcnN0Jywnc2Vjb25kJywnbWVhbicsJ2RpZmYnXTtcblx0XHR0aGlzLm9wZXJhdGlvbnMgPSB7XG5cdFx0XHQnZmlyc3QnOiAnY29sb3IgPSBjMTsnLFxuXHRcdFx0J3NlY29uZCc6ICdjb2xvciA9IGMyOycsXG5cdFx0XHQnbWVhbic6ICdjb2xvciA9IChjMSArIGMyKS8yLjA7Jyxcblx0XHRcdCdkaWZmJzogJ2NvbG9yID0gdmVjNChjMi5yZ2IgLSBjMS5yZ2IsIGMxLmEpOydcblx0XHR9O1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0ZnJhZ1NoYWRlclNyYyhnbCkge1xuXHRcdGxldCBnbDIgPSAhKGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KTtcblx0XHRsZXQgb3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb25zW3RoaXMubW9kZV07XG5cdFx0cmV0dXJuIGAke2dsMj8gJyN2ZXJzaW9uIDMwMCBlcycgOiAnJ31cblxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0OyBcbnByZWNpc2lvbiBoaWdocCBpbnQ7IFxuXG4ke2dsMj8gJ2luJyA6ICd2YXJ5aW5nJ30gdmVjMiB2X3RleGNvb3JkO1xuXG51bmlmb3JtIHNhbXBsZXIyRCBzb3VyY2UxO1xudW5pZm9ybSBzYW1wbGVyMkQgc291cmNlMjtcblxuJHtnbDI/ICdvdXQnIDogJyd9IHZlYzQgY29sb3I7XG5cbnZvaWQgbWFpbigpIHtcblx0dmVjNCBjMSA9IHRleHR1cmUoc291cmNlMSwgdl90ZXhjb29yZCk7XG5cdHZlYzQgYzIgPSB0ZXh0dXJlKHNvdXJjZTIsIHZfdGV4Y29vcmQpO1xuXHQke29wZXJhdGlvbn07XG5cdCR7Z2wyPycnOidnbF9GcmFnQ29sb3IgPSBjb2xvcjsnfVxufVxuYDtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHZlcnRTaGFkZXJTcmMoZ2wpIHtcblx0XHRsZXQgZ2wyID0gIShnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCk7XG5cdFx0cmV0dXJuIGAke2dsMj8gJyN2ZXJzaW9uIDMwMCBlcyc6Jyd9XG5cbnByZWNpc2lvbiBoaWdocCBmbG9hdDsgXG5wcmVjaXNpb24gaGlnaHAgaW50OyBcblxuJHtnbDI/ICdpbicgOiAnYXR0cmlidXRlJ30gdmVjNCBhX3Bvc2l0aW9uO1xuJHtnbDI/ICdpbicgOiAnYXR0cmlidXRlJ30gdmVjMiBhX3RleGNvb3JkO1xuXG4ke2dsMj8gJ291dCcgOiAndmFyeWluZyd9IHZlYzIgdl90ZXhjb29yZDtcblxudm9pZCBtYWluKCkge1xuXHRnbF9Qb3NpdGlvbiA9IGFfcG9zaXRpb247XG5cdHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xufWA7XG5cdH1cbn1cblxuZXhwb3J0IHsgU2hhZGVyQ29tYmluZXIgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/ShaderCombiner.js\n");

/***/ }),

/***/ "./src/ShaderDstretch.js":
/*!*******************************!*\
  !*** ./src/ShaderDstretch.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderDstretch\": () => (/* binding */ ShaderDstretch)\n/* harmony export */ });\n/* harmony import */ var _Shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader */ \"./src/Shader.js\");\n\n\nclass ShaderDstretch extends _Shader__WEBPACK_IMPORTED_MODULE_0__.Shader {\n    constructor(options) {\n\t\tsuper(options);\n\t}\n\n\tinit(json) {\n        this.rotationMatrix = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];\n\n        // Store samples, compute min / max on the fly\n        this.samples = json[\"samples\"];\n        this.samplers.push({ id:0, name:'image', type:'vec3' });\n\n        this.setMinMax();\n\t}\n\n    setMinMax() {\n        if (this.samples == undefined)\n            return;\n            \n        let min = [Infinity, Infinity, Infinity], max = [-Infinity, -Infinity, -Infinity];\n        for (let i=0; i<this.samples.length; i++) {\n            let transformedSample = this.transformSample(this.matToArray(this.transpose(this.rotationMatrix)),\n             this.transformSample(\n                this.matToArray(this.rotationMatrix), \n                        this.samples[i].concat(1)));\n\n            for (let j=0; j<3; j++) {\n                if (transformedSample[j] < min[j])\n                    min[j] = transformedSample[j];\n                if (transformedSample[j] > max[j])\n                    max[j] = transformedSample[j];\n            }\n        }\n\n        this.min = min;\n        this.max = max;\n\n        this.uniforms = {\n            rotation: { type: 'mat4', needsUpdate: true, size: 16, value: this.matToArray(this.rotationMatrix)},\n\t\t\tmin: {type: 'vec3', needsUpdate:true, size: 3, value: this.min},\n            max: {type: 'vec3', needsUpdate:true, size: 3, value: this.max}\n\t\t}\n    }\n\n    transpose(mat) {\n        let ret = [];\n\n        for (let i=0; i<4; i++) {\n            let arr = [];\n            for (let j=0; j<4; j++)\n                arr.push(mat[j][i]);\n            ret.push(arr);\n        }\n        \n        return ret;\n    }\n\n    updateRotationMatrix(eulerRotation) {\n\t\tlet x = [[1,0,0,0],\n\t\t\t[0,\tMath.cos(eulerRotation[0]),\t-Math.sin(eulerRotation[0]),0],\n\t\t\t[0, Math.sin(eulerRotation[0]), Math.cos(eulerRotation[0]),\t0],\n\t\t\t[0,0,0,1]];\n\t\tlet y = [\n\t\t\t[Math.cos(eulerRotation[1]), 0, Math.sin(eulerRotation[1]),0],\n\t\t\t[0,1,0,0],\n\t\t\t[Math.sin(eulerRotation[1]), 0, Math.cos(eulerRotation[1]), 0],\n\t\t\t[0,0,0,1]];\n\t\tlet z = [\n\t\t\t[Math.cos(eulerRotation[2]), -Math.sin(eulerRotation[2]), 0, 0],\n\t\t\t[Math.sin(eulerRotation[2]), Math.cos(eulerRotation[2]), 0, 0],\n\t\t\t[0,0,1,0],\n\t\t\t[0,0,0,1]\n\t\t];\n\n\t\tlet mat = this.multiplyMatrices(y, x);\n\t\tmat = this.multiplyMatrices(z, mat);\n\n\t\tthis.rotationMatrix = mat;\n        this.setMinMax();\n\t}\t\n\n    multiplyMatrices(mat1, mat2) {\n\t\tvar res = [];\n\t\tlet i, j, k;\n        for (i = 0; i < 4; i++) {\n            res[i] = [];\n            for (j = 0; j < 4; j++) {\n                res[i][j] = 0;\n                for (k = 0; k < 4; k++) {\n                    res[i][j] += mat1[i][k] * mat2[k][j];\n                }\n            }\n        }\n\t\treturn res;\n\t}\n\n    matToArray(mat) {\n        let arr = [];\n\t\tfor (let i=0; i<4; i++)\n\t\t\tarr = arr.concat(mat[i]);\n        return arr;\n    }\n\n    transformSample(matrix, point) {\n        let c0r0 = matrix[ 0], c1r0 = matrix[ 1], c2r0 = matrix[ 2], c3r0 = matrix[ 3];\n        let c0r1 = matrix[ 4], c1r1 = matrix[ 5], c2r1 = matrix[ 6], c3r1 = matrix[ 7];\n        let c0r2 = matrix[ 8], c1r2 = matrix[ 9], c2r2 = matrix[10], c3r2 = matrix[11];\n        let c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];\n      \n        let x = point[0] -  127, y = point[1] - 127, z = point[2] - 127, w = point[3];\n      \n        let resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);\n        let resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);\n        let resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);\n        let resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);\n      \n        return [resultX + 127, resultY + 127, resultZ + 127, resultW];\n      }\n\n\tfragShaderSrc(gl) {\n        \n\t\tlet gl2 = !(gl instanceof WebGLRenderingContext);\n\t\tlet str = `${gl2? '#version 300 es' : ''}\n\nprecision highp float; \nprecision highp int; \n\n${gl2? 'in' : 'varying'} vec2 v_texcoord;\n${gl2? 'out' : ''} vec4 color;\n\nuniform mat4 rotation;\nuniform vec3 min;\nuniform vec3 max;\nuniform sampler2D image;\n\nvoid main(void) {\n    vec3 ret = vec3(127.0, 127.0, 127.0) + (transpose(rotation) * (rotation * 255.0 * (texture(image, v_texcoord) - vec4(0.5, 0.5, 0.5, 0.0)))).xyz;\n    ret = (ret - min) / (max - min);\n\n    color = vec4(ret, 1.0);\n}`;\n\t\treturn str;\n\t}\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2hhZGVyRHN0cmV0Y2guanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7O0FBRWxDLDZCQUE2QiwyQ0FBTTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGlDQUFpQzs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix1RkFBdUY7QUFDL0csU0FBUyx5REFBeUQ7QUFDbEUsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxFQUFFLHVCQUF1QjtBQUN6QixFQUFFLGlCQUFpQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL1NoYWRlckRzdHJldGNoLmpzPzRlZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSBcIi4vU2hhZGVyXCI7XG5cbmNsYXNzIFNoYWRlckRzdHJldGNoIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdH1cblxuXHRpbml0KGpzb24pIHtcbiAgICAgICAgdGhpcy5yb3RhdGlvbk1hdHJpeCA9IFtbMSwwLDAsMF0sWzAsMSwwLDBdLFswLDAsMSwwXSxbMCwwLDAsMV1dO1xuXG4gICAgICAgIC8vIFN0b3JlIHNhbXBsZXMsIGNvbXB1dGUgbWluIC8gbWF4IG9uIHRoZSBmbHlcbiAgICAgICAgdGhpcy5zYW1wbGVzID0ganNvbltcInNhbXBsZXNcIl07XG4gICAgICAgIHRoaXMuc2FtcGxlcnMucHVzaCh7IGlkOjAsIG5hbWU6J2ltYWdlJywgdHlwZTondmVjMycgfSk7XG5cbiAgICAgICAgdGhpcy5zZXRNaW5NYXgoKTtcblx0fVxuXG4gICAgc2V0TWluTWF4KCkge1xuICAgICAgICBpZiAodGhpcy5zYW1wbGVzID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICBsZXQgbWluID0gW0luZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldLCBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZFNhbXBsZSA9IHRoaXMudHJhbnNmb3JtU2FtcGxlKHRoaXMubWF0VG9BcnJheSh0aGlzLnRyYW5zcG9zZSh0aGlzLnJvdGF0aW9uTWF0cml4KSksXG4gICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1TYW1wbGUoXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRUb0FycmF5KHRoaXMucm90YXRpb25NYXRyaXgpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlc1tpXS5jb25jYXQoMSkpKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPDM7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lZFNhbXBsZVtqXSA8IG1pbltqXSlcbiAgICAgICAgICAgICAgICAgICAgbWluW2pdID0gdHJhbnNmb3JtZWRTYW1wbGVbal07XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkU2FtcGxlW2pdID4gbWF4W2pdKVxuICAgICAgICAgICAgICAgICAgICBtYXhbal0gPSB0cmFuc2Zvcm1lZFNhbXBsZVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcblxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICAgICAgcm90YXRpb246IHsgdHlwZTogJ21hdDQnLCBuZWVkc1VwZGF0ZTogdHJ1ZSwgc2l6ZTogMTYsIHZhbHVlOiB0aGlzLm1hdFRvQXJyYXkodGhpcy5yb3RhdGlvbk1hdHJpeCl9LFxuXHRcdFx0bWluOiB7dHlwZTogJ3ZlYzMnLCBuZWVkc1VwZGF0ZTp0cnVlLCBzaXplOiAzLCB2YWx1ZTogdGhpcy5taW59LFxuICAgICAgICAgICAgbWF4OiB7dHlwZTogJ3ZlYzMnLCBuZWVkc1VwZGF0ZTp0cnVlLCBzaXplOiAzLCB2YWx1ZTogdGhpcy5tYXh9XG5cdFx0fVxuICAgIH1cblxuICAgIHRyYW5zcG9zZShtYXQpIHtcbiAgICAgICAgbGV0IHJldCA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTw0OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhcnIgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajw0OyBqKyspXG4gICAgICAgICAgICAgICAgYXJyLnB1c2gobWF0W2pdW2ldKTtcbiAgICAgICAgICAgIHJldC5wdXNoKGFycik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdXBkYXRlUm90YXRpb25NYXRyaXgoZXVsZXJSb3RhdGlvbikge1xuXHRcdGxldCB4ID0gW1sxLDAsMCwwXSxcblx0XHRcdFswLFx0TWF0aC5jb3MoZXVsZXJSb3RhdGlvblswXSksXHQtTWF0aC5zaW4oZXVsZXJSb3RhdGlvblswXSksMF0sXG5cdFx0XHRbMCwgTWF0aC5zaW4oZXVsZXJSb3RhdGlvblswXSksIE1hdGguY29zKGV1bGVyUm90YXRpb25bMF0pLFx0MF0sXG5cdFx0XHRbMCwwLDAsMV1dO1xuXHRcdGxldCB5ID0gW1xuXHRcdFx0W01hdGguY29zKGV1bGVyUm90YXRpb25bMV0pLCAwLCBNYXRoLnNpbihldWxlclJvdGF0aW9uWzFdKSwwXSxcblx0XHRcdFswLDEsMCwwXSxcblx0XHRcdFtNYXRoLnNpbihldWxlclJvdGF0aW9uWzFdKSwgMCwgTWF0aC5jb3MoZXVsZXJSb3RhdGlvblsxXSksIDBdLFxuXHRcdFx0WzAsMCwwLDFdXTtcblx0XHRsZXQgeiA9IFtcblx0XHRcdFtNYXRoLmNvcyhldWxlclJvdGF0aW9uWzJdKSwgLU1hdGguc2luKGV1bGVyUm90YXRpb25bMl0pLCAwLCAwXSxcblx0XHRcdFtNYXRoLnNpbihldWxlclJvdGF0aW9uWzJdKSwgTWF0aC5jb3MoZXVsZXJSb3RhdGlvblsyXSksIDAsIDBdLFxuXHRcdFx0WzAsMCwxLDBdLFxuXHRcdFx0WzAsMCwwLDFdXG5cdFx0XTtcblxuXHRcdGxldCBtYXQgPSB0aGlzLm11bHRpcGx5TWF0cmljZXMoeSwgeCk7XG5cdFx0bWF0ID0gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHosIG1hdCk7XG5cblx0XHR0aGlzLnJvdGF0aW9uTWF0cml4ID0gbWF0O1xuICAgICAgICB0aGlzLnNldE1pbk1heCgpO1xuXHR9XHRcblxuICAgIG11bHRpcGx5TWF0cmljZXMobWF0MSwgbWF0Mikge1xuXHRcdHZhciByZXMgPSBbXTtcblx0XHRsZXQgaSwgaiwgaztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldW2pdID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXVtqXSArPSBtYXQxW2ldW2tdICogbWF0MltrXVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cbiAgICBtYXRUb0FycmF5KG1hdCkge1xuICAgICAgICBsZXQgYXJyID0gW107XG5cdFx0Zm9yIChsZXQgaT0wOyBpPDQ7IGkrKylcblx0XHRcdGFyciA9IGFyci5jb25jYXQobWF0W2ldKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1TYW1wbGUobWF0cml4LCBwb2ludCkge1xuICAgICAgICBsZXQgYzByMCA9IG1hdHJpeFsgMF0sIGMxcjAgPSBtYXRyaXhbIDFdLCBjMnIwID0gbWF0cml4WyAyXSwgYzNyMCA9IG1hdHJpeFsgM107XG4gICAgICAgIGxldCBjMHIxID0gbWF0cml4WyA0XSwgYzFyMSA9IG1hdHJpeFsgNV0sIGMycjEgPSBtYXRyaXhbIDZdLCBjM3IxID0gbWF0cml4WyA3XTtcbiAgICAgICAgbGV0IGMwcjIgPSBtYXRyaXhbIDhdLCBjMXIyID0gbWF0cml4WyA5XSwgYzJyMiA9IG1hdHJpeFsxMF0sIGMzcjIgPSBtYXRyaXhbMTFdO1xuICAgICAgICBsZXQgYzByMyA9IG1hdHJpeFsxMl0sIGMxcjMgPSBtYXRyaXhbMTNdLCBjMnIzID0gbWF0cml4WzE0XSwgYzNyMyA9IG1hdHJpeFsxNV07XG4gICAgICBcbiAgICAgICAgbGV0IHggPSBwb2ludFswXSAtICAxMjcsIHkgPSBwb2ludFsxXSAtIDEyNywgeiA9IHBvaW50WzJdIC0gMTI3LCB3ID0gcG9pbnRbM107XG4gICAgICBcbiAgICAgICAgbGV0IHJlc3VsdFggPSAoeCAqIGMwcjApICsgKHkgKiBjMHIxKSArICh6ICogYzByMikgKyAodyAqIGMwcjMpO1xuICAgICAgICBsZXQgcmVzdWx0WSA9ICh4ICogYzFyMCkgKyAoeSAqIGMxcjEpICsgKHogKiBjMXIyKSArICh3ICogYzFyMyk7XG4gICAgICAgIGxldCByZXN1bHRaID0gKHggKiBjMnIwKSArICh5ICogYzJyMSkgKyAoeiAqIGMycjIpICsgKHcgKiBjMnIzKTtcbiAgICAgICAgbGV0IHJlc3VsdFcgPSAoeCAqIGMzcjApICsgKHkgKiBjM3IxKSArICh6ICogYzNyMikgKyAodyAqIGMzcjMpO1xuICAgICAgXG4gICAgICAgIHJldHVybiBbcmVzdWx0WCArIDEyNywgcmVzdWx0WSArIDEyNywgcmVzdWx0WiArIDEyNywgcmVzdWx0V107XG4gICAgICB9XG5cblx0ZnJhZ1NoYWRlclNyYyhnbCkge1xuICAgICAgICBcblx0XHRsZXQgZ2wyID0gIShnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCk7XG5cdFx0bGV0IHN0ciA9IGAke2dsMj8gJyN2ZXJzaW9uIDMwMCBlcycgOiAnJ31cblxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0OyBcbnByZWNpc2lvbiBoaWdocCBpbnQ7IFxuXG4ke2dsMj8gJ2luJyA6ICd2YXJ5aW5nJ30gdmVjMiB2X3RleGNvb3JkO1xuJHtnbDI/ICdvdXQnIDogJyd9IHZlYzQgY29sb3I7XG5cbnVuaWZvcm0gbWF0NCByb3RhdGlvbjtcbnVuaWZvcm0gdmVjMyBtaW47XG51bmlmb3JtIHZlYzMgbWF4O1xudW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gICAgdmVjMyByZXQgPSB2ZWMzKDEyNy4wLCAxMjcuMCwgMTI3LjApICsgKHRyYW5zcG9zZShyb3RhdGlvbikgKiAocm90YXRpb24gKiAyNTUuMCAqICh0ZXh0dXJlKGltYWdlLCB2X3RleGNvb3JkKSAtIHZlYzQoMC41LCAwLjUsIDAuNSwgMC4wKSkpKS54eXo7XG4gICAgcmV0ID0gKHJldCAtIG1pbikgLyAobWF4IC0gbWluKTtcblxuICAgIGNvbG9yID0gdmVjNChyZXQsIDEuMCk7XG59YDtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG59XG5cbmV4cG9ydCB7U2hhZGVyRHN0cmV0Y2h9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/ShaderDstretch.js\n");

/***/ }),

/***/ "./src/ShaderLens.js":
/*!***************************!*\
  !*** ./src/ShaderLens.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderLens\": () => (/* binding */ ShaderLens)\n/* harmony export */ });\n/* harmony import */ var _Shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Shader.js */ \"./src/Shader.js\");\n\n\nclass ShaderLens extends _Shader_js__WEBPACK_IMPORTED_MODULE_0__.Shader {\n    constructor(options) {\n        super(options);\n        \n        this.samplers = [\n\t\t\t{ id:0, name:'source0' }, { id:1, name:'source1' }\n\t\t];\n        \n        this.uniforms = {\n            u_lens: { type: 'vec4', needsUpdate: true, size: 4, value: [0,0,100,10] },\n            u_width_height: { type: 'vec2', needsUpdate: true, size: 2, value: [1,1]},\n            u_border_color: {type: 'vec4', needsUpdate: true, size: 4, value: [0.8, 0.8, 0.8, 1]},\n            u_border_enable: {type: 'bool', needsUpdate: true, size: 1, value: false}        };\n        this.label = \"ShaderLens\";\n        this.needsUpdate = true;\n        this.overlayLayerEnabled = false;\n    }\n\n    setOverlayLayerEnabled(x) {\n        this.overlayLayerEnabled = x;\n        this.needsUpdate = true;\n    }\n\n    setLensUniforms(lensViewportCoords, windowWH, borderColor, borderEnable) {\n        this.setUniform('u_lens', lensViewportCoords);\n        this.setUniform('u_width_height', windowWH);\n        this.setUniform('u_border_color', borderColor);\n        this.setUniform('u_border_enable', borderEnable);\n    }\n\n\tfragShaderSrc(gl) {\n\t\tlet gl2 = !(gl instanceof WebGLRenderingContext);\n\n        let samplerDeclaration = `uniform sampler2D ` + this.samplers[0].name + `;`;\n        let overlaySamplerCode = \"\";\n\n        if (this.overlayLayerEnabled) { //FIXME two cases with transparence or not.\n            samplerDeclaration += `uniform sampler2D ` + this.samplers[1].name + `;`;\n\n            overlaySamplerCode =  \n            `vec4 c1 = texture${gl2?'':'2D'}(source1, v_texcoord);\n            if (r > u_lens.z) {\n                float k = (c1.r + c1.g + c1.b) / 3.0;\n                c1 = vec4(k, k, k, c1.a);\n            } else if (u_border_enable && r > innerBorderRadius) {\n                // Preserve border keeping c1 alpha at zero\n                c1.a = 0.0; \n            }\n            color = color * (1.0 - c1.a) + c1 * c1.a;\n            `\n        }\n\t\treturn `${gl2? '#version 300 es':''}\n\n        precision highp float; \n        precision highp int; \n\n        ${samplerDeclaration}\n        uniform vec4 u_lens; // [cx, cy, radius, border]\n        uniform vec2 u_width_height; // Keep wh to map to pixels. TexCoords cannot be integer unless using texture_rectangle\n        uniform vec4 u_border_color;\n        uniform bool u_border_enable;\n        ${gl2? 'in' : 'varying'} vec2 v_texcoord;\n        ${gl2? 'out' : ''} vec4 color;\n\n        vec4 lensColor(in vec4 c_in, in vec4 c_border, in vec4 c_out,\n            float r, float R, float B) {\n            vec4 result;\n            if (u_border_enable) {\n                float B_SMOOTH = B < 8.0 ? B/8.0 : 1.0;\n                if (r<R-B+B_SMOOTH) {\n                    float t=smoothstep(R-B, R-B+B_SMOOTH, r);\n                    result = mix(c_in, c_border, t);\n                } else if (r<R-B_SMOOTH) {\n                    result = c_border;  \n                } else {\n                    float t=smoothstep(R-B_SMOOTH, R, r);\n                    result = mix(c_border, c_out, t);\n                }\n            } else {\n                result = (r<R) ? c_in : c_out;\n            }\n            return result;\n        }\n\n        void main() {\n            float innerBorderRadius = (u_lens.z - u_lens.w);\n            float dx = v_texcoord.x * u_width_height.x - u_lens.x;\n            float dy = v_texcoord.y * u_width_height.y - u_lens.y;\n            float r = sqrt(dx*dx + dy*dy);\n\n            vec4 c_in = texture${gl2?'':'2D'}(source0, v_texcoord);\n            vec4 c_out = u_border_color; c_out.a=0.0;\n            \n            color = lensColor(c_in, u_border_color, c_out, r, u_lens.z, u_lens.w);\n\n            ${overlaySamplerCode}\n            ${gl2?'':'gl_FragColor = color;'}\n        }\n        `\n    }\n\n    vertShaderSrc(gl) {\n\t\tlet gl2 = !(gl instanceof WebGLRenderingContext);\n\t\treturn `${gl2? '#version 300 es':''}\n\nprecision highp float; \nprecision highp int; \n\n${gl2? 'in' : 'attribute'} vec4 a_position;\n${gl2? 'in' : 'attribute'} vec2 a_texcoord;\n\n${gl2? 'out' : 'varying'} vec2 v_texcoord;\nvoid main() {\n\tgl_Position = a_position;\n    v_texcoord = a_texcoord;\n}`;\n\t}\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2hhZGVyTGVucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQzs7QUFFbEMseUJBQXlCLDhDQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQkFBc0IsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQStEO0FBQ3JGLDhCQUE4Qix1REFBdUQ7QUFDckYsNkJBQTZCLG9FQUFvRTtBQUNqRyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0ZBQWtGO0FBQ2xGOztBQUVBLHdDQUF3QztBQUN4QyxtRkFBbUY7O0FBRW5GO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSxpQkFBaUI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFlBQVk7QUFDN0MseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBOztBQUVBLEVBQUUseUJBQXlCO0FBQzNCLEVBQUUseUJBQXlCOztBQUUzQixFQUFFLHdCQUF3QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9TaGFkZXJMZW5zLmpzPzRmNGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTaGFkZXJ9IGZyb20gJy4vU2hhZGVyLmpzJ1xuXG5jbGFzcyBTaGFkZXJMZW5zIGV4dGVuZHMgU2hhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zYW1wbGVycyA9IFtcblx0XHRcdHsgaWQ6MCwgbmFtZTonc291cmNlMCcgfSwgeyBpZDoxLCBuYW1lOidzb3VyY2UxJyB9XG5cdFx0XTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgICAgICB1X2xlbnM6IHsgdHlwZTogJ3ZlYzQnLCBuZWVkc1VwZGF0ZTogdHJ1ZSwgc2l6ZTogNCwgdmFsdWU6IFswLDAsMTAwLDEwXSB9LFxuICAgICAgICAgICAgdV93aWR0aF9oZWlnaHQ6IHsgdHlwZTogJ3ZlYzInLCBuZWVkc1VwZGF0ZTogdHJ1ZSwgc2l6ZTogMiwgdmFsdWU6IFsxLDFdfSxcbiAgICAgICAgICAgIHVfYm9yZGVyX2NvbG9yOiB7dHlwZTogJ3ZlYzQnLCBuZWVkc1VwZGF0ZTogdHJ1ZSwgc2l6ZTogNCwgdmFsdWU6IFswLjgsIDAuOCwgMC44LCAxXX0sXG4gICAgICAgICAgICB1X2JvcmRlcl9lbmFibGU6IHt0eXBlOiAnYm9vbCcsIG5lZWRzVXBkYXRlOiB0cnVlLCBzaXplOiAxLCB2YWx1ZTogZmFsc2V9ICAgICAgICB9O1xuICAgICAgICB0aGlzLmxhYmVsID0gXCJTaGFkZXJMZW5zXCI7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm92ZXJsYXlMYXllckVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXRPdmVybGF5TGF5ZXJFbmFibGVkKHgpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5TGF5ZXJFbmFibGVkID0geDtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgc2V0TGVuc1VuaWZvcm1zKGxlbnNWaWV3cG9ydENvb3Jkcywgd2luZG93V0gsIGJvcmRlckNvbG9yLCBib3JkZXJFbmFibGUpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCd1X2xlbnMnLCBsZW5zVmlld3BvcnRDb29yZHMpO1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ3Vfd2lkdGhfaGVpZ2h0Jywgd2luZG93V0gpO1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ3VfYm9yZGVyX2NvbG9yJywgYm9yZGVyQ29sb3IpO1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ3VfYm9yZGVyX2VuYWJsZScsIGJvcmRlckVuYWJsZSk7XG4gICAgfVxuXG5cdGZyYWdTaGFkZXJTcmMoZ2wpIHtcblx0XHRsZXQgZ2wyID0gIShnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCk7XG5cbiAgICAgICAgbGV0IHNhbXBsZXJEZWNsYXJhdGlvbiA9IGB1bmlmb3JtIHNhbXBsZXIyRCBgICsgdGhpcy5zYW1wbGVyc1swXS5uYW1lICsgYDtgO1xuICAgICAgICBsZXQgb3ZlcmxheVNhbXBsZXJDb2RlID0gXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5vdmVybGF5TGF5ZXJFbmFibGVkKSB7IC8vRklYTUUgdHdvIGNhc2VzIHdpdGggdHJhbnNwYXJlbmNlIG9yIG5vdC5cbiAgICAgICAgICAgIHNhbXBsZXJEZWNsYXJhdGlvbiArPSBgdW5pZm9ybSBzYW1wbGVyMkQgYCArIHRoaXMuc2FtcGxlcnNbMV0ubmFtZSArIGA7YDtcblxuICAgICAgICAgICAgb3ZlcmxheVNhbXBsZXJDb2RlID0gIFxuICAgICAgICAgICAgYHZlYzQgYzEgPSB0ZXh0dXJlJHtnbDI/Jyc6JzJEJ30oc291cmNlMSwgdl90ZXhjb29yZCk7XG4gICAgICAgICAgICBpZiAociA+IHVfbGVucy56KSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgayA9IChjMS5yICsgYzEuZyArIGMxLmIpIC8gMy4wO1xuICAgICAgICAgICAgICAgIGMxID0gdmVjNChrLCBrLCBrLCBjMS5hKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodV9ib3JkZXJfZW5hYmxlICYmIHIgPiBpbm5lckJvcmRlclJhZGl1cykge1xuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGJvcmRlciBrZWVwaW5nIGMxIGFscGhhIGF0IHplcm9cbiAgICAgICAgICAgICAgICBjMS5hID0gMC4wOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbG9yID0gY29sb3IgKiAoMS4wIC0gYzEuYSkgKyBjMSAqIGMxLmE7XG4gICAgICAgICAgICBgXG4gICAgICAgIH1cblx0XHRyZXR1cm4gYCR7Z2wyPyAnI3ZlcnNpb24gMzAwIGVzJzonJ31cblxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7IFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgaW50OyBcblxuICAgICAgICAke3NhbXBsZXJEZWNsYXJhdGlvbn1cbiAgICAgICAgdW5pZm9ybSB2ZWM0IHVfbGVuczsgLy8gW2N4LCBjeSwgcmFkaXVzLCBib3JkZXJdXG4gICAgICAgIHVuaWZvcm0gdmVjMiB1X3dpZHRoX2hlaWdodDsgLy8gS2VlcCB3aCB0byBtYXAgdG8gcGl4ZWxzLiBUZXhDb29yZHMgY2Fubm90IGJlIGludGVnZXIgdW5sZXNzIHVzaW5nIHRleHR1cmVfcmVjdGFuZ2xlXG4gICAgICAgIHVuaWZvcm0gdmVjNCB1X2JvcmRlcl9jb2xvcjtcbiAgICAgICAgdW5pZm9ybSBib29sIHVfYm9yZGVyX2VuYWJsZTtcbiAgICAgICAgJHtnbDI/ICdpbicgOiAndmFyeWluZyd9IHZlYzIgdl90ZXhjb29yZDtcbiAgICAgICAgJHtnbDI/ICdvdXQnIDogJyd9IHZlYzQgY29sb3I7XG5cbiAgICAgICAgdmVjNCBsZW5zQ29sb3IoaW4gdmVjNCBjX2luLCBpbiB2ZWM0IGNfYm9yZGVyLCBpbiB2ZWM0IGNfb3V0LFxuICAgICAgICAgICAgZmxvYXQgciwgZmxvYXQgUiwgZmxvYXQgQikge1xuICAgICAgICAgICAgdmVjNCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodV9ib3JkZXJfZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgQl9TTU9PVEggPSBCIDwgOC4wID8gQi84LjAgOiAxLjA7XG4gICAgICAgICAgICAgICAgaWYgKHI8Ui1CK0JfU01PT1RIKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHQ9c21vb3Roc3RlcChSLUIsIFItQitCX1NNT09USCwgcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1peChjX2luLCBjX2JvcmRlciwgdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyPFItQl9TTU9PVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY19ib3JkZXI7ICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbG9hdCB0PXNtb290aHN0ZXAoUi1CX1NNT09USCwgUiwgcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1peChjX2JvcmRlciwgY19vdXQsIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHI8UikgPyBjX2luIDogY19vdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZmxvYXQgaW5uZXJCb3JkZXJSYWRpdXMgPSAodV9sZW5zLnogLSB1X2xlbnMudyk7XG4gICAgICAgICAgICBmbG9hdCBkeCA9IHZfdGV4Y29vcmQueCAqIHVfd2lkdGhfaGVpZ2h0LnggLSB1X2xlbnMueDtcbiAgICAgICAgICAgIGZsb2F0IGR5ID0gdl90ZXhjb29yZC55ICogdV93aWR0aF9oZWlnaHQueSAtIHVfbGVucy55O1xuICAgICAgICAgICAgZmxvYXQgciA9IHNxcnQoZHgqZHggKyBkeSpkeSk7XG5cbiAgICAgICAgICAgIHZlYzQgY19pbiA9IHRleHR1cmUke2dsMj8nJzonMkQnfShzb3VyY2UwLCB2X3RleGNvb3JkKTtcbiAgICAgICAgICAgIHZlYzQgY19vdXQgPSB1X2JvcmRlcl9jb2xvcjsgY19vdXQuYT0wLjA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbG9yID0gbGVuc0NvbG9yKGNfaW4sIHVfYm9yZGVyX2NvbG9yLCBjX291dCwgciwgdV9sZW5zLnosIHVfbGVucy53KTtcblxuICAgICAgICAgICAgJHtvdmVybGF5U2FtcGxlckNvZGV9XG4gICAgICAgICAgICAke2dsMj8nJzonZ2xfRnJhZ0NvbG9yID0gY29sb3I7J31cbiAgICAgICAgfVxuICAgICAgICBgXG4gICAgfVxuXG4gICAgdmVydFNoYWRlclNyYyhnbCkge1xuXHRcdGxldCBnbDIgPSAhKGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KTtcblx0XHRyZXR1cm4gYCR7Z2wyPyAnI3ZlcnNpb24gMzAwIGVzJzonJ31cblxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0OyBcbnByZWNpc2lvbiBoaWdocCBpbnQ7IFxuXG4ke2dsMj8gJ2luJyA6ICdhdHRyaWJ1dGUnfSB2ZWM0IGFfcG9zaXRpb247XG4ke2dsMj8gJ2luJyA6ICdhdHRyaWJ1dGUnfSB2ZWMyIGFfdGV4Y29vcmQ7XG5cbiR7Z2wyPyAnb3V0JyA6ICd2YXJ5aW5nJ30gdmVjMiB2X3RleGNvb3JkO1xudm9pZCBtYWluKCkge1xuXHRnbF9Qb3NpdGlvbiA9IGFfcG9zaXRpb247XG4gICAgdl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7XG59YDtcblx0fVxufVxuXG5leHBvcnQge1NoYWRlckxlbnN9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/ShaderLens.js\n");

/***/ }),

/***/ "./src/Signals.js":
/*!************************!*\
  !*** ./src/Signals.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addSignals\": () => (/* binding */ addSignals)\n/* harmony export */ });\n\nfunction addSignals(proto, ...signals) {\n\n\tif(!proto.prototype.allSignals)\n\t\tproto.prototype.allSignals = [];\n\tproto.prototype.allSignals = [...proto.prototype.allSignals, ...signals];\n\n\tproto.prototype.initSignals = function() {\n\t\tthis.signals = Object.fromEntries(this.allSignals.map( s => [s, []]));\n\t}\n     \n     \n\t/**\n\t  * Adds a Layer Event\n\t  * @param {string} event A label to identify the event.\n\t  * @param {*} callback The event callback function.\n\t*/\n\tproto.prototype.addEvent = function(event, callback) {\n\t\tif(!this.signals)\n\t\t\tthis.initSignals();\n\t\tthis.signals[event].push(callback);\n\t}\n\n\t/*\n\t  * Emits an event (running all the callbacks referred to it).\n\t  * @param {*} event The event name\n\t  */\n\t/** @ignore */\n\tproto.prototype.emit = function(event, ...parameters) {\n\t\tif(!this.signals)\n\t\t\tthis.initSignals();\n\t\tfor (let r of this.signals[event])\n\t\t\tr(...parameters);\n\t}\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2lnbmFscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvU2lnbmFscy5qcz83MDQwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuZnVuY3Rpb24gYWRkU2lnbmFscyhwcm90bywgLi4uc2lnbmFscykge1xuXG5cdGlmKCFwcm90by5wcm90b3R5cGUuYWxsU2lnbmFscylcblx0XHRwcm90by5wcm90b3R5cGUuYWxsU2lnbmFscyA9IFtdO1xuXHRwcm90by5wcm90b3R5cGUuYWxsU2lnbmFscyA9IFsuLi5wcm90by5wcm90b3R5cGUuYWxsU2lnbmFscywgLi4uc2lnbmFsc107XG5cblx0cHJvdG8ucHJvdG90eXBlLmluaXRTaWduYWxzID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zaWduYWxzID0gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuYWxsU2lnbmFscy5tYXAoIHMgPT4gW3MsIFtdXSkpO1xuXHR9XG4gICAgIFxuICAgICBcblx0LyoqXG5cdCAgKiBBZGRzIGEgTGF5ZXIgRXZlbnRcblx0ICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBBIGxhYmVsIHRvIGlkZW50aWZ5IHRoZSBldmVudC5cblx0ICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2sgVGhlIGV2ZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQqL1xuXHRwcm90by5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcblx0XHRpZighdGhpcy5zaWduYWxzKVxuXHRcdFx0dGhpcy5pbml0U2lnbmFscygpO1xuXHRcdHRoaXMuc2lnbmFsc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG5cdH1cblxuXHQvKlxuXHQgICogRW1pdHMgYW4gZXZlbnQgKHJ1bm5pbmcgYWxsIHRoZSBjYWxsYmFja3MgcmVmZXJyZWQgdG8gaXQpLlxuXHQgICogQHBhcmFtIHsqfSBldmVudCBUaGUgZXZlbnQgbmFtZVxuXHQgICovXG5cdC8qKiBAaWdub3JlICovXG5cdHByb3RvLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQsIC4uLnBhcmFtZXRlcnMpIHtcblx0XHRpZighdGhpcy5zaWduYWxzKVxuXHRcdFx0dGhpcy5pbml0U2lnbmFscygpO1xuXHRcdGZvciAobGV0IHIgb2YgdGhpcy5zaWduYWxzW2V2ZW50XSlcblx0XHRcdHIoLi4ucGFyYW1ldGVycyk7XG5cdH1cbn1cblxuZXhwb3J0IHsgYWRkU2lnbmFscyB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Signals.js\n");

/***/ }),

/***/ "./src/Simplify.js":
/*!*************************!*\
  !*** ./src/Simplify.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"simplify\": () => (/* binding */ simplify),\n/* harmony export */   \"smooth\": () => (/* binding */ smooth),\n/* harmony export */   \"smoothToPath\": () => (/* binding */ smoothToPath)\n/* harmony export */ });\n/* FROM: https://stackoverflow.com/questions/40650306/how-to-draw-a-smooth-continuous-line-with-mouse-using-html-canvas-and-javascript */\n\n/**\n * A [x, y, xc, yc] point.\n * @typedef BezierPoint\n * @property {number} p.0 The x-coordinate.\n * @property {number} p.1 The y-coordinate.\n * @property {number} p.2 The x-coordinate of the control point.\n * @property {number} p.3 The y-coordinate of the control point.\n */\n\n/**\n * Simplifies a polyline via the Douglas-Peucker algorithm.\n * @param {Array<Point>} points A polyline.\n * @param {*} tolerance The tolerance is the maximum distance between the original polyline and the simplified polyline.\n * It has the same metric as the point coordinates.  \n * @returns {Array<Point>} The simplified polyline.\n */\nfunction simplify(points, tolerance) {\n\tlet tolerance2 = Math.pow(tolerance, 2);\n\n    var simplify1 = function(start, end) { // recursize simplifies points from start to end\n        var index, i, xx , yy, dx, dy, ddx, ddy,  t, dist, dist1;\n        let p1 = points[start];\n        let p2 = points[end];   \n        xx = p1.x;\n        yy = p1.y;\n        ddx = p2.x - xx;\n        ddy = p2.y - yy;\n        dist1 = ddx * ddx + ddy * ddy;\n        let maxDist = tolerance2;\n        for (var i = start + 1; i < end; i++) {\n            let p = points[i];\n            if (ddx !== 0 || ddy !== 0) {\n                t = ((p.x - xx) * ddx + (p.y - yy) * ddy) / dist1;\n                if (t > 1) {\n                    dx = p.x - p2.x;\n                    dy = p.y - p2.y;\n                } else \n                if (t > 0) {\n                    dx = p.x - (xx + ddx * t);\n                    dy = p.y - (yy + ddy * t);\n                } else {\n                    dx = p.x - xx;\n                    dy = p.y - yy;\n                }\n            } else{\n                dx = p.x - xx;\n                dy = p.y - yy;\n            }\n            dist = dx * dx + dy * dy \n            if (dist > maxDist) {\n                index = i;\n                maxDist = dist;\n            }\n        }\n\n        if (maxDist > tolerance2) { \n            if (index - start > 1){\n                simplify1(start, index);\n            }\n            newLine.push(points[index]);\n            if (end - index > 1){\n                simplify1(index, end);\n            }\n        }\n    }    \n    var end = points.length - 1;\n    var newLine = [points[0]];\n    simplify1(0, end);\n    newLine.push(points[end]);\n    return newLine;\n}\n\n/**\n *  Uses Bezier Curve to smooth a polyline\n * @param {Array<Point>} points A polyline.\n * @param {number} cornerThres The angular threshold (in degrees). Two segments are smoothed if their angle is less then the threshold.\n * @param {bool} match Whether the smoothed curve should traverse the original points or approximate them.\n * @returns {Array<BezierPoint>} The smoothed polyline.\n */\nfunction smooth(points, cornerThres, match) {\n\tcornerThres *= 3.1415/180;\n\tlet newPoints = []; // array for new points\n\n\tif(points.length <= 2)\n\t\treturn points.map((p) => [p.x, p.y]);\n\n\tlet nx1, ny1, nx2, ny2, dist1, dist2;\n\n\tfunction dot(x, y, xx, yy) {  // get do product\n\t\t// dist1,dist2,nx1,nx2,ny1,ny2 are the length and  normals and used outside function\n\t\t// normalise both vectors\n\t\t\n\t\tdist1 = Math.sqrt(x * x + y * y); // get length\n\t\tif (dist1  > 0) {  // normalise\n\t\t\tnx1 = x / dist1 ;\n\t\t\tny1 = y / dist1 ;\n\t\t} else {\n\t\t\tnx1 = 1;  // need to have something so this will do as good as anything\n\t\t\tny1 = 0;\n\t\t}\n\t\tdist2  = Math.sqrt(xx * xx + yy * yy);\n\t\tif (dist2  > 0) {\n\t\t\tnx2 = xx / dist2;\n\t\t\tny2 = yy / dist2;\n\t\t} else {\n\t\t\tnx2 = 1;\n\t\t\tny2 = 0;\n\t\t}\n\t\treturn Math.acos(nx1 * nx2 + ny1 * ny2 ); // dot product\n\t}\n\n\tlet p1 = points[0];\n\tlet endP = points[points.length-1];\n\tlet i = 0;  // start from second poitn if line not closed\n\tlet closed = false;\n\tlet len = Math.hypot(p1.x- endP.x, p1.y-endP.y);\n\t\n\tif(len < Math.SQRT2){  // end points are the same. Join them in coordinate space\n\t\tendP =  p1;\n\t\ti = 0;\t\t\t // start from first point if line closed\n\t\tp1 = points[points.length-2];\n\t\tclosed = true;\n\t}\t   \n\tnewPoints.push([points[i].x,points[i].y])\n\tfor(; i < points.length-1; i++){\n\t\tlet p2 = points[i];\n\t\tlet p3 = points[i + 1];\n\t\tlet angle = Math.abs(dot(p2.x - p1.x, p2.y - p1.y, p3.x - p2.x, p3.y - p2.y));\n\t\tif(dist1 !== 0){  // dist1 and dist2 come from dot function\n\t\t\tif( angle < cornerThres){ // bend it if angle between lines is small\n\t\t\t\t  if(match){\n\t\t\t\t\t  dist1 = Math.min(dist1,dist2);\n\t\t\t\t\t  dist2 = dist1;\n\t\t\t\t  }\n\t\t\t\t  // use the two normalized vectors along the lines to create the tangent vector\n\t\t\t\t  let x = (nx1 + nx2) / 2;  \n\t\t\t\t  let y = (ny1 + ny2) / 2;\n\t\t\t\t  len = Math.sqrt(x * x + y * y);  // normalise the tangent\n\t\t\t\t  if(len === 0){\n\t\t\t\t\t  newPoints.push([p2.x,p2.y]);\t\t\t\t\t\t\t\t  \n\t\t\t\t  } else {\n\t\t\t\t\t  x /= len;\n\t\t\t\t\t  y /= len;\n\t\t\t\t\t  if(newPoints.length > 0){\n\t\t\t\t\t\t  var np = newPoints[newPoints.length-1];\n\t\t\t\t\t\t  np.push(p2.x-x*dist1*0.25);\n\t\t\t\t\t\t  np.push(p2.y-y*dist1*0.25);\n\t\t\t\t\t  }\n\t\t\t\t\t  newPoints.push([  // create the new point with the new bezier control points.\n\t\t\t\t\t\t\tp2.x,\n\t\t\t\t\t\t\tp2.y,\n\t\t\t\t\t\t\tp2.x+x*dist2*0.25,\n\t\t\t\t\t\t\tp2.y+y*dist2*0.25\n\t\t\t\t\t  ]);\n\t\t\t\t  }\n\t\t\t} else {\n\t\t\t\tnewPoints.push([p2.x,p2.y]);\t\t\t\n\t\t\t}\n\t\t}\n\t\tp1 = p2;\n\t}  \n\tif(closed){ // if closed then copy first point to last.\n\t\tp1 = [];\n\t\tfor(i = 0; i < newPoints[0].length; i++){\n\t\t\tp1.push(newPoints[0][i]);\n\t\t}\n\t\tnewPoints.push(p1);\n\t}else{\n\t\tnewPoints.push([points[points.length-1].x,points[points.length-1].y]);\t  \n\t}\n\treturn newPoints;\t\n}\n\n/**\n * Converts a smoothed polyline into an SVG path.\n * @param {Array<BezierPoint>} smoothed The smoothed polyline.\n * @returns {Array<String>} The SVG path.\n */\nfunction smoothToPath(smoothed) {\n\tlet p = smoothed[0];\n\tlet d = [`M${p[0].toFixed(1)} ${p[1].toFixed(1)}`];\n\tlet p1;\n\tfor(let i = 0; i < smoothed.length-1; i++) {\n\t\tp = smoothed[i];\n\t\tp1 = smoothed[i+1];\t\n\t\tif(p.length == 2)\n\t\t\td.push(`l${(p1[0]-p[0]).toFixed(1)} ${(p1[1]-p[1]).toFixed(1)}`)\n\t\telse if(p.length == 4) \n\t\t\td.push(`q${(p[2]-p[0]).toFixed(1)} ${(p[3]-p[1]).toFixed(1)} ${(p1[0]-p[0]).toFixed(1)} ${(p1[1]-p[1]).toFixed(1)}`)\n\t\telse\n\t\t\td.push(`c${(p[2]-p[0]).toFixed(1)} ${(p[3]-p[1]).toFixed(1)} ${(p[4]-p[0]).toFixed(1)} ${(p[5]-p[1]).toFixed(1)} ${(p1[0]-p[0]).toFixed(1)} ${(p1[1]-p[1]).toFixed(1)}`);\n\t}\n\treturn d.join(' ');\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2ltcGxpZnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQkFBcUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCLEVBQUUsZ0JBQWdCO0FBQ2pEO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QixFQUFFLHdCQUF3QjtBQUNqRTtBQUNBLGNBQWMsd0JBQXdCLEVBQUUsd0JBQXdCLEVBQUUseUJBQXlCLEVBQUUsd0JBQXdCO0FBQ3JIO0FBQ0EsY0FBYyx3QkFBd0IsRUFBRSx3QkFBd0IsRUFBRSx3QkFBd0IsRUFBRSx3QkFBd0IsRUFBRSx5QkFBeUIsRUFBRSx3QkFBd0I7QUFDeks7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvU2ltcGxpZnkuanM/YjUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBGUk9NOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MDY1MDMwNi9ob3ctdG8tZHJhdy1hLXNtb290aC1jb250aW51b3VzLWxpbmUtd2l0aC1tb3VzZS11c2luZy1odG1sLWNhbnZhcy1hbmQtamF2YXNjcmlwdCAqL1xuXG4vKipcbiAqIEEgW3gsIHksIHhjLCB5Y10gcG9pbnQuXG4gKiBAdHlwZWRlZiBCZXppZXJQb2ludFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHAuMCBUaGUgeC1jb29yZGluYXRlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHAuMSBUaGUgeS1jb29yZGluYXRlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHAuMiBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHAuMyBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICovXG5cbi8qKlxuICogU2ltcGxpZmllcyBhIHBvbHlsaW5lIHZpYSB0aGUgRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7QXJyYXk8UG9pbnQ+fSBwb2ludHMgQSBwb2x5bGluZS5cbiAqIEBwYXJhbSB7Kn0gdG9sZXJhbmNlIFRoZSB0b2xlcmFuY2UgaXMgdGhlIG1heGltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgb3JpZ2luYWwgcG9seWxpbmUgYW5kIHRoZSBzaW1wbGlmaWVkIHBvbHlsaW5lLlxuICogSXQgaGFzIHRoZSBzYW1lIG1ldHJpYyBhcyB0aGUgcG9pbnQgY29vcmRpbmF0ZXMuICBcbiAqIEByZXR1cm5zIHtBcnJheTxQb2ludD59IFRoZSBzaW1wbGlmaWVkIHBvbHlsaW5lLlxuICovXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xuXHRsZXQgdG9sZXJhbmNlMiA9IE1hdGgucG93KHRvbGVyYW5jZSwgMik7XG5cbiAgICB2YXIgc2ltcGxpZnkxID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkgeyAvLyByZWN1cnNpemUgc2ltcGxpZmllcyBwb2ludHMgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgICAgdmFyIGluZGV4LCBpLCB4eCAsIHl5LCBkeCwgZHksIGRkeCwgZGR5LCAgdCwgZGlzdCwgZGlzdDE7XG4gICAgICAgIGxldCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICAgIGxldCBwMiA9IHBvaW50c1tlbmRdOyAgIFxuICAgICAgICB4eCA9IHAxLng7XG4gICAgICAgIHl5ID0gcDEueTtcbiAgICAgICAgZGR4ID0gcDIueCAtIHh4O1xuICAgICAgICBkZHkgPSBwMi55IC0geXk7XG4gICAgICAgIGRpc3QxID0gZGR4ICogZGR4ICsgZGR5ICogZGR5O1xuICAgICAgICBsZXQgbWF4RGlzdCA9IHRvbGVyYW5jZTI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBpZiAoZGR4ICE9PSAwIHx8IGRkeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSAoKHAueCAtIHh4KSAqIGRkeCArIChwLnkgLSB5eSkgKiBkZHkpIC8gZGlzdDE7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gcC54IC0gcDIueDtcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBwLnkgLSBwMi55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBcbiAgICAgICAgICAgICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHggPSBwLnggLSAoeHggKyBkZHggKiB0KTtcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBwLnkgLSAoeXkgKyBkZHkgKiB0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkeCA9IHAueCAtIHh4O1xuICAgICAgICAgICAgICAgICAgICBkeSA9IHAueSAtIHl5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgICBkeCA9IHAueCAtIHh4O1xuICAgICAgICAgICAgICAgIGR5ID0gcC55IC0geXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ID0gZHggKiBkeCArIGR5ICogZHkgXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG1heERpc3QpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4RGlzdCA+IHRvbGVyYW5jZTIpIHsgXG4gICAgICAgICAgICBpZiAoaW5kZXggLSBzdGFydCA+IDEpe1xuICAgICAgICAgICAgICAgIHNpbXBsaWZ5MShzdGFydCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3TGluZS5wdXNoKHBvaW50c1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKGVuZCAtIGluZGV4ID4gMSl7XG4gICAgICAgICAgICAgICAgc2ltcGxpZnkxKGluZGV4LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSAgICBcbiAgICB2YXIgZW5kID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld0xpbmUgPSBbcG9pbnRzWzBdXTtcbiAgICBzaW1wbGlmeTEoMCwgZW5kKTtcbiAgICBuZXdMaW5lLnB1c2gocG9pbnRzW2VuZF0pO1xuICAgIHJldHVybiBuZXdMaW5lO1xufVxuXG4vKipcbiAqICBVc2VzIEJlemllciBDdXJ2ZSB0byBzbW9vdGggYSBwb2x5bGluZVxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IHBvaW50cyBBIHBvbHlsaW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvcm5lclRocmVzIFRoZSBhbmd1bGFyIHRocmVzaG9sZCAoaW4gZGVncmVlcykuIFR3byBzZWdtZW50cyBhcmUgc21vb3RoZWQgaWYgdGhlaXIgYW5nbGUgaXMgbGVzcyB0aGVuIHRoZSB0aHJlc2hvbGQuXG4gKiBAcGFyYW0ge2Jvb2x9IG1hdGNoIFdoZXRoZXIgdGhlIHNtb290aGVkIGN1cnZlIHNob3VsZCB0cmF2ZXJzZSB0aGUgb3JpZ2luYWwgcG9pbnRzIG9yIGFwcHJveGltYXRlIHRoZW0uXG4gKiBAcmV0dXJucyB7QXJyYXk8QmV6aWVyUG9pbnQ+fSBUaGUgc21vb3RoZWQgcG9seWxpbmUuXG4gKi9cbmZ1bmN0aW9uIHNtb290aChwb2ludHMsIGNvcm5lclRocmVzLCBtYXRjaCkge1xuXHRjb3JuZXJUaHJlcyAqPSAzLjE0MTUvMTgwO1xuXHRsZXQgbmV3UG9pbnRzID0gW107IC8vIGFycmF5IGZvciBuZXcgcG9pbnRzXG5cblx0aWYocG9pbnRzLmxlbmd0aCA8PSAyKVxuXHRcdHJldHVybiBwb2ludHMubWFwKChwKSA9PiBbcC54LCBwLnldKTtcblxuXHRsZXQgbngxLCBueTEsIG54MiwgbnkyLCBkaXN0MSwgZGlzdDI7XG5cblx0ZnVuY3Rpb24gZG90KHgsIHksIHh4LCB5eSkgeyAgLy8gZ2V0IGRvIHByb2R1Y3Rcblx0XHQvLyBkaXN0MSxkaXN0MixueDEsbngyLG55MSxueTIgYXJlIHRoZSBsZW5ndGggYW5kICBub3JtYWxzIGFuZCB1c2VkIG91dHNpZGUgZnVuY3Rpb25cblx0XHQvLyBub3JtYWxpc2UgYm90aCB2ZWN0b3JzXG5cdFx0XG5cdFx0ZGlzdDEgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7IC8vIGdldCBsZW5ndGhcblx0XHRpZiAoZGlzdDEgID4gMCkgeyAgLy8gbm9ybWFsaXNlXG5cdFx0XHRueDEgPSB4IC8gZGlzdDEgO1xuXHRcdFx0bnkxID0geSAvIGRpc3QxIDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bngxID0gMTsgIC8vIG5lZWQgdG8gaGF2ZSBzb21ldGhpbmcgc28gdGhpcyB3aWxsIGRvIGFzIGdvb2QgYXMgYW55dGhpbmdcblx0XHRcdG55MSA9IDA7XG5cdFx0fVxuXHRcdGRpc3QyICA9IE1hdGguc3FydCh4eCAqIHh4ICsgeXkgKiB5eSk7XG5cdFx0aWYgKGRpc3QyICA+IDApIHtcblx0XHRcdG54MiA9IHh4IC8gZGlzdDI7XG5cdFx0XHRueTIgPSB5eSAvIGRpc3QyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRueDIgPSAxO1xuXHRcdFx0bnkyID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIE1hdGguYWNvcyhueDEgKiBueDIgKyBueTEgKiBueTIgKTsgLy8gZG90IHByb2R1Y3Rcblx0fVxuXG5cdGxldCBwMSA9IHBvaW50c1swXTtcblx0bGV0IGVuZFAgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXTtcblx0bGV0IGkgPSAwOyAgLy8gc3RhcnQgZnJvbSBzZWNvbmQgcG9pdG4gaWYgbGluZSBub3QgY2xvc2VkXG5cdGxldCBjbG9zZWQgPSBmYWxzZTtcblx0bGV0IGxlbiA9IE1hdGguaHlwb3QocDEueC0gZW5kUC54LCBwMS55LWVuZFAueSk7XG5cdFxuXHRpZihsZW4gPCBNYXRoLlNRUlQyKXsgIC8vIGVuZCBwb2ludHMgYXJlIHRoZSBzYW1lLiBKb2luIHRoZW0gaW4gY29vcmRpbmF0ZSBzcGFjZVxuXHRcdGVuZFAgPSAgcDE7XG5cdFx0aSA9IDA7XHRcdFx0IC8vIHN0YXJ0IGZyb20gZmlyc3QgcG9pbnQgaWYgbGluZSBjbG9zZWRcblx0XHRwMSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTJdO1xuXHRcdGNsb3NlZCA9IHRydWU7XG5cdH1cdCAgIFxuXHRuZXdQb2ludHMucHVzaChbcG9pbnRzW2ldLngscG9pbnRzW2ldLnldKVxuXHRmb3IoOyBpIDwgcG9pbnRzLmxlbmd0aC0xOyBpKyspe1xuXHRcdGxldCBwMiA9IHBvaW50c1tpXTtcblx0XHRsZXQgcDMgPSBwb2ludHNbaSArIDFdO1xuXHRcdGxldCBhbmdsZSA9IE1hdGguYWJzKGRvdChwMi54IC0gcDEueCwgcDIueSAtIHAxLnksIHAzLnggLSBwMi54LCBwMy55IC0gcDIueSkpO1xuXHRcdGlmKGRpc3QxICE9PSAwKXsgIC8vIGRpc3QxIGFuZCBkaXN0MiBjb21lIGZyb20gZG90IGZ1bmN0aW9uXG5cdFx0XHRpZiggYW5nbGUgPCBjb3JuZXJUaHJlcyl7IC8vIGJlbmQgaXQgaWYgYW5nbGUgYmV0d2VlbiBsaW5lcyBpcyBzbWFsbFxuXHRcdFx0XHQgIGlmKG1hdGNoKXtcblx0XHRcdFx0XHQgIGRpc3QxID0gTWF0aC5taW4oZGlzdDEsZGlzdDIpO1xuXHRcdFx0XHRcdCAgZGlzdDIgPSBkaXN0MTtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdCAgLy8gdXNlIHRoZSB0d28gbm9ybWFsaXplZCB2ZWN0b3JzIGFsb25nIHRoZSBsaW5lcyB0byBjcmVhdGUgdGhlIHRhbmdlbnQgdmVjdG9yXG5cdFx0XHRcdCAgbGV0IHggPSAobngxICsgbngyKSAvIDI7ICBcblx0XHRcdFx0ICBsZXQgeSA9IChueTEgKyBueTIpIC8gMjtcblx0XHRcdFx0ICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7ICAvLyBub3JtYWxpc2UgdGhlIHRhbmdlbnRcblx0XHRcdFx0ICBpZihsZW4gPT09IDApe1xuXHRcdFx0XHRcdCAgbmV3UG9pbnRzLnB1c2goW3AyLngscDIueV0pO1x0XHRcdFx0XHRcdFx0XHQgIFxuXHRcdFx0XHQgIH0gZWxzZSB7XG5cdFx0XHRcdFx0ICB4IC89IGxlbjtcblx0XHRcdFx0XHQgIHkgLz0gbGVuO1xuXHRcdFx0XHRcdCAgaWYobmV3UG9pbnRzLmxlbmd0aCA+IDApe1xuXHRcdFx0XHRcdFx0ICB2YXIgbnAgPSBuZXdQb2ludHNbbmV3UG9pbnRzLmxlbmd0aC0xXTtcblx0XHRcdFx0XHRcdCAgbnAucHVzaChwMi54LXgqZGlzdDEqMC4yNSk7XG5cdFx0XHRcdFx0XHQgIG5wLnB1c2gocDIueS15KmRpc3QxKjAuMjUpO1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdCAgbmV3UG9pbnRzLnB1c2goWyAgLy8gY3JlYXRlIHRoZSBuZXcgcG9pbnQgd2l0aCB0aGUgbmV3IGJlemllciBjb250cm9sIHBvaW50cy5cblx0XHRcdFx0XHRcdFx0cDIueCxcblx0XHRcdFx0XHRcdFx0cDIueSxcblx0XHRcdFx0XHRcdFx0cDIueCt4KmRpc3QyKjAuMjUsXG5cdFx0XHRcdFx0XHRcdHAyLnkreSpkaXN0MiowLjI1XG5cdFx0XHRcdFx0ICBdKTtcblx0XHRcdFx0ICB9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdQb2ludHMucHVzaChbcDIueCxwMi55XSk7XHRcdFx0XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHAxID0gcDI7XG5cdH0gIFxuXHRpZihjbG9zZWQpeyAvLyBpZiBjbG9zZWQgdGhlbiBjb3B5IGZpcnN0IHBvaW50IHRvIGxhc3QuXG5cdFx0cDEgPSBbXTtcblx0XHRmb3IoaSA9IDA7IGkgPCBuZXdQb2ludHNbMF0ubGVuZ3RoOyBpKyspe1xuXHRcdFx0cDEucHVzaChuZXdQb2ludHNbMF1baV0pO1xuXHRcdH1cblx0XHRuZXdQb2ludHMucHVzaChwMSk7XG5cdH1lbHNle1xuXHRcdG5ld1BvaW50cy5wdXNoKFtwb2ludHNbcG9pbnRzLmxlbmd0aC0xXS54LHBvaW50c1twb2ludHMubGVuZ3RoLTFdLnldKTtcdCAgXG5cdH1cblx0cmV0dXJuIG5ld1BvaW50cztcdFxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc21vb3RoZWQgcG9seWxpbmUgaW50byBhbiBTVkcgcGF0aC5cbiAqIEBwYXJhbSB7QXJyYXk8QmV6aWVyUG9pbnQ+fSBzbW9vdGhlZCBUaGUgc21vb3RoZWQgcG9seWxpbmUuXG4gKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPn0gVGhlIFNWRyBwYXRoLlxuICovXG5mdW5jdGlvbiBzbW9vdGhUb1BhdGgoc21vb3RoZWQpIHtcblx0bGV0IHAgPSBzbW9vdGhlZFswXTtcblx0bGV0IGQgPSBbYE0ke3BbMF0udG9GaXhlZCgxKX0gJHtwWzFdLnRvRml4ZWQoMSl9YF07XG5cdGxldCBwMTtcblx0Zm9yKGxldCBpID0gMDsgaSA8IHNtb290aGVkLmxlbmd0aC0xOyBpKyspIHtcblx0XHRwID0gc21vb3RoZWRbaV07XG5cdFx0cDEgPSBzbW9vdGhlZFtpKzFdO1x0XG5cdFx0aWYocC5sZW5ndGggPT0gMilcblx0XHRcdGQucHVzaChgbCR7KHAxWzBdLXBbMF0pLnRvRml4ZWQoMSl9ICR7KHAxWzFdLXBbMV0pLnRvRml4ZWQoMSl9YClcblx0XHRlbHNlIGlmKHAubGVuZ3RoID09IDQpIFxuXHRcdFx0ZC5wdXNoKGBxJHsocFsyXS1wWzBdKS50b0ZpeGVkKDEpfSAkeyhwWzNdLXBbMV0pLnRvRml4ZWQoMSl9ICR7KHAxWzBdLXBbMF0pLnRvRml4ZWQoMSl9ICR7KHAxWzFdLXBbMV0pLnRvRml4ZWQoMSl9YClcblx0XHRlbHNlXG5cdFx0XHRkLnB1c2goYGMkeyhwWzJdLXBbMF0pLnRvRml4ZWQoMSl9ICR7KHBbM10tcFsxXSkudG9GaXhlZCgxKX0gJHsocFs0XS1wWzBdKS50b0ZpeGVkKDEpfSAkeyhwWzVdLXBbMV0pLnRvRml4ZWQoMSl9ICR7KHAxWzBdLXBbMF0pLnRvRml4ZWQoMSl9ICR7KHAxWzFdLXBbMV0pLnRvRml4ZWQoMSl9YCk7XG5cdH1cblx0cmV0dXJuIGQuam9pbignICcpO1xufVxuXG5leHBvcnQgeyBzaW1wbGlmeSwgc21vb3RoLCBzbW9vdGhUb1BhdGggfSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Simplify.js\n");

/***/ }),

/***/ "./src/Skin.js":
/*!*********************!*\
  !*** ./src/Skin.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Skin\": () => (/* binding */ Skin)\n/* harmony export */ });\n\nlet url = 'skin/skin.svg';\nlet svg = null;\nlet pad = 5;\n\n/**\n * The static class **Skin** implements some utilities for handling the skin file.\n * A skin file is a SVG file containing SVG icons that are used by **UIBasic*\n * for customizing the visual appearance of the user interface (i.e., icons for buttons, menu, toolbar, dialog...).\n * Each SVG drawing element must be tagged with a 'class' attribute  whose name must begin with *openlime-*:\n * for instance, the HOME icon is a SVG element tagged with `class=\"openlime-home\"`. \n */\nclass Skin {\n\t/**\n\t * Sets the URL of the SVG skin file. By default it is *'skin/skin.svg'*;\n\t * @param {string} u The URL of the SVG skin file.\n\t */\n\tstatic setUrl(u) { url = u; }\n\n\t/**\n\t * Loads the SVG skin file and converts it into a global DOM SVGElement ready for use in a web page.\n\t */\n\tstatic async loadSvg() {\n\t\tvar response = await fetch(url);\n\t\tif (!response.ok) {\n\t\t\tthrow Error(\"Failed loading \" + url + \": \" + response.statusText);\n\t\t\treturn;\n\t\t}\n\n\t\tlet text = await response.text();\n\t\tlet parser = new DOMParser();\n\t\tsvg = parser.parseFromString(text, \"image/svg+xml\").documentElement;\n\t}\n\n\t/**\n\t * Gets the SVG element with a specific CSS `selector`.\n\t * @param {string} selector A CSS selector (e.g. a class name).\n\t * @returns {SVGElement} The SVGElement referenced by the selector.\n\t */\n\tstatic async getElement(selector) {\n\t\tif (!svg)\n\t\t\tawait Skin.loadSvg();\n\t\treturn svg.querySelector(selector).cloneNode(true);\n\t}\n\n\t/**\n\t * Appends the selected SVG element to the `container`.\n\t * @param {HTMLElement} container A HTML DOM node.\n\t * @param {SVGElement|string} elm An SVGElement or a CSS selector (e.g. a class name).\n\t * @returns {SVGElement} A pointer to the SVG icon referenced by the elm.\n\t */\n\tstatic async appendIcon(container, icon) {\n\t\tlet element = null;\n\t\tif (typeof icon == 'string') {\n\t\t\telement = await Skin.getElement(icon);\n\t\t\ticon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\t\t\ticon.appendChild(element);\n\t\t\tcontainer.appendChild(icon);\n\t\t\tlet box = element.getBBox();\n\t\t\tlet tlist = element.transform.baseVal;\n\t\t\tif (tlist.numberOfItems == 0)\n\t\t\t\ttlist.appendItem(icon.createSVGTransform());\n\t\t\ttlist.getItem(0).setTranslate(-box.x, -box.y);\n\t\t\ticon.setAttribute('viewBox', `${-pad} ${-pad} ${box.width + 2 * pad} ${box.height + 2 * pad}`);\n\t\t\ticon.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n\t\t} else {\n\t\t\tcontainer.appendChild(icon);\n\t\t\tlet box = icon.getBBox();\n\t\t\ticon.setAttribute('viewBox', `${-pad} ${-pad} ${box.width + 2 * pad} ${box.height + 2 * pad}`);\n\t\t\ticon.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n\t\t}\n\t\treturn icon;\n\t }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvU2tpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksbUJBQW1CO0FBQy9CLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNLEVBQUUsTUFBTSxFQUFFLHFCQUFxQixFQUFFLHFCQUFxQjtBQUMvRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sRUFBRSxNQUFNLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9Ta2luLmpzP2RlMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5sZXQgdXJsID0gJ3NraW4vc2tpbi5zdmcnO1xubGV0IHN2ZyA9IG51bGw7XG5sZXQgcGFkID0gNTtcblxuLyoqXG4gKiBUaGUgc3RhdGljIGNsYXNzICoqU2tpbioqIGltcGxlbWVudHMgc29tZSB1dGlsaXRpZXMgZm9yIGhhbmRsaW5nIHRoZSBza2luIGZpbGUuXG4gKiBBIHNraW4gZmlsZSBpcyBhIFNWRyBmaWxlIGNvbnRhaW5pbmcgU1ZHIGljb25zIHRoYXQgYXJlIHVzZWQgYnkgKipVSUJhc2ljKlxuICogZm9yIGN1c3RvbWl6aW5nIHRoZSB2aXN1YWwgYXBwZWFyYW5jZSBvZiB0aGUgdXNlciBpbnRlcmZhY2UgKGkuZS4sIGljb25zIGZvciBidXR0b25zLCBtZW51LCB0b29sYmFyLCBkaWFsb2cuLi4pLlxuICogRWFjaCBTVkcgZHJhd2luZyBlbGVtZW50IG11c3QgYmUgdGFnZ2VkIHdpdGggYSAnY2xhc3MnIGF0dHJpYnV0ZSAgd2hvc2UgbmFtZSBtdXN0IGJlZ2luIHdpdGggKm9wZW5saW1lLSo6XG4gKiBmb3IgaW5zdGFuY2UsIHRoZSBIT01FIGljb24gaXMgYSBTVkcgZWxlbWVudCB0YWdnZWQgd2l0aCBgY2xhc3M9XCJvcGVubGltZS1ob21lXCJgLiBcbiAqL1xuY2xhc3MgU2tpbiB7XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBVUkwgb2YgdGhlIFNWRyBza2luIGZpbGUuIEJ5IGRlZmF1bHQgaXQgaXMgKidza2luL3NraW4uc3ZnJyo7XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1IFRoZSBVUkwgb2YgdGhlIFNWRyBza2luIGZpbGUuXG5cdCAqL1xuXHRzdGF0aWMgc2V0VXJsKHUpIHsgdXJsID0gdTsgfVxuXG5cdC8qKlxuXHQgKiBMb2FkcyB0aGUgU1ZHIHNraW4gZmlsZSBhbmQgY29udmVydHMgaXQgaW50byBhIGdsb2JhbCBET00gU1ZHRWxlbWVudCByZWFkeSBmb3IgdXNlIGluIGEgd2ViIHBhZ2UuXG5cdCAqL1xuXHRzdGF0aWMgYXN5bmMgbG9hZFN2ZygpIHtcblx0XHR2YXIgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuXHRcdGlmICghcmVzcG9uc2Uub2spIHtcblx0XHRcdHRocm93IEVycm9yKFwiRmFpbGVkIGxvYWRpbmcgXCIgKyB1cmwgKyBcIjogXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcblx0XHRsZXQgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdHN2ZyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJpbWFnZS9zdmcreG1sXCIpLmRvY3VtZW50RWxlbWVudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBTVkcgZWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgQ1NTIGBzZWxlY3RvcmAuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBBIENTUyBzZWxlY3RvciAoZS5nLiBhIGNsYXNzIG5hbWUpLlxuXHQgKiBAcmV0dXJucyB7U1ZHRWxlbWVudH0gVGhlIFNWR0VsZW1lbnQgcmVmZXJlbmNlZCBieSB0aGUgc2VsZWN0b3IuXG5cdCAqL1xuXHRzdGF0aWMgYXN5bmMgZ2V0RWxlbWVudChzZWxlY3Rvcikge1xuXHRcdGlmICghc3ZnKVxuXHRcdFx0YXdhaXQgU2tpbi5sb2FkU3ZnKCk7XG5cdFx0cmV0dXJuIHN2Zy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKS5jbG9uZU5vZGUodHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc2VsZWN0ZWQgU1ZHIGVsZW1lbnQgdG8gdGhlIGBjb250YWluZXJgLlxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgQSBIVE1MIERPTSBub2RlLlxuXHQgKiBAcGFyYW0ge1NWR0VsZW1lbnR8c3RyaW5nfSBlbG0gQW4gU1ZHRWxlbWVudCBvciBhIENTUyBzZWxlY3RvciAoZS5nLiBhIGNsYXNzIG5hbWUpLlxuXHQgKiBAcmV0dXJucyB7U1ZHRWxlbWVudH0gQSBwb2ludGVyIHRvIHRoZSBTVkcgaWNvbiByZWZlcmVuY2VkIGJ5IHRoZSBlbG0uXG5cdCAqL1xuXHRzdGF0aWMgYXN5bmMgYXBwZW5kSWNvbihjb250YWluZXIsIGljb24pIHtcblx0XHRsZXQgZWxlbWVudCA9IG51bGw7XG5cdFx0aWYgKHR5cGVvZiBpY29uID09ICdzdHJpbmcnKSB7XG5cdFx0XHRlbGVtZW50ID0gYXdhaXQgU2tpbi5nZXRFbGVtZW50KGljb24pO1xuXHRcdFx0aWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG5cdFx0XHRpY29uLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGljb24pO1xuXHRcdFx0bGV0IGJveCA9IGVsZW1lbnQuZ2V0QkJveCgpO1xuXHRcdFx0bGV0IHRsaXN0ID0gZWxlbWVudC50cmFuc2Zvcm0uYmFzZVZhbDtcblx0XHRcdGlmICh0bGlzdC5udW1iZXJPZkl0ZW1zID09IDApXG5cdFx0XHRcdHRsaXN0LmFwcGVuZEl0ZW0oaWNvbi5jcmVhdGVTVkdUcmFuc2Zvcm0oKSk7XG5cdFx0XHR0bGlzdC5nZXRJdGVtKDApLnNldFRyYW5zbGF0ZSgtYm94LngsIC1ib3gueSk7XG5cdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIGAkey1wYWR9ICR7LXBhZH0gJHtib3gud2lkdGggKyAyICogcGFkfSAke2JveC5oZWlnaHQgKyAyICogcGFkfWApO1xuXHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoaWNvbik7XG5cdFx0XHRsZXQgYm94ID0gaWNvbi5nZXRCQm94KCk7XG5cdFx0XHRpY29uLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIGAkey1wYWR9ICR7LXBhZH0gJHtib3gud2lkdGggKyAyICogcGFkfSAke2JveC5oZWlnaHQgKyAyICogcGFkfWApO1xuXHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gaWNvbjtcblx0IH1cbn1cblxuZXhwb3J0IHsgU2tpbiB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Skin.js\n");

/***/ }),

/***/ "./src/Tile.js":
/*!*********************!*\
  !*** ./src/Tile.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tile\": () => (/* binding */ Tile)\n/* harmony export */ });\n// Tile level x y  index ----- tex missing() start/end (tarzoom) ----- time, priority size(byte)\n\n/**\n * A tile represents a single element of a regular grid that subdivides an image.\n * A tile is identified by its position (`x`, `y`) within the grid and the zoom `level` of the image.\n * @typedef {Object} Tile\n * @property {number} level The zoom level of the tile.\n * @property {number} x x position of the tile in the grid.\n * @property {number} y y position of the tile in the grid.\n * @property {number} index Unique tile identifier.\n * @property {number} start The position of the first byte of the tile in the image dataset (used only for tarzoom and itarzoom image formats).\n * @property {number} end The position of the last byte of the tile in the image dataset (used only for tarzoom and itarzoom image formats).\n * @property {number} missing In the case of multi-channel formats (RTI, BRDF), the information content of a tile is distributed over several planes (channels). \n * `missing` represents the number of pending channel data requests.\n * @property {Array} tex A array of WebGLTexture (one texture per channel).\n * @property {time} time Tile creation time (this value is used internally by the cache algorithms).\n * @property {number} priority The priority of the tile (this value is used internally by the cache algorithms).\n * @property {number} size The total size of the tile in bytes (this value is used internally by the cache algorithms).\n */\n\nclass Tile {\n    constructor() {\n        Object.assign(this, {\n            index: null, \n            bbox: null,\n\n            level: null, //used only in LayoutTiles\n            x: null,\n            y: null,\n            w: null, // used only in LayoutImages\n            h: null, // used only in LayoutImages\n\n            start:null,\n            end:null,\n\n            tex: [],\n            missing: null,\n            time: null,\n            priority: null,\n            size: null\n        });\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVGlsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9UaWxlLmpzPzcxZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGlsZSBsZXZlbCB4IHkgIGluZGV4IC0tLS0tIHRleCBtaXNzaW5nKCkgc3RhcnQvZW5kICh0YXJ6b29tKSAtLS0tLSB0aW1lLCBwcmlvcml0eSBzaXplKGJ5dGUpXG5cbi8qKlxuICogQSB0aWxlIHJlcHJlc2VudHMgYSBzaW5nbGUgZWxlbWVudCBvZiBhIHJlZ3VsYXIgZ3JpZCB0aGF0IHN1YmRpdmlkZXMgYW4gaW1hZ2UuXG4gKiBBIHRpbGUgaXMgaWRlbnRpZmllZCBieSBpdHMgcG9zaXRpb24gKGB4YCwgYHlgKSB3aXRoaW4gdGhlIGdyaWQgYW5kIHRoZSB6b29tIGBsZXZlbGAgb2YgdGhlIGltYWdlLlxuICogQHR5cGVkZWYge09iamVjdH0gVGlsZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsIFRoZSB6b29tIGxldmVsIG9mIHRoZSB0aWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggeCBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIHRpbGUgaW4gdGhlIGdyaWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggVW5pcXVlIHRpbGUgaWRlbnRpZmllci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHRpbGUgaW4gdGhlIGltYWdlIGRhdGFzZXQgKHVzZWQgb25seSBmb3IgdGFyem9vbSBhbmQgaXRhcnpvb20gaW1hZ2UgZm9ybWF0cykuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZW5kIFRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBieXRlIG9mIHRoZSB0aWxlIGluIHRoZSBpbWFnZSBkYXRhc2V0ICh1c2VkIG9ubHkgZm9yIHRhcnpvb20gYW5kIGl0YXJ6b29tIGltYWdlIGZvcm1hdHMpLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pc3NpbmcgSW4gdGhlIGNhc2Ugb2YgbXVsdGktY2hhbm5lbCBmb3JtYXRzIChSVEksIEJSREYpLCB0aGUgaW5mb3JtYXRpb24gY29udGVudCBvZiBhIHRpbGUgaXMgZGlzdHJpYnV0ZWQgb3ZlciBzZXZlcmFsIHBsYW5lcyAoY2hhbm5lbHMpLiBcbiAqIGBtaXNzaW5nYCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgcGVuZGluZyBjaGFubmVsIGRhdGEgcmVxdWVzdHMuXG4gKiBAcHJvcGVydHkge0FycmF5fSB0ZXggQSBhcnJheSBvZiBXZWJHTFRleHR1cmUgKG9uZSB0ZXh0dXJlIHBlciBjaGFubmVsKS5cbiAqIEBwcm9wZXJ0eSB7dGltZX0gdGltZSBUaWxlIGNyZWF0aW9uIHRpbWUgKHRoaXMgdmFsdWUgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBjYWNoZSBhbGdvcml0aG1zKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmlvcml0eSBUaGUgcHJpb3JpdHkgb2YgdGhlIHRpbGUgKHRoaXMgdmFsdWUgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBjYWNoZSBhbGdvcml0aG1zKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIFRoZSB0b3RhbCBzaXplIG9mIHRoZSB0aWxlIGluIGJ5dGVzICh0aGlzIHZhbHVlIGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgY2FjaGUgYWxnb3JpdGhtcykuXG4gKi9cblxuY2xhc3MgVGlsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgaW5kZXg6IG51bGwsIFxuICAgICAgICAgICAgYmJveDogbnVsbCxcblxuICAgICAgICAgICAgbGV2ZWw6IG51bGwsIC8vdXNlZCBvbmx5IGluIExheW91dFRpbGVzXG4gICAgICAgICAgICB4OiBudWxsLFxuICAgICAgICAgICAgeTogbnVsbCxcbiAgICAgICAgICAgIHc6IG51bGwsIC8vIHVzZWQgb25seSBpbiBMYXlvdXRJbWFnZXNcbiAgICAgICAgICAgIGg6IG51bGwsIC8vIHVzZWQgb25seSBpbiBMYXlvdXRJbWFnZXNcblxuICAgICAgICAgICAgc3RhcnQ6bnVsbCxcbiAgICAgICAgICAgIGVuZDpudWxsLFxuXG4gICAgICAgICAgICB0ZXg6IFtdLFxuICAgICAgICAgICAgbWlzc2luZzogbnVsbCxcbiAgICAgICAgICAgIHRpbWU6IG51bGwsXG4gICAgICAgICAgICBwcmlvcml0eTogbnVsbCxcbiAgICAgICAgICAgIHNpemU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgVGlsZSB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Tile.js\n");

/***/ }),

/***/ "./src/Transform.js":
/*!**************************!*\
  !*** ./src/Transform.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Transform\": () => (/* binding */ Transform)\n/* harmony export */ });\n/* harmony import */ var _BoundingBox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox */ \"./src/BoundingBox.js\");\n\n\n/**\n * A [x, y] point.\n * @typedef APoint\n * @property {number} p.0 The x-coordinate.\n * @property {number} p.1 The y-coordinate.\n */\n\n/**\n * A {x, y} point.\n * @typedef {Object} Point\n * @property {number} x The x-coordinate.\n * @property {number} y The y-coordinate.\n */\n\n/**\n * The class **Transform** implements a 2D affine map to convert coordinates between two systems.\n * The map is internally represented by four values:\n * * `x` the x-component of the translation vector\n * * `y` the y-component of the translation vector\n * * `a` the rotation angle around the z-axis (in degrees)\n * * `z` the scale factor\n * \n * A transformation between a point P to P' is defined by\n * ```\n * P' = z*rot(a)*P + t\n * ```\n * where `z` is the scale factor, `a` is the rotation angle, and `t(x,y)` is the translation vector.\n * \n * The class implements a set of geometric transformations useful to position the camera, create animations, etc... \n */\n\nclass Transform { //FIXME Add translation to P?\n\t/**\n\t * Instantiates a Transform object.\n\t * @param {Object} [options] An object literal with Transform parameters.\n\t * @param {number} options.x=0 The x-component of the translation vector.\n\t * @param {number} options.y=0 The y-component of the translation vector.\n\t * @param {number} options.a=0 The rotation angle (in degrees).\n\t * @param {number} options.z=1 The scale factor.\n\t * @param {time} options.t=0 The current time.\n\t */\n\tconstructor(options) {\n\t\tObject.assign(this, { x:0, y:0, z:1, a:0, t:0 });\n\n\t\tif(!this.t) this.t = performance.now();\n\t\t\n\t\tif(typeof(options) == 'object')\n\t\t\tObject.assign(this, options);\n\t}\n\n\t/**\n\t * Gets a copy of `this` Transform.\n\t * @returns {Transform} The copy of the Transform.\n\t */\n\tcopy() {\n\t\tlet transform = new Transform();\n\t\tObject.assign(transform, this);\n\t\treturn transform;\n\t}\n\n\t/**\n\t * Applies `this` Transform to a point P(x,y) to get P'(x',y').\n\t * @param {number} x x-coordinate of the point P.\n\t * @param {number} y y-coordinate of the point P.\n\t * @returns {{x, y}} The point P'.\n\t */\n\tapply(x, y) {\n\t\t//TODO! ROTATE\n\t\tlet r = Transform.rotate(x, y, this.a);\n\t\treturn { \n\t\t\tx: r.x*this.z + this.x,\n\t\t\ty: r.y*this.z + this.y\n\t\t}\n\t}\n\n\t/**\n\t * Computes the inverse of `this` Transform.\n\t * @returns {Transform} The inverse Transform.\n\t */\n\tinverse() {\n\t\tlet r = Transform.rotate(this.x/this.z, this.y/this.z, -this.a);\n\t\treturn new Transform({x:-r.x, y:-r.y, z:1/this.z, a:-this.a, t:this.t});\n\t}\n\n\t/**\n\t * Maps an angle `a` to range from 0 to 360 degrees.\n\t * @param {number} a The angle (in degrees).\n\t * @returns {number} The normalized angle.\n\t */\n\tstatic normalizeAngle(a) {\n\t\twhile(a > 360) a -= 360;\n\t\twhile(a < 0) a += 360;\n\t\treturn a;\n\t}\n\n\t/**\n\t * Computes the rotation of a point P(x,y) by an angle `a` around the z-axis to get P'(x',y').\n\t * @param {*} x x-coordinate of the point P.\n\t * @param {*} y y-coordinate of the point P.\n\t * @param {*} a The rotation angle (in degrees)\n\t * @returns {{x,y}} The point P'.\n\t */\n\tstatic rotate(x, y, a) {\n\t\ta = Math.PI*(a/180);\n\t\tlet ex =  Math.cos(a)*x - Math.sin(a)*y;\n\t\tlet ey =  Math.sin(a)*x + Math.cos(a)*y;\n\t\treturn {x:ex, y:ey};\n\t}\n\n\t// first get applied this (a) then  transform (b).\n\t/**\n\t * Composes (multiplies) `this` Transform with an other `transform`.\n\t * @param {Transform} transform \n\t * @returns {Transform} The result of the composition.\n\t */\n\tcompose(transform) {\n\t\tlet a = this.copy();\n\t\tlet b = transform;\n\t\ta.z *= b.z;\n\t\ta.a += b.a;\n\t\tvar r = Transform.rotate(a.x, a.y, b.a);\n\t\ta.x = r.x*b.z + b.x;\n\t\ta.y = r.y*b.z + b.y; \n\t\treturn a;\n\t}\n\n\t/**\n\t * Applyes `this` Transform to a bounding box.\n\t * @param {BoundingBox} lbox \n\t * @returns {BoundingBox} The result.\n\t */\n\ttransformBox(lbox) {\n\t\tlet box = new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\n\t\tfor(let i = 0; i < 4; i++) {\n\t\t\tlet c = lbox.corner(i);\n\t\t\tlet p = this.apply(c.x, c.y);\n\t\t\tbox.mergePoint(p);\n\t\t}\n\t\treturn box;\n\t}\n\n\t/**\n\t * Gets the bounding box (in image coordinate space) of the vieport. The viewport y-axis points up.\n\t * The image and screen transform has y pointing down.\n\t * @param {Viewport} viewport \n\t * @returns {BoundingBox} The bounding box.\n\t */\n\tgetInverseBox(viewport) {\n\t\tlet inverse = this.inverse();\n\t\tlet corners = [\n\t\t\t{x:viewport.x,               y:viewport.y},\n\t\t\t{x:viewport.x + viewport.dx, y:viewport.y},\n\t\t\t{x:viewport.x,               y:viewport.y + viewport.dy},\n\t\t\t{x:viewport.x + viewport.dx, y:viewport.y + viewport.dy}\n\t\t];\n\t\tlet box = new _BoundingBox__WEBPACK_IMPORTED_MODULE_0__.BoundingBox();\n\t\tfor(let corner of corners) {\n\t\t\tlet p = inverse.apply(corner.x -viewport.w/2, -corner.y + viewport.h/2);\n\t\t\tbox.mergePoint(p);\n\t\t}\n\t\treturn box;\n\t}\n\n\t/**\n\t* The type Easing defines the function that regulates the movement of the camera\n\t* @typedef {('linear'|'ease-out'|'ease-in-out')} Transform#Easing\n\t*/\n\n\t/**\n\t * Computes the interpolated transform at time `time` between `source` and `target` \n\t * @param {Transform} source The source transform.\n\t * @param {Transform} target The target transform.\n\t * @param {time} time The time at which to compute the interpolation.\n\t * @param {Transform#Easing} easing The easing function.\n\t * @returns {Transform} The interpolated transform.\n\t */\n\tstatic interpolate(source, target, time, easing) { //FIXME STATIC\n\t\tconst pos = new Transform();\n\t\tlet dt = (target.t - source.t);\n\t\tif (time < source.t) {\n\t\t\tObject.assign(pos, source);\n\t\t} else if (time > target.t || dt < 0.001) {\n\t\t\tObject.assign(pos, target);\n\t\t} else {\n\t\t\tlet tt = (time - source.t) / dt;\n\t\t\tswitch (easing) {\n\t\t\t\tcase 'ease-out': tt = 1 - Math.pow(1 - tt, 2); break;\n\t\t\t\tcase 'ease-in-out': tt = tt < 0.5 ? 2 * tt * tt : 1 - Math.pow(-2 * tt + 2, 2) / 2; break;\n\t\t\t}\n\t\t\tlet st = 1 - tt;\n\t\t\tfor (let i of ['x', 'y', 'z', 'a'])\n\t\t\t\tpos[i] = (st * source[i] + tt * target[i]);\n\t\t}\n\t\tpos.t = time;\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Combines `this` Transform with the viewport to get the WebGL projection matrix.\n\t * @param {Viewport} viewport The viewport. \n\t * @returns {number[]} The result.\n\t */\n\tprojectionMatrix(viewport) {\n\t\tlet z = this.z;\n\n\t\t// In coords with 0 in lower left corner map x0 to -1, and x0+v.w to 1\n\t\t// In coords with 0 at screen center and x0 at 0, map -v.w/2 -> -1, v.w/2 -> 1 \n\t\t// With x0 != 0: x0 -> x0-v.w/2 -> -1, and x0+dx -> x0+v.dx-v.w/2 -> 1\n\t\t// Where dx is viewport width, while w is window width\n\t\t//0, 0 <-> viewport.x + viewport.dx/2 (if x, y =\n\t\t\n\t\tlet zx = 2/viewport.dx;\n\t\tlet zy = 2/viewport.dy;\n\n\t\tlet dx =  zx * this.x + (2/viewport.dx)*(viewport.w/2-viewport.x)-1;\n\t\tlet dy =  zy * this.y + (2/viewport.dy)*(viewport.h/2-viewport.y)-1;\n\n\t\tlet a = Math.PI *this.a/180;\n\t\tlet matrix = [\n\t\t\t Math.cos(a)*zx*z, Math.sin(a)*zy*z,  0,  0, \n\t\t\t-Math.sin(a)*zx*z, Math.cos(a)*zy*z,  0,  0,\n\t\t\t 0,  0,  1,  0,\n\t\t\tdx, dy, 0,  1];\n\t\treturn matrix;\n\t}\n\n    /**\n\t * Transforms the point `p` from scene (0 at image center) to [0,wh]  .\n\t * @param {Viewport} viewport The viewport.\n\t * @param {APoint} p The point in scene (0,0 at image center)\n\t * @returns {APoint} The point in range [0..w-1,0..h-1]\n\t */ \n\tsceneToViewportCoords(viewport, p) { //FIXME Point is an array, but in other places it is an Object...\n        return [p[0] * this.z  + this.x - viewport.x + viewport.w/2, \n                p[1] * this.z  - this.y + viewport.y + viewport.h/2 ];\n    }\n\n\t/**\n     * Transforms the point `p` from [0,wh] to scene (0 at image center).\n\t * \n\t * @param {Viewport} viewport The viewport.\n\t * @param {APoint} p The point in range [0..w-1,0..h-1]\n\t * @returns {APoint} The point in scene (0,0 at image center)\n\t */\n    viewportToSceneCoords(viewport, p) {\n        return [(p[0] + viewport.x - viewport.w/2 - this.x) / this.z,\n                (p[1] - viewport.y - viewport.h/2 + this.y) / this.z];\n    }\n\n\tprint(str=\"\", precision=0) {\n    \tconst p = precision;\n    \tconsole.log(str + \" x:\" + this.x.toFixed(p) + \", y:\" + this.y.toFixed(p) + \", z:\" + this.z.toFixed(p) + \", a:\" + this.a.toFixed(p) + \", t:\" + this.t.toFixed(p));\n\t}\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVubGltZS8uL3NyYy9UcmFuc2Zvcm0uanM/MzljZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gXCIuL0JvdW5kaW5nQm94XCI7XG5cbi8qKlxuICogQSBbeCwgeV0gcG9pbnQuXG4gKiBAdHlwZWRlZiBBUG9pbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwLjAgVGhlIHgtY29vcmRpbmF0ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwLjEgVGhlIHktY29vcmRpbmF0ZS5cbiAqL1xuXG4vKipcbiAqIEEge3gsIHl9IHBvaW50LlxuICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4LWNvb3JkaW5hdGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeS1jb29yZGluYXRlLlxuICovXG5cbi8qKlxuICogVGhlIGNsYXNzICoqVHJhbnNmb3JtKiogaW1wbGVtZW50cyBhIDJEIGFmZmluZSBtYXAgdG8gY29udmVydCBjb29yZGluYXRlcyBiZXR3ZWVuIHR3byBzeXN0ZW1zLlxuICogVGhlIG1hcCBpcyBpbnRlcm5hbGx5IHJlcHJlc2VudGVkIGJ5IGZvdXIgdmFsdWVzOlxuICogKiBgeGAgdGhlIHgtY29tcG9uZW50IG9mIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcbiAqICogYHlgIHRoZSB5LWNvbXBvbmVudCBvZiB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAqIGBhYCB0aGUgcm90YXRpb24gYW5nbGUgYXJvdW5kIHRoZSB6LWF4aXMgKGluIGRlZ3JlZXMpXG4gKiAqIGB6YCB0aGUgc2NhbGUgZmFjdG9yXG4gKiBcbiAqIEEgdHJhbnNmb3JtYXRpb24gYmV0d2VlbiBhIHBvaW50IFAgdG8gUCcgaXMgZGVmaW5lZCBieVxuICogYGBgXG4gKiBQJyA9IHoqcm90KGEpKlAgKyB0XG4gKiBgYGBcbiAqIHdoZXJlIGB6YCBpcyB0aGUgc2NhbGUgZmFjdG9yLCBgYWAgaXMgdGhlIHJvdGF0aW9uIGFuZ2xlLCBhbmQgYHQoeCx5KWAgaXMgdGhlIHRyYW5zbGF0aW9uIHZlY3Rvci5cbiAqIFxuICogVGhlIGNsYXNzIGltcGxlbWVudHMgYSBzZXQgb2YgZ2VvbWV0cmljIHRyYW5zZm9ybWF0aW9ucyB1c2VmdWwgdG8gcG9zaXRpb24gdGhlIGNhbWVyYSwgY3JlYXRlIGFuaW1hdGlvbnMsIGV0Yy4uLiBcbiAqL1xuXG5jbGFzcyBUcmFuc2Zvcm0geyAvL0ZJWE1FIEFkZCB0cmFuc2xhdGlvbiB0byBQP1xuXHQvKipcblx0ICogSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIFRyYW5zZm9ybSBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54PTAgVGhlIHgtY29tcG9uZW50IG9mIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnk9MCBUaGUgeS1jb21wb25lbnQgb2YgdGhlIHRyYW5zbGF0aW9uIHZlY3Rvci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYT0wIFRoZSByb3RhdGlvbiBhbmdsZSAoaW4gZGVncmVlcykuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLno9MSBUaGUgc2NhbGUgZmFjdG9yLlxuXHQgKiBAcGFyYW0ge3RpbWV9IG9wdGlvbnMudD0wIFRoZSBjdXJyZW50IHRpbWUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7IHg6MCwgeTowLCB6OjEsIGE6MCwgdDowIH0pO1xuXG5cdFx0aWYoIXRoaXMudCkgdGhpcy50ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XG5cdFx0aWYodHlwZW9mKG9wdGlvbnMpID09ICdvYmplY3QnKVxuXHRcdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgY29weSBvZiBgdGhpc2AgVHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJucyB7VHJhbnNmb3JtfSBUaGUgY29weSBvZiB0aGUgVHJhbnNmb3JtLlxuXHQgKi9cblx0Y29weSgpIHtcblx0XHRsZXQgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpO1xuXHRcdE9iamVjdC5hc3NpZ24odHJhbnNmb3JtLCB0aGlzKTtcblx0XHRyZXR1cm4gdHJhbnNmb3JtO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYHRoaXNgIFRyYW5zZm9ybSB0byBhIHBvaW50IFAoeCx5KSB0byBnZXQgUCcoeCcseScpLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCB4LWNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IFAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IHktY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgUC5cblx0ICogQHJldHVybnMge3t4LCB5fX0gVGhlIHBvaW50IFAnLlxuXHQgKi9cblx0YXBwbHkoeCwgeSkge1xuXHRcdC8vVE9ETyEgUk9UQVRFXG5cdFx0bGV0IHIgPSBUcmFuc2Zvcm0ucm90YXRlKHgsIHksIHRoaXMuYSk7XG5cdFx0cmV0dXJuIHsgXG5cdFx0XHR4OiByLngqdGhpcy56ICsgdGhpcy54LFxuXHRcdFx0eTogci55KnRoaXMueiArIHRoaXMueVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgaW52ZXJzZSBvZiBgdGhpc2AgVHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJucyB7VHJhbnNmb3JtfSBUaGUgaW52ZXJzZSBUcmFuc2Zvcm0uXG5cdCAqL1xuXHRpbnZlcnNlKCkge1xuXHRcdGxldCByID0gVHJhbnNmb3JtLnJvdGF0ZSh0aGlzLngvdGhpcy56LCB0aGlzLnkvdGhpcy56LCAtdGhpcy5hKTtcblx0XHRyZXR1cm4gbmV3IFRyYW5zZm9ybSh7eDotci54LCB5Oi1yLnksIHo6MS90aGlzLnosIGE6LXRoaXMuYSwgdDp0aGlzLnR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXBzIGFuIGFuZ2xlIGBhYCB0byByYW5nZSBmcm9tIDAgdG8gMzYwIGRlZ3JlZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBhbmdsZSAoaW4gZGVncmVlcykuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBub3JtYWxpemVkIGFuZ2xlLlxuXHQgKi9cblx0c3RhdGljIG5vcm1hbGl6ZUFuZ2xlKGEpIHtcblx0XHR3aGlsZShhID4gMzYwKSBhIC09IDM2MDtcblx0XHR3aGlsZShhIDwgMCkgYSArPSAzNjA7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblxuXHQvKipcblx0ICogQ29tcHV0ZXMgdGhlIHJvdGF0aW9uIG9mIGEgcG9pbnQgUCh4LHkpIGJ5IGFuIGFuZ2xlIGBhYCBhcm91bmQgdGhlIHotYXhpcyB0byBnZXQgUCcoeCcseScpLlxuXHQgKiBAcGFyYW0geyp9IHggeC1jb29yZGluYXRlIG9mIHRoZSBwb2ludCBQLlxuXHQgKiBAcGFyYW0geyp9IHkgeS1jb29yZGluYXRlIG9mIHRoZSBwb2ludCBQLlxuXHQgKiBAcGFyYW0geyp9IGEgVGhlIHJvdGF0aW9uIGFuZ2xlIChpbiBkZWdyZWVzKVxuXHQgKiBAcmV0dXJucyB7e3gseX19IFRoZSBwb2ludCBQJy5cblx0ICovXG5cdHN0YXRpYyByb3RhdGUoeCwgeSwgYSkge1xuXHRcdGEgPSBNYXRoLlBJKihhLzE4MCk7XG5cdFx0bGV0IGV4ID0gIE1hdGguY29zKGEpKnggLSBNYXRoLnNpbihhKSp5O1xuXHRcdGxldCBleSA9ICBNYXRoLnNpbihhKSp4ICsgTWF0aC5jb3MoYSkqeTtcblx0XHRyZXR1cm4ge3g6ZXgsIHk6ZXl9O1xuXHR9XG5cblx0Ly8gZmlyc3QgZ2V0IGFwcGxpZWQgdGhpcyAoYSkgdGhlbiAgdHJhbnNmb3JtIChiKS5cblx0LyoqXG5cdCAqIENvbXBvc2VzIChtdWx0aXBsaWVzKSBgdGhpc2AgVHJhbnNmb3JtIHdpdGggYW4gb3RoZXIgYHRyYW5zZm9ybWAuXG5cdCAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm0gXG5cdCAqIEByZXR1cm5zIHtUcmFuc2Zvcm19IFRoZSByZXN1bHQgb2YgdGhlIGNvbXBvc2l0aW9uLlxuXHQgKi9cblx0Y29tcG9zZSh0cmFuc2Zvcm0pIHtcblx0XHRsZXQgYSA9IHRoaXMuY29weSgpO1xuXHRcdGxldCBiID0gdHJhbnNmb3JtO1xuXHRcdGEueiAqPSBiLno7XG5cdFx0YS5hICs9IGIuYTtcblx0XHR2YXIgciA9IFRyYW5zZm9ybS5yb3RhdGUoYS54LCBhLnksIGIuYSk7XG5cdFx0YS54ID0gci54KmIueiArIGIueDtcblx0XHRhLnkgPSByLnkqYi56ICsgYi55OyBcblx0XHRyZXR1cm4gYTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBseWVzIGB0aGlzYCBUcmFuc2Zvcm0gdG8gYSBib3VuZGluZyBib3guXG5cdCAqIEBwYXJhbSB7Qm91bmRpbmdCb3h9IGxib3ggXG5cdCAqIEByZXR1cm5zIHtCb3VuZGluZ0JveH0gVGhlIHJlc3VsdC5cblx0ICovXG5cdHRyYW5zZm9ybUJveChsYm94KSB7XG5cdFx0bGV0IGJveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdGxldCBjID0gbGJveC5jb3JuZXIoaSk7XG5cdFx0XHRsZXQgcCA9IHRoaXMuYXBwbHkoYy54LCBjLnkpO1xuXHRcdFx0Ym94Lm1lcmdlUG9pbnQocCk7XG5cdFx0fVxuXHRcdHJldHVybiBib3g7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgYm91bmRpbmcgYm94IChpbiBpbWFnZSBjb29yZGluYXRlIHNwYWNlKSBvZiB0aGUgdmllcG9ydC4gVGhlIHZpZXdwb3J0IHktYXhpcyBwb2ludHMgdXAuXG5cdCAqIFRoZSBpbWFnZSBhbmQgc2NyZWVuIHRyYW5zZm9ybSBoYXMgeSBwb2ludGluZyBkb3duLlxuXHQgKiBAcGFyYW0ge1ZpZXdwb3J0fSB2aWV3cG9ydCBcblx0ICogQHJldHVybnMge0JvdW5kaW5nQm94fSBUaGUgYm91bmRpbmcgYm94LlxuXHQgKi9cblx0Z2V0SW52ZXJzZUJveCh2aWV3cG9ydCkge1xuXHRcdGxldCBpbnZlcnNlID0gdGhpcy5pbnZlcnNlKCk7XG5cdFx0bGV0IGNvcm5lcnMgPSBbXG5cdFx0XHR7eDp2aWV3cG9ydC54LCAgICAgICAgICAgICAgIHk6dmlld3BvcnQueX0sXG5cdFx0XHR7eDp2aWV3cG9ydC54ICsgdmlld3BvcnQuZHgsIHk6dmlld3BvcnQueX0sXG5cdFx0XHR7eDp2aWV3cG9ydC54LCAgICAgICAgICAgICAgIHk6dmlld3BvcnQueSArIHZpZXdwb3J0LmR5fSxcblx0XHRcdHt4OnZpZXdwb3J0LnggKyB2aWV3cG9ydC5keCwgeTp2aWV3cG9ydC55ICsgdmlld3BvcnQuZHl9XG5cdFx0XTtcblx0XHRsZXQgYm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG5cdFx0Zm9yKGxldCBjb3JuZXIgb2YgY29ybmVycykge1xuXHRcdFx0bGV0IHAgPSBpbnZlcnNlLmFwcGx5KGNvcm5lci54IC12aWV3cG9ydC53LzIsIC1jb3JuZXIueSArIHZpZXdwb3J0LmgvMik7XG5cdFx0XHRib3gubWVyZ2VQb2ludChwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJveDtcblx0fVxuXG5cdC8qKlxuXHQqIFRoZSB0eXBlIEVhc2luZyBkZWZpbmVzIHRoZSBmdW5jdGlvbiB0aGF0IHJlZ3VsYXRlcyB0aGUgbW92ZW1lbnQgb2YgdGhlIGNhbWVyYVxuXHQqIEB0eXBlZGVmIHsoJ2xpbmVhcid8J2Vhc2Utb3V0J3wnZWFzZS1pbi1vdXQnKX0gVHJhbnNmb3JtI0Vhc2luZ1xuXHQqL1xuXG5cdC8qKlxuXHQgKiBDb21wdXRlcyB0aGUgaW50ZXJwb2xhdGVkIHRyYW5zZm9ybSBhdCB0aW1lIGB0aW1lYCBiZXR3ZWVuIGBzb3VyY2VgIGFuZCBgdGFyZ2V0YCBcblx0ICogQHBhcmFtIHtUcmFuc2Zvcm19IHNvdXJjZSBUaGUgc291cmNlIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtUcmFuc2Zvcm19IHRhcmdldCBUaGUgdGFyZ2V0IHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHt0aW1lfSB0aW1lIFRoZSB0aW1lIGF0IHdoaWNoIHRvIGNvbXB1dGUgdGhlIGludGVycG9sYXRpb24uXG5cdCAqIEBwYXJhbSB7VHJhbnNmb3JtI0Vhc2luZ30gZWFzaW5nIFRoZSBlYXNpbmcgZnVuY3Rpb24uXG5cdCAqIEByZXR1cm5zIHtUcmFuc2Zvcm19IFRoZSBpbnRlcnBvbGF0ZWQgdHJhbnNmb3JtLlxuXHQgKi9cblx0c3RhdGljIGludGVycG9sYXRlKHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBlYXNpbmcpIHsgLy9GSVhNRSBTVEFUSUNcblx0XHRjb25zdCBwb3MgPSBuZXcgVHJhbnNmb3JtKCk7XG5cdFx0bGV0IGR0ID0gKHRhcmdldC50IC0gc291cmNlLnQpO1xuXHRcdGlmICh0aW1lIDwgc291cmNlLnQpIHtcblx0XHRcdE9iamVjdC5hc3NpZ24ocG9zLCBzb3VyY2UpO1xuXHRcdH0gZWxzZSBpZiAodGltZSA+IHRhcmdldC50IHx8IGR0IDwgMC4wMDEpIHtcblx0XHRcdE9iamVjdC5hc3NpZ24ocG9zLCB0YXJnZXQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgdHQgPSAodGltZSAtIHNvdXJjZS50KSAvIGR0O1xuXHRcdFx0c3dpdGNoIChlYXNpbmcpIHtcblx0XHRcdFx0Y2FzZSAnZWFzZS1vdXQnOiB0dCA9IDEgLSBNYXRoLnBvdygxIC0gdHQsIDIpOyBicmVhaztcblx0XHRcdFx0Y2FzZSAnZWFzZS1pbi1vdXQnOiB0dCA9IHR0IDwgMC41ID8gMiAqIHR0ICogdHQgOiAxIC0gTWF0aC5wb3coLTIgKiB0dCArIDIsIDIpIC8gMjsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRsZXQgc3QgPSAxIC0gdHQ7XG5cdFx0XHRmb3IgKGxldCBpIG9mIFsneCcsICd5JywgJ3onLCAnYSddKVxuXHRcdFx0XHRwb3NbaV0gPSAoc3QgKiBzb3VyY2VbaV0gKyB0dCAqIHRhcmdldFtpXSk7XG5cdFx0fVxuXHRcdHBvcy50ID0gdGltZTtcblx0XHRyZXR1cm4gcG9zO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbWJpbmVzIGB0aGlzYCBUcmFuc2Zvcm0gd2l0aCB0aGUgdmlld3BvcnQgdG8gZ2V0IHRoZSBXZWJHTCBwcm9qZWN0aW9uIG1hdHJpeC5cblx0ICogQHBhcmFtIHtWaWV3cG9ydH0gdmlld3BvcnQgVGhlIHZpZXdwb3J0LiBcblx0ICogQHJldHVybnMge251bWJlcltdfSBUaGUgcmVzdWx0LlxuXHQgKi9cblx0cHJvamVjdGlvbk1hdHJpeCh2aWV3cG9ydCkge1xuXHRcdGxldCB6ID0gdGhpcy56O1xuXG5cdFx0Ly8gSW4gY29vcmRzIHdpdGggMCBpbiBsb3dlciBsZWZ0IGNvcm5lciBtYXAgeDAgdG8gLTEsIGFuZCB4MCt2LncgdG8gMVxuXHRcdC8vIEluIGNvb3JkcyB3aXRoIDAgYXQgc2NyZWVuIGNlbnRlciBhbmQgeDAgYXQgMCwgbWFwIC12LncvMiAtPiAtMSwgdi53LzIgLT4gMSBcblx0XHQvLyBXaXRoIHgwICE9IDA6IHgwIC0+IHgwLXYudy8yIC0+IC0xLCBhbmQgeDArZHggLT4geDArdi5keC12LncvMiAtPiAxXG5cdFx0Ly8gV2hlcmUgZHggaXMgdmlld3BvcnQgd2lkdGgsIHdoaWxlIHcgaXMgd2luZG93IHdpZHRoXG5cdFx0Ly8wLCAwIDwtPiB2aWV3cG9ydC54ICsgdmlld3BvcnQuZHgvMiAoaWYgeCwgeSA9XG5cdFx0XG5cdFx0bGV0IHp4ID0gMi92aWV3cG9ydC5keDtcblx0XHRsZXQgenkgPSAyL3ZpZXdwb3J0LmR5O1xuXG5cdFx0bGV0IGR4ID0gIHp4ICogdGhpcy54ICsgKDIvdmlld3BvcnQuZHgpKih2aWV3cG9ydC53LzItdmlld3BvcnQueCktMTtcblx0XHRsZXQgZHkgPSAgenkgKiB0aGlzLnkgKyAoMi92aWV3cG9ydC5keSkqKHZpZXdwb3J0LmgvMi12aWV3cG9ydC55KS0xO1xuXG5cdFx0bGV0IGEgPSBNYXRoLlBJICp0aGlzLmEvMTgwO1xuXHRcdGxldCBtYXRyaXggPSBbXG5cdFx0XHQgTWF0aC5jb3MoYSkqengqeiwgTWF0aC5zaW4oYSkqenkqeiwgIDAsICAwLCBcblx0XHRcdC1NYXRoLnNpbihhKSp6eCp6LCBNYXRoLmNvcyhhKSp6eSp6LCAgMCwgIDAsXG5cdFx0XHQgMCwgIDAsICAxLCAgMCxcblx0XHRcdGR4LCBkeSwgMCwgIDFdO1xuXHRcdHJldHVybiBtYXRyaXg7XG5cdH1cblxuICAgIC8qKlxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBwb2ludCBgcGAgZnJvbSBzY2VuZSAoMCBhdCBpbWFnZSBjZW50ZXIpIHRvIFswLHdoXSAgLlxuXHQgKiBAcGFyYW0ge1ZpZXdwb3J0fSB2aWV3cG9ydCBUaGUgdmlld3BvcnQuXG5cdCAqIEBwYXJhbSB7QVBvaW50fSBwIFRoZSBwb2ludCBpbiBzY2VuZSAoMCwwIGF0IGltYWdlIGNlbnRlcilcblx0ICogQHJldHVybnMge0FQb2ludH0gVGhlIHBvaW50IGluIHJhbmdlIFswLi53LTEsMC4uaC0xXVxuXHQgKi8gXG5cdHNjZW5lVG9WaWV3cG9ydENvb3Jkcyh2aWV3cG9ydCwgcCkgeyAvL0ZJWE1FIFBvaW50IGlzIGFuIGFycmF5LCBidXQgaW4gb3RoZXIgcGxhY2VzIGl0IGlzIGFuIE9iamVjdC4uLlxuICAgICAgICByZXR1cm4gW3BbMF0gKiB0aGlzLnogICsgdGhpcy54IC0gdmlld3BvcnQueCArIHZpZXdwb3J0LncvMiwgXG4gICAgICAgICAgICAgICAgcFsxXSAqIHRoaXMueiAgLSB0aGlzLnkgKyB2aWV3cG9ydC55ICsgdmlld3BvcnQuaC8yIF07XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIHBvaW50IGBwYCBmcm9tIFswLHdoXSB0byBzY2VuZSAoMCBhdCBpbWFnZSBjZW50ZXIpLlxuXHQgKiBcblx0ICogQHBhcmFtIHtWaWV3cG9ydH0gdmlld3BvcnQgVGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge0FQb2ludH0gcCBUaGUgcG9pbnQgaW4gcmFuZ2UgWzAuLnctMSwwLi5oLTFdXG5cdCAqIEByZXR1cm5zIHtBUG9pbnR9IFRoZSBwb2ludCBpbiBzY2VuZSAoMCwwIGF0IGltYWdlIGNlbnRlcilcblx0ICovXG4gICAgdmlld3BvcnRUb1NjZW5lQ29vcmRzKHZpZXdwb3J0LCBwKSB7XG4gICAgICAgIHJldHVybiBbKHBbMF0gKyB2aWV3cG9ydC54IC0gdmlld3BvcnQudy8yIC0gdGhpcy54KSAvIHRoaXMueixcbiAgICAgICAgICAgICAgICAocFsxXSAtIHZpZXdwb3J0LnkgLSB2aWV3cG9ydC5oLzIgKyB0aGlzLnkpIC8gdGhpcy56XTtcbiAgICB9XG5cblx0cHJpbnQoc3RyPVwiXCIsIHByZWNpc2lvbj0wKSB7XG4gICAgXHRjb25zdCBwID0gcHJlY2lzaW9uO1xuICAgIFx0Y29uc29sZS5sb2coc3RyICsgXCIgeDpcIiArIHRoaXMueC50b0ZpeGVkKHApICsgXCIsIHk6XCIgKyB0aGlzLnkudG9GaXhlZChwKSArIFwiLCB6OlwiICsgdGhpcy56LnRvRml4ZWQocCkgKyBcIiwgYTpcIiArIHRoaXMuYS50b0ZpeGVkKHApICsgXCIsIHQ6XCIgKyB0aGlzLnQudG9GaXhlZChwKSk7XG5cdH1cbn1cblxuZXhwb3J0IHsgVHJhbnNmb3JtIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Transform.js\n");

/***/ }),

/***/ "./src/UIBasic.js":
/*!************************!*\
  !*** ./src/UIBasic.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UIBasic\": () => (/* binding */ UIBasic),\n/* harmony export */   \"UIDialog\": () => (/* binding */ UIDialog)\n/* harmony export */ });\n/* harmony import */ var _Skin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Skin */ \"./src/Skin.js\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Util */ \"./src/Util.js\");\n/* harmony import */ var _Controller2D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Controller2D */ \"./src/Controller2D.js\");\n/* harmony import */ var _ControllerPanZoom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ControllerPanZoom */ \"./src/ControllerPanZoom.js\");\n/* harmony import */ var _Ruler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Ruler */ \"./src/Ruler.js\");\n/* harmony import */ var _ScaleBar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ScaleBar */ \"./src/ScaleBar.js\");\n/* harmony import */ var _Signals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Signals */ \"./src/Signals.js\");\n\n\n\n\n\n\n\n\n/**\n * An Action describes the behaviour of a tool button.\n * @typedef {Object} UIBasic#Action\n * @property {string} title The nameof the action.\n * @property {bool} display Whether to show the action in the toolbar.\n * @property {string} key The shortcut key.\n * @property {callback} task The callback executed by the action.\n */\n\n/**\n * A MenuEntry describes an entry for the menu.\n * @typedef {Object} UIBasic#Action\n * @property {string} title The menu title.\n * @property {string} section The section title.\n * @property {string} html A HTML text.\n * @property {callback} task The callback executed by the action.\n */\n\n/* Basic viewer for a single layer.\n *  we support actions through buttons: each button style is controlled by classes (trigger), active (if support status)\n *  and custom.\n * actions supported are:\n *  home: reset the camera\n *  zoomin, zoomout\n *  fullscreen\n *  rotate (45/90 deg rotation option.\n *  light: turn on light changing.\n *  switch layer(s)\n *  lens.\n * \n * How the menu works:\n * Each entry eg: { title: 'Coin 16' }\n * title: large title\n * section: smaller title\n * html: whatever html\n * button: visually a button, attributes: group, layer, mode\n * slider: callback(percent)\n * list: an array of entries.\n * \n * Additional attributes:\n * onclick: a function(event) {}\n * group: a group of entries where at most one is active\n * layer: a layer id: will be active if layer is visible\n * mode: a layer visualization mode, active if it's the current mode.\n * layer + mode: if both are specified, both must be current for an active.\n */\n\n\n/** \n * **UIBasic** is a flexible and easy-to-use class that implements a complete user interface to bind to the `viewer`\n * The interface is associated with a CSS file (skin.css) that defines the style of the HTML DOM and a graphic \n * file (skin.svg) that specifies the geometric characteristics of the tool buttons.\n * \n * The class provides a set of default ready-to-use tools (called actions):\n * * **home** resets the camera.\n * * **fullscreen** enables the fullscreen mode.\n * * **layers** displays the layer menu.\n * * **zoomin** performs a camera zoom-in.\n * * **zoomout** performs a camera zoom-out.\n * * **rotate** rotates the camera around the z-axis (by 45-degs steps).\n * * **light** enables light manipulation.\n * * **help** displays a help dialog box.\n * \n * In the following example a UIBasic interface is created and binded to the `lime` viewer.\n * The `light` action is disabled, and the `zoomin` and `zoomout` actions are enabled. \n * ```\n * // Creates an User Interface \n * const ui = new OpenLIME.UIBasic(lime);\n *\n * // Removes light from the toolbar\n * ui.actions.light.display=false;\n * // Adds zoomin and zoomout to the toolbar\n * ui.actions.zoomin.display=true;\n * ui.actions.zoomout.display=true;\n * ```\n */ \nclass UIBasic {\n\t/**\n\t * Instantiates a UIBasic object.\n\t * @param {Viewer} viewer The OpenLIME viewer.\n\t * @param {Object} [options] An object literal with UIBasic parameters.\n\t * @param {string} options.skin='skin/skin.svg' The file name of the vector image defining the tool buttons.\n\t * @param {bool} options.autofit=true Whether the initial position of the camera is set to fit the scene model.\n\t * @param {number} options.priority=0 Higher priority controllers are invoked first.\n\t * @param {{UIBasic#Action}} options.actions An Object of {@link UIBasic#Action}. A set of default actions are ready to be used.\n\t * @param {string} options.attribution Some information related to data attribution or credits.\n\t * @param {Array<UIBasic#MenuEntry>} options.menu The interface menu structure.\n\t * @param {bool} options.enableTooltip=true Whether to enable tool button tooltip.\n\t * @param {bool} options.showLightDirections=false Whether to draw light direction vectors.\n\t */\n\tconstructor(viewer, options) {\n\t\t//we need to know the size of the scene but the layers are not ready.\n\t\tlet camera = viewer.camera;\n\t\tObject.assign(this, {\n\t\t\tviewer: viewer,\n\t\t\tcamera: viewer.camera,\n\t\t\tskin: 'skin/skin.svg',\n\t\t\tautoFit: true, //FIXME to be moved in the viewer?\n\t\t\t//skinCSS: 'skin.css', // TODO: probably not useful\n\t\t\tactions: {\n\t\t\t\thome: { title: 'Home', display: true, key: 'Home', task: (event) => { if (camera.boundingBox) camera.fitCameraBox(250); } },\n\t\t\t\tfullscreen: { title: 'Fullscreen', display: true, key: 'f', task: (event) => { this.toggleFullscreen(); } },\n\t\t\t\tlayers: { title: 'Layers', display: true, key: 'Escape', task: (event) => { this.toggleLayers(); } },\n\t\t\t\tzoomin: { title: 'Zoom in', display: false, key: '+', task: (event) => { camera.deltaZoom(250, 1.25, 0, 0); } },\n\t\t\t\tzoomout: { title: 'Zoom out', display: false, key: '-', task: (event) => { camera.deltaZoom(250, 1 / 1.25, 0, 0); } },\n\t\t\t\trotate: { title: 'Rotate', display: false, key: 'r', task: (event) => { camera.rotate(250, -45); } },\n\t\t\t\tlight: { title: 'Light', display: 'auto', key: 'l', task: (event) => { this.toggleLightController(); } },\n\t\t\t\truler: { title: 'Ruler', display: false, task: (event) => { this.toggleRuler(); } },\n\t\t\t\thelp: { title: 'Help', display: false, key: '?', task: (event) => { this.toggleHelp(this.actions.help); }, html: '<p>Help here!</p>' }, //FIXME Why a boolean in toggleHelp?\n\t\t\t\tsnapshot: { title: 'Snapshot', display: false, task: (event) => { this.snapshot() } }, //FIXME not work!\n\t\t\t},\n\t\t\tpixelSize: null,\n\t\t\tunit: null, //FIXME to be used with ruler\n\t\t\tattribution: null,     //image attribution\n\t\t\tlightcontroller: null,\n\t\t\tshowLightDirections: false,\n\t\t\tenableTooltip: true,\n\t\t\tcontrolZoomMessage: null, //\"Use Ctrl + Wheel to zoom instead of scrolling\" ,\n\t\t\tmenu: []\n\t\t});\n\t\t\n\t\tObject.assign(this, options);\n\t\tif (this.autoFit) //FIXME Check if fitCamera is triggered only if the layer is loaded. Is updateSize the right event?\n\t\t\tthis.viewer.canvas.addEvent('updateSize', () => this.viewer.camera.fitCameraBox(0));\n\n\t\tthis.panzoom = new _ControllerPanZoom__WEBPACK_IMPORTED_MODULE_3__.ControllerPanZoom(this.viewer.camera, {\n\t\t\tpriority: -1000,\n\t\t\tactiveModifiers: [0, 1],\n\t\t\tcontrolZoom: this.controlZoomMessage != null\n\t\t});\n\t\tif(this.controlZoomMessage)\n\t\t\tthis.panzoom.addEvent('nowheel', () => { this.showOverlayMessage(this.controlZoomMessage); });\n\t\tthis.viewer.pointerManager.onEvent(this.panzoom); //register wheel, doubleclick, pan and pinch\n\t\t// this.viewer.pointerManager.on(\"fingerSingleTap\", { \"fingerSingleTap\": (e) => { this.showInfo(e); }, priority: 10000 });\n\n\t\t/*let element = entry.element;\n\t\tlet group = element.getAttribute('data-group');\n\t\tlet layer = element.getAttribute('data-layer');\n\t\tlet mode = element.getAttribute('data-mode');\n\t\tlet active = (layer && this.viewer.canvas.layers[layer].visible) &&\n\t\t\t(!mode || this.viewer.canvas.layers[layer].getMode() == mode);\n\t\tentry.element.classList.toggle('active', active); */\n\n\t\tthis.menu.push({ section: \"Layers\" });\n\t\tfor (let [id, layer] of Object.entries(this.viewer.canvas.layers)) {\n\t\t\tlet modes = []\n\t\t\tfor (let m of layer.getModes()) {\n\t\t\t\tlet mode = {\n\t\t\t\t\tbutton: m,\n\t\t\t\t\tmode: m,\n\t\t\t\t\tlayer: id,\n\t\t\t\t\tonclick: () => { layer.setMode(m); },\n\t\t\t\t\tstatus: () => layer.getMode() == m ? 'active' : '',\n\t\t\t\t};\n\t\t\t\tif (m == 'specular' && layer.shader.setSpecularExp)\n\t\t\t\t\tmode.list = [{ slider: '', oninput: (e) => { layer.shader.setSpecularExp(e.target.value); } }];\n\t\t\t\tmodes.push(mode);\n\t\t\t}\n\t\t\tlet layerEntry = {\n\t\t\t\tbutton: layer.label || id,\n\t\t\t\tonclick: () => { this.setLayer(layer); },\n\t\t\t\tstatus: () => layer.visible ? 'active' : '',\n\t\t\t\tlist: modes,\n\t\t\t\tlayer: id\n\t\t\t};\n\t\t\tif (layer.annotations) {\n\t\t\t\tlayerEntry.list.push(layer.annotationsEntry());\n\t\t\t\t//TODO: this could be a convenience, creating an editor which can be\n\t\t\t\t//customized later using layer.editor.\n\t\t\t\t//if(layer.editable) \n\t\t\t\t//\tlayer.editor = this.editor;\n\t\t\t}\n\t\t\tthis.menu.push(layerEntry);\n\t\t}\n\n\t\tlet controller = new _Controller2D__WEBPACK_IMPORTED_MODULE_2__.Controller2D((x, y) => {\n\t\t\tfor (let layer of lightLayers)\n\t\t\t\tlayer.setLight([x, y], 0);\n\t\t\tif(this.showLightDirections)\n\t\t\t\tthis.updateLightDirections(x, y);\n\t\t\t}, { \n\t\t\t\t// TODO: IS THIS OK? It was false before\n\t\t\t\tactive: false, \n    \t\t\tactiveModifiers: [2, 4], \n    \t\t\tcontrol: 'light', \n    \t\t\tonPanStart: this.showLightDirections ? () => {\n    \t\t\t\tObject.values(this.viewer.canvas.layers).filter(l => l.annotations != null).forEach(l => l.setVisible(false) );\n    \t\t\t\tthis.enableLightDirections(true); } : null,\n    \t\t\tonPanEnd: this.showLightDirections ? () => { \n    \t\t\t\tObject.values(this.viewer.canvas.layers).filter(l => l.annotations != null).forEach(l => l.setVisible(true) );\n    \t\t\t\tthis.enableLightDirections(false); } : null,\n    \t\t\trelative: true \n\t\t\t});\n\n\t\tcontroller.priority = 0;\n\t\tthis.viewer.pointerManager.onEvent(controller);\n\t\tthis.lightcontroller = controller;\n\n\n\t\tlet lightLayers = [];\n\t\tfor (let [id, layer] of Object.entries(this.viewer.canvas.layers))\n\t\t\tif (layer.controls.light) lightLayers.push(layer);\n\n\t\tif (lightLayers.length) {\n\t\t\tthis.createLightDirections();\n\t\t\tfor (let layer of lightLayers) {\n\t\t\t\tcontroller.setPosition(0.5, 0.5);\n\t\t\t\t//layer.setLight([0.5, 0.5], 0);\n\t\t\t\tlayer.controllers.push(controller);\n\t\t\t}\n\t\t}\n\n\t\tif (queueMicrotask) queueMicrotask(() => { this.init() }); //allows modification of actions and layers before init.\n\t\telse setTimeout(() => { this.init(); }, 0);\n\t}\n\n\tshowOverlayMessage(msg, duration = 2000) {\n\t\tif(this.overlayMessage) {\n\t\t\tclearTimeout(this.overlayMessage.timeout);\n\t\t\tthis.overlayMessage.timeout = setTimeout(() => this.destroyOverlayMessage(), duration);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tlet background = document.createElement('div');\n\t\tbackground.classList.add('openlime-overlaymsg');\n\t\tbackground.innerHTML = `<p>${msg}</p>`;\n\t\tthis.viewer.containerElement.appendChild(background);\n\n\t\tthis.overlayMessage = {\n\t\t\tbackground,\n\t\t\ttimeout: setTimeout(() => this.destroyOverlayMessage(), duration)\n\t\t}\n\t}\n\tdestroyOverlayMessage() {\n\t\tthis.overlayMessage.background.remove();\n\t\tthis.overlayMessage = null;\n\t}\n\n\t/** @ignore */\n\tgetMenuLayerEntry(id) {\n\t\tconst found = this.menu.find(e => e.layer == id);\n\t\treturn found;\n\t}\n\n\t/** @ignore */\n\tcreateLightDirections() {\n\t\tthis.lightDirections = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\t\tthis.lightDirections.setAttribute('viewBox', '-100, -100, 200 200');\n\t\tthis.lightDirections.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n\t\tthis.lightDirections.style.display = 'none';\n\t\tthis.lightDirections.classList.add('openlime-lightdir');\n\t\tfor(let x = -1; x <= 1; x++) {\n\t\t\tfor(let y = -1; y <= 1; y++) {\n\t\t\t\tlet line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n\t\t\t\tline.pos = [x*35, y*35];\n\t\t\t\t//line.setAttribute('data-start', `${x} ${y}`);\n\t\t\t\tthis.lightDirections.appendChild(line);\n\t\t\t}\n\t\t}\n\t\tthis.viewer.containerElement.appendChild(this.lightDirections);\n\t}\n\t\n\t/** @ignore */\n\tupdateLightDirections(lx, ly) {\n\t\tlet lines = [...this.lightDirections.children];\n\t\tfor(let line of lines) {\n\t\t\tlet x = line.pos[0];\n\t\t\tlet y = line.pos[1];\n\t\t\t\n\t\t\tline.setAttribute('x1', 0.6*x -25*0*lx);\n\t\t\tline.setAttribute('y1', 0.6*y +25*0*ly);\n\t\t\tline.setAttribute('x2', x/0.6 + 60*lx);\n\t\t\tline.setAttribute('y2', y/0.6 - 60*ly);\n\t\t}\n\t}\n\n\t/** @ignore */\n\tenableLightDirections(show) {\n\t\tthis.lightDirections.style.display = show? 'block' : 'none';\n\t}\n\n\t/** @ignore */\n\tinit() {\n\t\t(async () => {\n\n\t\t\tdocument.addEventListener('keydown', (e) => this.keyDown(e), false);\n\t\t\tdocument.addEventListener('keyup', (e) => this.keyUp(e), false);\n\n\t\t\tthis.createMenu();\n\t\t\tthis.updateMenu();\n\t\t\tthis.viewer.canvas.addEvent('update', () => this.updateMenu());\n\n\t\t\tif (this.actions.light && this.actions.light.display === 'auto')\n\t\t\t\tthis.actions.light.display = true;\n\n\n\t\t\tif (this.skin)\n\t\t\t\tawait this.loadSkin();\n\t\t\t/* TODO: this is probably not needed\n\t\t\tif(this.skinCSS)\n\t\t\t\tawait this.loadSkinCSS();\n\t\t\t*/\n\n\t\t\tthis.setupActions();\n\t\t\tif(this.pixelSize) \n\t\t\t\tthis.scalebar = new _ScaleBar__WEBPACK_IMPORTED_MODULE_5__.ScaleBar(this.pixelSize, this.viewer);\n\n\t\t\tif(this.attribution) {\n\t\t\t\tvar p = document.createElement('p');\n\t\t\t\tp.classList.add('openlime-attribution');\n\t\t\t\tp.innerHTML = this.attribution;\n\t\t\t\tthis.viewer.containerElement.appendChild(p);\n\t\t\t}\n\n\t\t\t\n\n\t\t\tfor(let l of Object.values(this.viewer.canvas.layers)) {\n\t\t\t\tthis.setLayer(l);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(this.actions.light && this.actions.light.active)\n\t\t\t\tthis.toggleLightController();\n\t\t\tif(this.actions.layers && this.actions.layers.active)\n\t\t\t\tthis.toggleLayers();\n\n\t\t})().catch(e => { console.log(e); throw Error(\"Something failed\") });\n\t}\n\n\t/** @ignore */\n\tkeyDown(e) {\n\t}\n\n\t/** @ignore */\n\tkeyUp(e) {\n\t\tif (e.target != document.body && e.target.closest('input, textarea') != null)\n\t\t\treturn;\n\n\t\tif (e.defaultPrevented) return;\n\n\t\tfor (const a of Object.values(this.actions)) {\n\t\t\tif ('key' in a && a.key == e.key) {\n\t\t\t\te.preventDefault();\n\t\t\t\ta.task(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** @ignore */\n\tasync loadSkin() {\n\t\tlet toolbar = document.createElement('div');\n\t\ttoolbar.classList.add('openlime-toolbar');\n\t\tthis.viewer.containerElement.appendChild(toolbar);\n\n\t\t//toolbar manually created with parameters (padding, etc) + css for toolbar positioning and size.\n\t\tif (true) {\n\n\t\t\tlet padding = 10;\n\t\t\tlet x = 0;\n\t\t\tlet h = 0;\n\t\t\tfor (let [name, action] of Object.entries(this.actions)) {\n\n\t\t\t\tif (action.display !== true)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif('icon' in action) {\n\t\t\t\t\tif(typeof action.icon == 'string') {\n\t\t\t\t\t\tif(_Util__WEBPACK_IMPORTED_MODULE_1__.Util.isSVGString(action.icon)) {\n\t\t\t\t\t\t\taction.icon = _Util__WEBPACK_IMPORTED_MODULE_1__.Util.SVGFromString(action.icon);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taction.icon = await _Util__WEBPACK_IMPORTED_MODULE_1__.Util.loadSVG(action.icon);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taction.icon.classList.add('openlime-button');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taction.icon = '.openlime-' + name;\n\t\t\t\t}\n\n\t\t\t\taction.element = await _Skin__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(toolbar, action.icon);\n\t\t\t\tif (this.enableTooltip) {\n\t\t\t\t\tlet title = document.createElementNS('http://www.w3.org/2000/svg', 'title');\n\t\t\t\t\ttitle.textContent = action.title;\n\t\t\t\t\taction.element.appendChild(title);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (false) {}\n\n\n\n\t\t//TODO: not needed, probably. Toolbar build from the skin directly\n\t\tif (false) {}\n\t}\n\n\t/** @ignore */\n\tsetupActions() {\n\t\tfor (let [name, action] of Object.entries(this.actions)) {\n\t\t\tlet element = action.element;\n\t\t\tif (!element)\n\t\t\t\tcontinue;\n\t\t\t// let pointerManager = new PointerManager(element);\n\t\t\t// pointerManager.onEvent({ fingerSingleTap: action.task, priority: -2000 });\n\t\t\telement.addEventListener('click', (e) => {\n\t\t\t\taction.task(e);\n\t\t\t\te.preventDefault();\n\t\t\t});\n\t\t}\n\t\tlet items = document.querySelectorAll('.openlime-layers-button');\n\t\tfor (let item of items) {\n\t\t\tlet id = item.getAttribute('data-layer');\n\t\t\tif (!id) continue;\n\t\t\titem.addEventListener('click', () => {\n\t\t\t\tthis.setLayer(this.viewer.layers[id]);\n\t\t\t});\n\t\t}\n\t}\n\n\t//we need the concept of active layer! so we an turn on and off light.\n\t/** @ignore */\n\ttoggleLightController(on) {\n\t\tlet div = this.viewer.containerElement;\n\t\tlet active = div.classList.toggle('openlime-light-active', on);\n\t\tthis.lightActive = active;\n\n\t\tfor (let layer of Object.values(this.viewer.canvas.layers))\n\t\t\tfor (let c of layer.controllers)\n\t\t\t\tif (c.control == 'light') {\n\t\t\t\t\tc.active = true;\n\t\t\t\t\tc.activeModifiers = active ? [0, 2, 4] : [2, 4];  //nothing, shift and alt\n\t\t\t\t}\n\t}\n\n\t/** @ignore */\n\ttoggleFullscreen() {\n\t\tlet canvas = this.viewer.canvasElement;\n\t\tlet div = this.viewer.containerElement;\n\t\tlet active = div.classList.toggle('openlime-fullscreen-active');\n\n\t\tif (!active) {\n\t\t\tvar request = document.exitFullscreen || document.webkitExitFullscreen ||\n\t\t\t\tdocument.mozCancelFullScreen || document.msExitFullscreen;\n\t\t\trequest.call(document); document.querySelector('.openlime-scale > line');\n\n\t\t\tthis.viewer.resize(canvas.offsetWidth, canvas.offsetHeight);\n\t\t} else {\n\t\t\tvar request = div.requestFullscreen || div.webkitRequestFullscreen ||\n\t\t\t\tdiv.mozRequestFullScreen || div.msRequestFullscreen;\n\t\t\trequest.call(div);\n\t\t}\n\t\tthis.viewer.resize(canvas.offsetWidth, canvas.offsetHeight);\n\t}\n\n\t/** @ignore */\n\ttoggleRuler() {\n\t\tif(!this.ruler) {\n\t\t\tthis.ruler = new _Ruler__WEBPACK_IMPORTED_MODULE_4__.Ruler(this.viewer, this.pixelSize);\n\t\t\tthis.viewer.pointerManager.onEvent(this.ruler);\n\t\t}\n\t\t\n\t\tif(!this.ruler.enabled)\n\t\t\tthis.ruler.start();\n\t\telse\n\t\t\tthis.ruler.end();\n\t}\n\n\t/** @ignore */\n\ttoggleHelp(help, on) {\n\t\tif(!help.dialog) {\n\t\t\thelp.dialog = new UIDialog(this.viewer.containerElement, { modal: true, class: 'openlime-help-dialog' });\n\t\t\thelp.dialog.setContent(help.html);\n\t\t} else\n\t\t\thelp.dialog.toggle(on);\t\t\n\t}\n\n\t/** @ignore */\n\tsnapshot() {\n\t\tvar e = document.createElement('a');\n\t\te.setAttribute('href', this.viewer.canvas.canvasElement.toDataURL());\n\t\te.setAttribute('download', 'snapshot.png');\n\t\te.style.display = 'none';\n\t\tdocument.body.appendChild(e);\n\t\te.click();\n\t\tdocument.body.removeChild(e);\n\t}\n\n\t/* Layer management */\n\n\t/** @ignore */\n\tcreateEntry(entry) {\n\t\tif (!('id' in entry))\n\t\t\tentry.id = 'entry_' + (this.entry_count++);\n\n\t\tlet id = `id=\"${entry.id}\"`;\n\t\tlet tooltip = 'tooltip' in entry ? `title=\"${entry.tooltip}\"` : '';\n\t\tlet classes = 'classes' in entry ? entry.classes : '';\n\t\tlet html = '';\n\t\tif ('title' in entry) {\n\t\t\thtml += `<h2 ${id} class=\"openlime-title ${classes}\" ${tooltip}>${entry.title}</h2>`;\n\n\t\t} else if ('section' in entry) {\n\t\t\thtml += `<h3 ${id} class=\"openlime-section ${classes}\" ${tooltip}>${entry.section}</h3>`;\n\n\t\t} else if ('html' in entry) {\n\t\t\thtml += `<div ${id} class=\"${classes}\">${entry.html}</div>`;\n\n\t\t} else if ('button' in entry) {\n\t\t\tlet group = 'group' in entry ? `data-group=\"${entry.group}\"` : '';\n\t\t\tlet layer = 'layer' in entry ? `data-layer=\"${entry.layer}\"` : '';\n\t\t\tlet mode = 'mode' in entry ? `data-mode=\"${entry.mode}\"` : '';\n\t\t\thtml += `<a href=\"#\" ${id} ${group} ${layer} ${mode} ${tooltip} class=\"openlime-entry ${classes}\">${entry.button}</a>`;\n\t\t} else if ('slider' in entry) {\n\t\t\tlet value = ('value' in entry) ? entry['value'] : 50;\n\t\t\thtml += `<input type=\"range\" min=\"1\" max=\"100\" value=\"${value}\" class=\"openlime-slider ${classes}\" ${id}>`;\n\t\t}\n\n\t\tif ('list' in entry) {\n\t\t\tlet ul = `<div class=\"openlime-list ${classes}\">`;\n\t\t\tfor (let li of entry.list)\n\t\t\t\tul += this.createEntry(li);\n\t\t\tul += '</div>';\n\t\t\thtml += ul;\n\t\t}\n\t\treturn html;\n\t}\n\n\t/** @ignore */\n\taddEntryCallbacks(entry) {\n\t\tentry.element = this.layerMenu.querySelector('#' + entry.id);\n\t\tif (entry.onclick)\n\t\t\tentry.element.addEventListener('click', (e) => {\n\t\t\t\tentry.onclick();\n\t\t\t\t//this.updateMenu();\n\t\t\t});\n\t\tif (entry.oninput)\n\t\t\tentry.element.addEventListener('input', entry.oninput);\n\t\tif (entry.oncreate)\n\t\t\tentry.oncreate();\n\n\t\tif ('list' in entry)\n\t\t\tfor (let e of entry.list)\n\t\t\t\tthis.addEntryCallbacks(e);\n\t}\n\n\t/** @ignore */\n\tupdateEntry(entry) {\n\t\tlet status = entry.status ? entry.status() : '';\n\t\tentry.element.classList.toggle('active', status == 'active');\n\n\t\tif ('list' in entry)\n\t\t\tfor (let e of entry.list)\n\t\t\t\tthis.updateEntry(e);\n\t}\n\n\t/** @ignore */\n\tupdateMenu() {\n\t\tfor (let entry of this.menu)\n\t\t\tthis.updateEntry(entry);\n\t}\n\n\t/** @ignore */\n\tcreateMenu() {\n\t\tthis.entry_count = 0;\n\t\tlet html = `<div class=\"openlime-layers-menu\">`;\n\t\tfor (let entry of this.menu) {\n\t\t\thtml += this.createEntry(entry);\n\t\t}\n\t\thtml += '</div>';\n\n\n\t\tlet template = document.createElement('template');\n\t\ttemplate.innerHTML = html.trim();\n\t\tthis.layerMenu = template.content.firstChild;\n\t\tthis.viewer.containerElement.appendChild(this.layerMenu);\n\n\t\tfor (let entry of this.menu) {\n\t\t\tthis.addEntryCallbacks(entry);\n\t\t}\n\n\n\t\t/*\t\tfor(let li of document.querySelectorAll('[data-layer]'))\n\t\t\t\t\tli.addEventListener('click', (e) => {\n\t\t\t\t\t\tthis.setLayer(this.viewer.canvas.layers[li.getAttribute('data-layer')]);\n\t\t\t\t\t}); */\n\t}\n\n\t/** @ignore */\n\ttoggleLayers() {\n\t\tthis.layerMenu.classList.toggle('open');\n\t}\n\n\t/** @ignore */\n\tsetLayer(layer_on) {\n\t\tif (typeof layer_on == 'string')\n\t\t\tlayer_on = this.viewer.canvas.layers[layer_on];\n\n\t\tif (layer_on.overlay) { //just toggle\n\t\t\tlayer_on.setVisible(!layer_on.visible);\n\n\t\t} else {\n\t\t\tfor (let layer of Object.values(this.viewer.canvas.layers)) {\n\t\t\t\tif (layer.overlay)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlayer.setVisible(layer == layer_on);\n\t\t\t\tfor (let c of layer.controllers) {\n\t\t\t\t\tif (c.control == 'light')\n\t\t\t\t\t\tc.active = this.lightActive && layer == layer_on;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.updateMenu();\n\t\tthis.viewer.redraw();\n\t}\n\n\t/** @ignore */\n\tcloseLayersMenu() {\n\t\tthis.layerMenu.style.display = 'none';\n\t}\n}\n\n/**\n * A **UIDialog** is a top-level window used for communications with the user. It may be modal or modeless.\n * The content of the dialog can be either an HTML text or a pre-built DOM element.\n * When hidden, a dialog emits a 'closed' event.\n */\nclass UIDialog { //FIXME standalone class\n\t/**\n\t * Instatiates a UIDialog object.\n\t * @param {HTMLElement} container The HTMLElement on which the dialog is focused\n\t * @param {Object} [options] An object literal with UIDialog parameters.\n\t * @param {bool} options.modal Whether the dialog is modal. \n\t */\n\tconstructor(container, options) {\n\t\tObject.assign(this, {\n\t\t\tdialog: null,\n\t\t\tcontent: null,\n\t\t\tcontainer: container,\n\t\t\tmodal: false,\n\t\t\tclass: null,\n\t\t\tvisible: false,\n\t\t\tbackdropEvents: true\n\t\t}, options);\n\t\tthis.create();\n\t}\n\n\t/** @ignore */\n\tcreate() {\n\t\tlet background = document.createElement('div');\n\t\tbackground.classList.add('openlime-dialog-background');\n\n\t\tlet dialog = document.createElement('div');\n\t\tdialog.classList.add('openlime-dialog');\n\t\tif (this.class)\n\t\t\tdialog.classList.add(this.class);\n\n\t\t(async () => {\n\t\t\tlet close = await _Skin__WEBPACK_IMPORTED_MODULE_0__.Skin.appendIcon(dialog, '.openlime-close');\n\t\t\tclose.classList.add('openlime-close');\n\t\t\tclose.addEventListener('click', () => this.hide());\n\t\t\t//content.appendChild(close);\n\t\t})();\n\n\n\t\t// let close = Skin.appendIcon(dialog, '.openlime-close');\n\t\t// close.classList.add('openlime-close');\n\t\t// close.addEventListener('click', () => this.hide());\n\n\t\tlet content = document.createElement('div');\n\t\tcontent.classList.add('openlime-dialog-content');\n\t\tdialog.append(content);\n\n\t\tif (this.modal) { //FIXME backdrown => backdrop\n\t\t\tif(this.backdropEvents) background.addEventListener('click', (e) => { if (e.target == background) this.hide(); });\n\t\t\tbackground.appendChild(dialog);\n\t\t\tthis.container.appendChild(background);\n\t\t\tthis.element = background;\n\t\t} else {\n\t\t\tthis.container.appendChild(dialog);\n\t\t\tthis.element = dialog;\n\t\t}\n\n\t\tthis.dialog = dialog;\n\t\tthis.content = content;\n\t\tthis.hide();\n\t}\n\n\t/**\n\t * Sets the content of the dialog.\n\t * @param {(string|HTMLElement)} html The content of the dialog (a HTML text or element). \n\t */\n\tsetContent(html) {\n\t\tif (typeof (html) == 'string')\n\t\t\tthis.content.innerHTML = html;\n\t\telse\n\t\t\tthis.content.replaceChildren(html);\n\t}\n\t\n\t/**\n\t * Shows the dialog.\n\t */\n\tshow() {\n\t\tthis.element.classList.remove('hidden');\n\t\tthis.visible=true;\n\t}\n\t\n\t/**\n\t * Hides the dialog.\n\t */\n\thide() {\n\t\t/**\n\t\t * The event is fired when the dialog is closed.\n\t\t * @event UIDialog#closed\n\t\t */\n\t\tthis.element.classList.add('hidden');\n\t\tthis.visible=false;\n\t\tthis.emit('closed');\n\t}\n\t\n\t/**\n\t * Adds fading effect to the dialog.\n\t * @param {bool} on Whether the fading effect is enabled.\n\t */\n\tfade(on) { //FIXME Does it work?\n\t\tthis.element.classList.toggle('fading');\n\t}\n\n\t/**\n\t * Toggles the display of the dialog.\n\t * @param {bool} force Whether to turn the dialog into a one way-only operation.\n\t */\n\ttoggle(force) { //FIXME Why not remove force?\n\t\tthis.element.classList.toggle('hidden', force);\n\t\tthis.visible = !this.visible; //FIXME not in sync with 'force'\n\t}\n}\n\n(0,_Signals__WEBPACK_IMPORTED_MODULE_6__.addSignals)(UIDialog, 'closed');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQix5RUFBeUUsMENBQTBDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLG9EQUFVOztBQUVrQiIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW5saW1lLy4vc3JjL1VJQmFzaWMuanM/YzhiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTa2luIH0gZnJvbSAnLi9Ta2luJ1xuaW1wb3J0IHsgVXRpbCB9IGZyb20gJy4vVXRpbCdcbmltcG9ydCB7IENvbnRyb2xsZXIyRCB9IGZyb20gJy4vQ29udHJvbGxlcjJEJ1xuaW1wb3J0IHsgQ29udHJvbGxlclBhblpvb20gfSBmcm9tICcuL0NvbnRyb2xsZXJQYW5ab29tJ1xuaW1wb3J0IHsgUnVsZXIgfSBmcm9tIFwiLi9SdWxlclwiXG5pbXBvcnQgeyBTY2FsZUJhciB9IGZyb20gJy4vU2NhbGVCYXInXG5pbXBvcnQgeyBhZGRTaWduYWxzIH0gIGZyb20gJy4vU2lnbmFscydcblxuLyoqXG4gKiBBbiBBY3Rpb24gZGVzY3JpYmVzIHRoZSBiZWhhdmlvdXIgb2YgYSB0b29sIGJ1dHRvbi5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVJQmFzaWMjQWN0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGl0bGUgVGhlIG5hbWVvZiB0aGUgYWN0aW9uLlxuICogQHByb3BlcnR5IHtib29sfSBkaXNwbGF5IFdoZXRoZXIgdG8gc2hvdyB0aGUgYWN0aW9uIGluIHRoZSB0b29sYmFyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleSBUaGUgc2hvcnRjdXQga2V5LlxuICogQHByb3BlcnR5IHtjYWxsYmFja30gdGFzayBUaGUgY2FsbGJhY2sgZXhlY3V0ZWQgYnkgdGhlIGFjdGlvbi5cbiAqL1xuXG4vKipcbiAqIEEgTWVudUVudHJ5IGRlc2NyaWJlcyBhbiBlbnRyeSBmb3IgdGhlIG1lbnUuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVSUJhc2ljI0FjdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIFRoZSBtZW51IHRpdGxlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlY3Rpb24gVGhlIHNlY3Rpb24gdGl0bGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaHRtbCBBIEhUTUwgdGV4dC5cbiAqIEBwcm9wZXJ0eSB7Y2FsbGJhY2t9IHRhc2sgVGhlIGNhbGxiYWNrIGV4ZWN1dGVkIGJ5IHRoZSBhY3Rpb24uXG4gKi9cblxuLyogQmFzaWMgdmlld2VyIGZvciBhIHNpbmdsZSBsYXllci5cbiAqICB3ZSBzdXBwb3J0IGFjdGlvbnMgdGhyb3VnaCBidXR0b25zOiBlYWNoIGJ1dHRvbiBzdHlsZSBpcyBjb250cm9sbGVkIGJ5IGNsYXNzZXMgKHRyaWdnZXIpLCBhY3RpdmUgKGlmIHN1cHBvcnQgc3RhdHVzKVxuICogIGFuZCBjdXN0b20uXG4gKiBhY3Rpb25zIHN1cHBvcnRlZCBhcmU6XG4gKiAgaG9tZTogcmVzZXQgdGhlIGNhbWVyYVxuICogIHpvb21pbiwgem9vbW91dFxuICogIGZ1bGxzY3JlZW5cbiAqICByb3RhdGUgKDQ1LzkwIGRlZyByb3RhdGlvbiBvcHRpb24uXG4gKiAgbGlnaHQ6IHR1cm4gb24gbGlnaHQgY2hhbmdpbmcuXG4gKiAgc3dpdGNoIGxheWVyKHMpXG4gKiAgbGVucy5cbiAqIFxuICogSG93IHRoZSBtZW51IHdvcmtzOlxuICogRWFjaCBlbnRyeSBlZzogeyB0aXRsZTogJ0NvaW4gMTYnIH1cbiAqIHRpdGxlOiBsYXJnZSB0aXRsZVxuICogc2VjdGlvbjogc21hbGxlciB0aXRsZVxuICogaHRtbDogd2hhdGV2ZXIgaHRtbFxuICogYnV0dG9uOiB2aXN1YWxseSBhIGJ1dHRvbiwgYXR0cmlidXRlczogZ3JvdXAsIGxheWVyLCBtb2RlXG4gKiBzbGlkZXI6IGNhbGxiYWNrKHBlcmNlbnQpXG4gKiBsaXN0OiBhbiBhcnJheSBvZiBlbnRyaWVzLlxuICogXG4gKiBBZGRpdGlvbmFsIGF0dHJpYnV0ZXM6XG4gKiBvbmNsaWNrOiBhIGZ1bmN0aW9uKGV2ZW50KSB7fVxuICogZ3JvdXA6IGEgZ3JvdXAgb2YgZW50cmllcyB3aGVyZSBhdCBtb3N0IG9uZSBpcyBhY3RpdmVcbiAqIGxheWVyOiBhIGxheWVyIGlkOiB3aWxsIGJlIGFjdGl2ZSBpZiBsYXllciBpcyB2aXNpYmxlXG4gKiBtb2RlOiBhIGxheWVyIHZpc3VhbGl6YXRpb24gbW9kZSwgYWN0aXZlIGlmIGl0J3MgdGhlIGN1cnJlbnQgbW9kZS5cbiAqIGxheWVyICsgbW9kZTogaWYgYm90aCBhcmUgc3BlY2lmaWVkLCBib3RoIG11c3QgYmUgY3VycmVudCBmb3IgYW4gYWN0aXZlLlxuICovXG5cblxuLyoqIFxuICogKipVSUJhc2ljKiogaXMgYSBmbGV4aWJsZSBhbmQgZWFzeS10by11c2UgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIGEgY29tcGxldGUgdXNlciBpbnRlcmZhY2UgdG8gYmluZCB0byB0aGUgYHZpZXdlcmBcbiAqIFRoZSBpbnRlcmZhY2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgQ1NTIGZpbGUgKHNraW4uY3NzKSB0aGF0IGRlZmluZXMgdGhlIHN0eWxlIG9mIHRoZSBIVE1MIERPTSBhbmQgYSBncmFwaGljIFxuICogZmlsZSAoc2tpbi5zdmcpIHRoYXQgc3BlY2lmaWVzIHRoZSBnZW9tZXRyaWMgY2hhcmFjdGVyaXN0aWNzIG9mIHRoZSB0b29sIGJ1dHRvbnMuXG4gKiBcbiAqIFRoZSBjbGFzcyBwcm92aWRlcyBhIHNldCBvZiBkZWZhdWx0IHJlYWR5LXRvLXVzZSB0b29scyAoY2FsbGVkIGFjdGlvbnMpOlxuICogKiAqKmhvbWUqKiByZXNldHMgdGhlIGNhbWVyYS5cbiAqICogKipmdWxsc2NyZWVuKiogZW5hYmxlcyB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICogKiAqKmxheWVycyoqIGRpc3BsYXlzIHRoZSBsYXllciBtZW51LlxuICogKiAqKnpvb21pbioqIHBlcmZvcm1zIGEgY2FtZXJhIHpvb20taW4uXG4gKiAqICoqem9vbW91dCoqIHBlcmZvcm1zIGEgY2FtZXJhIHpvb20tb3V0LlxuICogKiAqKnJvdGF0ZSoqIHJvdGF0ZXMgdGhlIGNhbWVyYSBhcm91bmQgdGhlIHotYXhpcyAoYnkgNDUtZGVncyBzdGVwcykuXG4gKiAqICoqbGlnaHQqKiBlbmFibGVzIGxpZ2h0IG1hbmlwdWxhdGlvbi5cbiAqICogKipoZWxwKiogZGlzcGxheXMgYSBoZWxwIGRpYWxvZyBib3guXG4gKiBcbiAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSBhIFVJQmFzaWMgaW50ZXJmYWNlIGlzIGNyZWF0ZWQgYW5kIGJpbmRlZCB0byB0aGUgYGxpbWVgIHZpZXdlci5cbiAqIFRoZSBgbGlnaHRgIGFjdGlvbiBpcyBkaXNhYmxlZCwgYW5kIHRoZSBgem9vbWluYCBhbmQgYHpvb21vdXRgIGFjdGlvbnMgYXJlIGVuYWJsZWQuIFxuICogYGBgXG4gKiAvLyBDcmVhdGVzIGFuIFVzZXIgSW50ZXJmYWNlIFxuICogY29uc3QgdWkgPSBuZXcgT3BlbkxJTUUuVUlCYXNpYyhsaW1lKTtcbiAqXG4gKiAvLyBSZW1vdmVzIGxpZ2h0IGZyb20gdGhlIHRvb2xiYXJcbiAqIHVpLmFjdGlvbnMubGlnaHQuZGlzcGxheT1mYWxzZTtcbiAqIC8vIEFkZHMgem9vbWluIGFuZCB6b29tb3V0IHRvIHRoZSB0b29sYmFyXG4gKiB1aS5hY3Rpb25zLnpvb21pbi5kaXNwbGF5PXRydWU7XG4gKiB1aS5hY3Rpb25zLnpvb21vdXQuZGlzcGxheT10cnVlO1xuICogYGBgXG4gKi8gXG5jbGFzcyBVSUJhc2ljIHtcblx0LyoqXG5cdCAqIEluc3RhbnRpYXRlcyBhIFVJQmFzaWMgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge1ZpZXdlcn0gdmlld2VyIFRoZSBPcGVuTElNRSB2aWV3ZXIuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBVSUJhc2ljIHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnNraW49J3NraW4vc2tpbi5zdmcnIFRoZSBmaWxlIG5hbWUgb2YgdGhlIHZlY3RvciBpbWFnZSBkZWZpbmluZyB0aGUgdG9vbCBidXR0b25zLlxuXHQgKiBAcGFyYW0ge2Jvb2x9IG9wdGlvbnMuYXV0b2ZpdD10cnVlIFdoZXRoZXIgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGNhbWVyYSBpcyBzZXQgdG8gZml0IHRoZSBzY2VuZSBtb2RlbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucHJpb3JpdHk9MCBIaWdoZXIgcHJpb3JpdHkgY29udHJvbGxlcnMgYXJlIGludm9rZWQgZmlyc3QuXG5cdCAqIEBwYXJhbSB7e1VJQmFzaWMjQWN0aW9ufX0gb3B0aW9ucy5hY3Rpb25zIEFuIE9iamVjdCBvZiB7QGxpbmsgVUlCYXNpYyNBY3Rpb259LiBBIHNldCBvZiBkZWZhdWx0IGFjdGlvbnMgYXJlIHJlYWR5IHRvIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmF0dHJpYnV0aW9uIFNvbWUgaW5mb3JtYXRpb24gcmVsYXRlZCB0byBkYXRhIGF0dHJpYnV0aW9uIG9yIGNyZWRpdHMuXG5cdCAqIEBwYXJhbSB7QXJyYXk8VUlCYXNpYyNNZW51RW50cnk+fSBvcHRpb25zLm1lbnUgVGhlIGludGVyZmFjZSBtZW51IHN0cnVjdHVyZS5cblx0ICogQHBhcmFtIHtib29sfSBvcHRpb25zLmVuYWJsZVRvb2x0aXA9dHJ1ZSBXaGV0aGVyIHRvIGVuYWJsZSB0b29sIGJ1dHRvbiB0b29sdGlwLlxuXHQgKiBAcGFyYW0ge2Jvb2x9IG9wdGlvbnMuc2hvd0xpZ2h0RGlyZWN0aW9ucz1mYWxzZSBXaGV0aGVyIHRvIGRyYXcgbGlnaHQgZGlyZWN0aW9uIHZlY3RvcnMuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih2aWV3ZXIsIG9wdGlvbnMpIHtcblx0XHQvL3dlIG5lZWQgdG8ga25vdyB0aGUgc2l6ZSBvZiB0aGUgc2NlbmUgYnV0IHRoZSBsYXllcnMgYXJlIG5vdCByZWFkeS5cblx0XHRsZXQgY2FtZXJhID0gdmlld2VyLmNhbWVyYTtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHtcblx0XHRcdHZpZXdlcjogdmlld2VyLFxuXHRcdFx0Y2FtZXJhOiB2aWV3ZXIuY2FtZXJhLFxuXHRcdFx0c2tpbjogJ3NraW4vc2tpbi5zdmcnLFxuXHRcdFx0YXV0b0ZpdDogdHJ1ZSwgLy9GSVhNRSB0byBiZSBtb3ZlZCBpbiB0aGUgdmlld2VyP1xuXHRcdFx0Ly9za2luQ1NTOiAnc2tpbi5jc3MnLCAvLyBUT0RPOiBwcm9iYWJseSBub3QgdXNlZnVsXG5cdFx0XHRhY3Rpb25zOiB7XG5cdFx0XHRcdGhvbWU6IHsgdGl0bGU6ICdIb21lJywgZGlzcGxheTogdHJ1ZSwga2V5OiAnSG9tZScsIHRhc2s6IChldmVudCkgPT4geyBpZiAoY2FtZXJhLmJvdW5kaW5nQm94KSBjYW1lcmEuZml0Q2FtZXJhQm94KDI1MCk7IH0gfSxcblx0XHRcdFx0ZnVsbHNjcmVlbjogeyB0aXRsZTogJ0Z1bGxzY3JlZW4nLCBkaXNwbGF5OiB0cnVlLCBrZXk6ICdmJywgdGFzazogKGV2ZW50KSA9PiB7IHRoaXMudG9nZ2xlRnVsbHNjcmVlbigpOyB9IH0sXG5cdFx0XHRcdGxheWVyczogeyB0aXRsZTogJ0xheWVycycsIGRpc3BsYXk6IHRydWUsIGtleTogJ0VzY2FwZScsIHRhc2s6IChldmVudCkgPT4geyB0aGlzLnRvZ2dsZUxheWVycygpOyB9IH0sXG5cdFx0XHRcdHpvb21pbjogeyB0aXRsZTogJ1pvb20gaW4nLCBkaXNwbGF5OiBmYWxzZSwga2V5OiAnKycsIHRhc2s6IChldmVudCkgPT4geyBjYW1lcmEuZGVsdGFab29tKDI1MCwgMS4yNSwgMCwgMCk7IH0gfSxcblx0XHRcdFx0em9vbW91dDogeyB0aXRsZTogJ1pvb20gb3V0JywgZGlzcGxheTogZmFsc2UsIGtleTogJy0nLCB0YXNrOiAoZXZlbnQpID0+IHsgY2FtZXJhLmRlbHRhWm9vbSgyNTAsIDEgLyAxLjI1LCAwLCAwKTsgfSB9LFxuXHRcdFx0XHRyb3RhdGU6IHsgdGl0bGU6ICdSb3RhdGUnLCBkaXNwbGF5OiBmYWxzZSwga2V5OiAncicsIHRhc2s6IChldmVudCkgPT4geyBjYW1lcmEucm90YXRlKDI1MCwgLTQ1KTsgfSB9LFxuXHRcdFx0XHRsaWdodDogeyB0aXRsZTogJ0xpZ2h0JywgZGlzcGxheTogJ2F1dG8nLCBrZXk6ICdsJywgdGFzazogKGV2ZW50KSA9PiB7IHRoaXMudG9nZ2xlTGlnaHRDb250cm9sbGVyKCk7IH0gfSxcblx0XHRcdFx0cnVsZXI6IHsgdGl0bGU6ICdSdWxlcicsIGRpc3BsYXk6IGZhbHNlLCB0YXNrOiAoZXZlbnQpID0+IHsgdGhpcy50b2dnbGVSdWxlcigpOyB9IH0sXG5cdFx0XHRcdGhlbHA6IHsgdGl0bGU6ICdIZWxwJywgZGlzcGxheTogZmFsc2UsIGtleTogJz8nLCB0YXNrOiAoZXZlbnQpID0+IHsgdGhpcy50b2dnbGVIZWxwKHRoaXMuYWN0aW9ucy5oZWxwKTsgfSwgaHRtbDogJzxwPkhlbHAgaGVyZSE8L3A+JyB9LCAvL0ZJWE1FIFdoeSBhIGJvb2xlYW4gaW4gdG9nZ2xlSGVscD9cblx0XHRcdFx0c25hcHNob3Q6IHsgdGl0bGU6ICdTbmFwc2hvdCcsIGRpc3BsYXk6IGZhbHNlLCB0YXNrOiAoZXZlbnQpID0+IHsgdGhpcy5zbmFwc2hvdCgpIH0gfSwgLy9GSVhNRSBub3Qgd29yayFcblx0XHRcdH0sXG5cdFx0XHRwaXhlbFNpemU6IG51bGwsXG5cdFx0XHR1bml0OiBudWxsLCAvL0ZJWE1FIHRvIGJlIHVzZWQgd2l0aCBydWxlclxuXHRcdFx0YXR0cmlidXRpb246IG51bGwsICAgICAvL2ltYWdlIGF0dHJpYnV0aW9uXG5cdFx0XHRsaWdodGNvbnRyb2xsZXI6IG51bGwsXG5cdFx0XHRzaG93TGlnaHREaXJlY3Rpb25zOiBmYWxzZSxcblx0XHRcdGVuYWJsZVRvb2x0aXA6IHRydWUsXG5cdFx0XHRjb250cm9sWm9vbU1lc3NhZ2U6IG51bGwsIC8vXCJVc2UgQ3RybCArIFdoZWVsIHRvIHpvb20gaW5zdGVhZCBvZiBzY3JvbGxpbmdcIiAsXG5cdFx0XHRtZW51OiBbXVxuXHRcdH0pO1xuXHRcdFxuXHRcdE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cdFx0aWYgKHRoaXMuYXV0b0ZpdCkgLy9GSVhNRSBDaGVjayBpZiBmaXRDYW1lcmEgaXMgdHJpZ2dlcmVkIG9ubHkgaWYgdGhlIGxheWVyIGlzIGxvYWRlZC4gSXMgdXBkYXRlU2l6ZSB0aGUgcmlnaHQgZXZlbnQ/XG5cdFx0XHR0aGlzLnZpZXdlci5jYW52YXMuYWRkRXZlbnQoJ3VwZGF0ZVNpemUnLCAoKSA9PiB0aGlzLnZpZXdlci5jYW1lcmEuZml0Q2FtZXJhQm94KDApKTtcblxuXHRcdHRoaXMucGFuem9vbSA9IG5ldyBDb250cm9sbGVyUGFuWm9vbSh0aGlzLnZpZXdlci5jYW1lcmEsIHtcblx0XHRcdHByaW9yaXR5OiAtMTAwMCxcblx0XHRcdGFjdGl2ZU1vZGlmaWVyczogWzAsIDFdLFxuXHRcdFx0Y29udHJvbFpvb206IHRoaXMuY29udHJvbFpvb21NZXNzYWdlICE9IG51bGxcblx0XHR9KTtcblx0XHRpZih0aGlzLmNvbnRyb2xab29tTWVzc2FnZSlcblx0XHRcdHRoaXMucGFuem9vbS5hZGRFdmVudCgnbm93aGVlbCcsICgpID0+IHsgdGhpcy5zaG93T3ZlcmxheU1lc3NhZ2UodGhpcy5jb250cm9sWm9vbU1lc3NhZ2UpOyB9KTtcblx0XHR0aGlzLnZpZXdlci5wb2ludGVyTWFuYWdlci5vbkV2ZW50KHRoaXMucGFuem9vbSk7IC8vcmVnaXN0ZXIgd2hlZWwsIGRvdWJsZWNsaWNrLCBwYW4gYW5kIHBpbmNoXG5cdFx0Ly8gdGhpcy52aWV3ZXIucG9pbnRlck1hbmFnZXIub24oXCJmaW5nZXJTaW5nbGVUYXBcIiwgeyBcImZpbmdlclNpbmdsZVRhcFwiOiAoZSkgPT4geyB0aGlzLnNob3dJbmZvKGUpOyB9LCBwcmlvcml0eTogMTAwMDAgfSk7XG5cblx0XHQvKmxldCBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcblx0XHRsZXQgZ3JvdXAgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcpO1xuXHRcdGxldCBsYXllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWxheWVyJyk7XG5cdFx0bGV0IG1vZGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJyk7XG5cdFx0bGV0IGFjdGl2ZSA9IChsYXllciAmJiB0aGlzLnZpZXdlci5jYW52YXMubGF5ZXJzW2xheWVyXS52aXNpYmxlKSAmJlxuXHRcdFx0KCFtb2RlIHx8IHRoaXMudmlld2VyLmNhbnZhcy5sYXllcnNbbGF5ZXJdLmdldE1vZGUoKSA9PSBtb2RlKTtcblx0XHRlbnRyeS5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScsIGFjdGl2ZSk7ICovXG5cblx0XHR0aGlzLm1lbnUucHVzaCh7IHNlY3Rpb246IFwiTGF5ZXJzXCIgfSk7XG5cdFx0Zm9yIChsZXQgW2lkLCBsYXllcl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy52aWV3ZXIuY2FudmFzLmxheWVycykpIHtcblx0XHRcdGxldCBtb2RlcyA9IFtdXG5cdFx0XHRmb3IgKGxldCBtIG9mIGxheWVyLmdldE1vZGVzKCkpIHtcblx0XHRcdFx0bGV0IG1vZGUgPSB7XG5cdFx0XHRcdFx0YnV0dG9uOiBtLFxuXHRcdFx0XHRcdG1vZGU6IG0sXG5cdFx0XHRcdFx0bGF5ZXI6IGlkLFxuXHRcdFx0XHRcdG9uY2xpY2s6ICgpID0+IHsgbGF5ZXIuc2V0TW9kZShtKTsgfSxcblx0XHRcdFx0XHRzdGF0dXM6ICgpID0+IGxheWVyLmdldE1vZGUoKSA9PSBtID8gJ2FjdGl2ZScgOiAnJyxcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKG0gPT0gJ3NwZWN1bGFyJyAmJiBsYXllci5zaGFkZXIuc2V0U3BlY3VsYXJFeHApXG5cdFx0XHRcdFx0bW9kZS5saXN0ID0gW3sgc2xpZGVyOiAnJywgb25pbnB1dDogKGUpID0+IHsgbGF5ZXIuc2hhZGVyLnNldFNwZWN1bGFyRXhwKGUudGFyZ2V0LnZhbHVlKTsgfSB9XTtcblx0XHRcdFx0bW9kZXMucHVzaChtb2RlKTtcblx0XHRcdH1cblx0XHRcdGxldCBsYXllckVudHJ5ID0ge1xuXHRcdFx0XHRidXR0b246IGxheWVyLmxhYmVsIHx8IGlkLFxuXHRcdFx0XHRvbmNsaWNrOiAoKSA9PiB7IHRoaXMuc2V0TGF5ZXIobGF5ZXIpOyB9LFxuXHRcdFx0XHRzdGF0dXM6ICgpID0+IGxheWVyLnZpc2libGUgPyAnYWN0aXZlJyA6ICcnLFxuXHRcdFx0XHRsaXN0OiBtb2Rlcyxcblx0XHRcdFx0bGF5ZXI6IGlkXG5cdFx0XHR9O1xuXHRcdFx0aWYgKGxheWVyLmFubm90YXRpb25zKSB7XG5cdFx0XHRcdGxheWVyRW50cnkubGlzdC5wdXNoKGxheWVyLmFubm90YXRpb25zRW50cnkoKSk7XG5cdFx0XHRcdC8vVE9ETzogdGhpcyBjb3VsZCBiZSBhIGNvbnZlbmllbmNlLCBjcmVhdGluZyBhbiBlZGl0b3Igd2hpY2ggY2FuIGJlXG5cdFx0XHRcdC8vY3VzdG9taXplZCBsYXRlciB1c2luZyBsYXllci5lZGl0b3IuXG5cdFx0XHRcdC8vaWYobGF5ZXIuZWRpdGFibGUpIFxuXHRcdFx0XHQvL1x0bGF5ZXIuZWRpdG9yID0gdGhpcy5lZGl0b3I7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm1lbnUucHVzaChsYXllckVudHJ5KTtcblx0XHR9XG5cblx0XHRsZXQgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyMkQoKHgsIHkpID0+IHtcblx0XHRcdGZvciAobGV0IGxheWVyIG9mIGxpZ2h0TGF5ZXJzKVxuXHRcdFx0XHRsYXllci5zZXRMaWdodChbeCwgeV0sIDApO1xuXHRcdFx0aWYodGhpcy5zaG93TGlnaHREaXJlY3Rpb25zKVxuXHRcdFx0XHR0aGlzLnVwZGF0ZUxpZ2h0RGlyZWN0aW9ucyh4LCB5KTtcblx0XHRcdH0sIHsgXG5cdFx0XHRcdC8vIFRPRE86IElTIFRISVMgT0s/IEl0IHdhcyBmYWxzZSBiZWZvcmVcblx0XHRcdFx0YWN0aXZlOiBmYWxzZSwgXG4gICAgXHRcdFx0YWN0aXZlTW9kaWZpZXJzOiBbMiwgNF0sIFxuICAgIFx0XHRcdGNvbnRyb2w6ICdsaWdodCcsIFxuICAgIFx0XHRcdG9uUGFuU3RhcnQ6IHRoaXMuc2hvd0xpZ2h0RGlyZWN0aW9ucyA/ICgpID0+IHtcbiAgICBcdFx0XHRcdE9iamVjdC52YWx1ZXModGhpcy52aWV3ZXIuY2FudmFzLmxheWVycykuZmlsdGVyKGwgPT4gbC5hbm5vdGF0aW9ucyAhPSBudWxsKS5mb3JFYWNoKGwgPT4gbC5zZXRWaXNpYmxlKGZhbHNlKSApO1xuICAgIFx0XHRcdFx0dGhpcy5lbmFibGVMaWdodERpcmVjdGlvbnModHJ1ZSk7IH0gOiBudWxsLFxuICAgIFx0XHRcdG9uUGFuRW5kOiB0aGlzLnNob3dMaWdodERpcmVjdGlvbnMgPyAoKSA9PiB7IFxuICAgIFx0XHRcdFx0T2JqZWN0LnZhbHVlcyh0aGlzLnZpZXdlci5jYW52YXMubGF5ZXJzKS5maWx0ZXIobCA9PiBsLmFubm90YXRpb25zICE9IG51bGwpLmZvckVhY2gobCA9PiBsLnNldFZpc2libGUodHJ1ZSkgKTtcbiAgICBcdFx0XHRcdHRoaXMuZW5hYmxlTGlnaHREaXJlY3Rpb25zKGZhbHNlKTsgfSA6IG51bGwsXG4gICAgXHRcdFx0cmVsYXRpdmU6IHRydWUgXG5cdFx0XHR9KTtcblxuXHRcdGNvbnRyb2xsZXIucHJpb3JpdHkgPSAwO1xuXHRcdHRoaXMudmlld2VyLnBvaW50ZXJNYW5hZ2VyLm9uRXZlbnQoY29udHJvbGxlcik7XG5cdFx0dGhpcy5saWdodGNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG5cblx0XHRsZXQgbGlnaHRMYXllcnMgPSBbXTtcblx0XHRmb3IgKGxldCBbaWQsIGxheWVyXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnZpZXdlci5jYW52YXMubGF5ZXJzKSlcblx0XHRcdGlmIChsYXllci5jb250cm9scy5saWdodCkgbGlnaHRMYXllcnMucHVzaChsYXllcik7XG5cblx0XHRpZiAobGlnaHRMYXllcnMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZUxpZ2h0RGlyZWN0aW9ucygpO1xuXHRcdFx0Zm9yIChsZXQgbGF5ZXIgb2YgbGlnaHRMYXllcnMpIHtcblx0XHRcdFx0Y29udHJvbGxlci5zZXRQb3NpdGlvbigwLjUsIDAuNSk7XG5cdFx0XHRcdC8vbGF5ZXIuc2V0TGlnaHQoWzAuNSwgMC41XSwgMCk7XG5cdFx0XHRcdGxheWVyLmNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHF1ZXVlTWljcm90YXNrKSBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7IHRoaXMuaW5pdCgpIH0pOyAvL2FsbG93cyBtb2RpZmljYXRpb24gb2YgYWN0aW9ucyBhbmQgbGF5ZXJzIGJlZm9yZSBpbml0LlxuXHRcdGVsc2Ugc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuaW5pdCgpOyB9LCAwKTtcblx0fVxuXG5cdHNob3dPdmVybGF5TWVzc2FnZShtc2csIGR1cmF0aW9uID0gMjAwMCkge1xuXHRcdGlmKHRoaXMub3ZlcmxheU1lc3NhZ2UpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLm92ZXJsYXlNZXNzYWdlLnRpbWVvdXQpO1xuXHRcdFx0dGhpcy5vdmVybGF5TWVzc2FnZS50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmRlc3Ryb3lPdmVybGF5TWVzc2FnZSgpLCBkdXJhdGlvbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdFxuXHRcdGxldCBiYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0YmFja2dyb3VuZC5jbGFzc0xpc3QuYWRkKCdvcGVubGltZS1vdmVybGF5bXNnJyk7XG5cdFx0YmFja2dyb3VuZC5pbm5lckhUTUwgPSBgPHA+JHttc2d9PC9wPmA7XG5cdFx0dGhpcy52aWV3ZXIuY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChiYWNrZ3JvdW5kKTtcblxuXHRcdHRoaXMub3ZlcmxheU1lc3NhZ2UgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kLFxuXHRcdFx0dGltZW91dDogc2V0VGltZW91dCgoKSA9PiB0aGlzLmRlc3Ryb3lPdmVybGF5TWVzc2FnZSgpLCBkdXJhdGlvbilcblx0XHR9XG5cdH1cblx0ZGVzdHJveU92ZXJsYXlNZXNzYWdlKCkge1xuXHRcdHRoaXMub3ZlcmxheU1lc3NhZ2UuYmFja2dyb3VuZC5yZW1vdmUoKTtcblx0XHR0aGlzLm92ZXJsYXlNZXNzYWdlID0gbnVsbDtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGdldE1lbnVMYXllckVudHJ5KGlkKSB7XG5cdFx0Y29uc3QgZm91bmQgPSB0aGlzLm1lbnUuZmluZChlID0+IGUubGF5ZXIgPT0gaWQpO1xuXHRcdHJldHVybiBmb3VuZDtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGNyZWF0ZUxpZ2h0RGlyZWN0aW9ucygpIHtcblx0XHR0aGlzLmxpZ2h0RGlyZWN0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG5cdFx0dGhpcy5saWdodERpcmVjdGlvbnMuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgJy0xMDAsIC0xMDAsIDIwMCAyMDAnKTtcblx0XHR0aGlzLmxpZ2h0RGlyZWN0aW9ucy5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xuXHRcdHRoaXMubGlnaHREaXJlY3Rpb25zLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0dGhpcy5saWdodERpcmVjdGlvbnMuY2xhc3NMaXN0LmFkZCgnb3BlbmxpbWUtbGlnaHRkaXInKTtcblx0XHRmb3IobGV0IHggPSAtMTsgeCA8PSAxOyB4KyspIHtcblx0XHRcdGZvcihsZXQgeSA9IC0xOyB5IDw9IDE7IHkrKykge1xuXHRcdFx0XHRsZXQgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnbGluZScpO1xuXHRcdFx0XHRsaW5lLnBvcyA9IFt4KjM1LCB5KjM1XTtcblx0XHRcdFx0Ly9saW5lLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGFydCcsIGAke3h9ICR7eX1gKTtcblx0XHRcdFx0dGhpcy5saWdodERpcmVjdGlvbnMuYXBwZW5kQ2hpbGQobGluZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMudmlld2VyLmNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5saWdodERpcmVjdGlvbnMpO1xuXHR9XG5cdFxuXHQvKiogQGlnbm9yZSAqL1xuXHR1cGRhdGVMaWdodERpcmVjdGlvbnMobHgsIGx5KSB7XG5cdFx0bGV0IGxpbmVzID0gWy4uLnRoaXMubGlnaHREaXJlY3Rpb25zLmNoaWxkcmVuXTtcblx0XHRmb3IobGV0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdGxldCB4ID0gbGluZS5wb3NbMF07XG5cdFx0XHRsZXQgeSA9IGxpbmUucG9zWzFdO1xuXHRcdFx0XG5cdFx0XHRsaW5lLnNldEF0dHJpYnV0ZSgneDEnLCAwLjYqeCAtMjUqMCpseCk7XG5cdFx0XHRsaW5lLnNldEF0dHJpYnV0ZSgneTEnLCAwLjYqeSArMjUqMCpseSk7XG5cdFx0XHRsaW5lLnNldEF0dHJpYnV0ZSgneDInLCB4LzAuNiArIDYwKmx4KTtcblx0XHRcdGxpbmUuc2V0QXR0cmlidXRlKCd5MicsIHkvMC42IC0gNjAqbHkpO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGVuYWJsZUxpZ2h0RGlyZWN0aW9ucyhzaG93KSB7XG5cdFx0dGhpcy5saWdodERpcmVjdGlvbnMuc3R5bGUuZGlzcGxheSA9IHNob3c/ICdibG9jaycgOiAnbm9uZSc7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRpbml0KCkge1xuXHRcdChhc3luYyAoKSA9PiB7XG5cblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4gdGhpcy5rZXlEb3duKGUpLCBmYWxzZSk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChlKSA9PiB0aGlzLmtleVVwKGUpLCBmYWxzZSk7XG5cblx0XHRcdHRoaXMuY3JlYXRlTWVudSgpO1xuXHRcdFx0dGhpcy51cGRhdGVNZW51KCk7XG5cdFx0XHR0aGlzLnZpZXdlci5jYW52YXMuYWRkRXZlbnQoJ3VwZGF0ZScsICgpID0+IHRoaXMudXBkYXRlTWVudSgpKTtcblxuXHRcdFx0aWYgKHRoaXMuYWN0aW9ucy5saWdodCAmJiB0aGlzLmFjdGlvbnMubGlnaHQuZGlzcGxheSA9PT0gJ2F1dG8nKVxuXHRcdFx0XHR0aGlzLmFjdGlvbnMubGlnaHQuZGlzcGxheSA9IHRydWU7XG5cblxuXHRcdFx0aWYgKHRoaXMuc2tpbilcblx0XHRcdFx0YXdhaXQgdGhpcy5sb2FkU2tpbigpO1xuXHRcdFx0LyogVE9ETzogdGhpcyBpcyBwcm9iYWJseSBub3QgbmVlZGVkXG5cdFx0XHRpZih0aGlzLnNraW5DU1MpXG5cdFx0XHRcdGF3YWl0IHRoaXMubG9hZFNraW5DU1MoKTtcblx0XHRcdCovXG5cblx0XHRcdHRoaXMuc2V0dXBBY3Rpb25zKCk7XG5cdFx0XHRpZih0aGlzLnBpeGVsU2l6ZSkgXG5cdFx0XHRcdHRoaXMuc2NhbGViYXIgPSBuZXcgU2NhbGVCYXIodGhpcy5waXhlbFNpemUsIHRoaXMudmlld2VyKTtcblxuXHRcdFx0aWYodGhpcy5hdHRyaWJ1dGlvbikge1xuXHRcdFx0XHR2YXIgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0cC5jbGFzc0xpc3QuYWRkKCdvcGVubGltZS1hdHRyaWJ1dGlvbicpO1xuXHRcdFx0XHRwLmlubmVySFRNTCA9IHRoaXMuYXR0cmlidXRpb247XG5cdFx0XHRcdHRoaXMudmlld2VyLmNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQocCk7XG5cdFx0XHR9XG5cblx0XHRcdFxuXG5cdFx0XHRmb3IobGV0IGwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnZpZXdlci5jYW52YXMubGF5ZXJzKSkge1xuXHRcdFx0XHR0aGlzLnNldExheWVyKGwpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0aWYodGhpcy5hY3Rpb25zLmxpZ2h0ICYmIHRoaXMuYWN0aW9ucy5saWdodC5hY3RpdmUpXG5cdFx0XHRcdHRoaXMudG9nZ2xlTGlnaHRDb250cm9sbGVyKCk7XG5cdFx0XHRpZih0aGlzLmFjdGlvbnMubGF5ZXJzICYmIHRoaXMuYWN0aW9ucy5sYXllcnMuYWN0aXZlKVxuXHRcdFx0XHR0aGlzLnRvZ2dsZUxheWVycygpO1xuXG5cdFx0fSkoKS5jYXRjaChlID0+IHsgY29uc29sZS5sb2coZSk7IHRocm93IEVycm9yKFwiU29tZXRoaW5nIGZhaWxlZFwiKSB9KTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdGtleURvd24oZSkge1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0a2V5VXAoZSkge1xuXHRcdGlmIChlLnRhcmdldCAhPSBkb2N1bWVudC5ib2R5ICYmIGUudGFyZ2V0LmNsb3Nlc3QoJ2lucHV0LCB0ZXh0YXJlYScpICE9IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cblx0XHRmb3IgKGNvbnN0IGEgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmFjdGlvbnMpKSB7XG5cdFx0XHRpZiAoJ2tleScgaW4gYSAmJiBhLmtleSA9PSBlLmtleSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGEudGFzayhlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0LyoqIEBpZ25vcmUgKi9cblx0YXN5bmMgbG9hZFNraW4oKSB7XG5cdFx0bGV0IHRvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0b29sYmFyLmNsYXNzTGlzdC5hZGQoJ29wZW5saW1lLXRvb2xiYXInKTtcblx0XHR0aGlzLnZpZXdlci5jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHRvb2xiYXIpO1xuXG5cdFx0Ly90b29sYmFyIG1hbnVhbGx5IGNyZWF0ZWQgd2l0aCBwYXJhbWV0ZXJzIChwYWRkaW5nLCBldGMpICsgY3NzIGZvciB0b29sYmFyIHBvc2l0aW9uaW5nIGFuZCBzaXplLlxuXHRcdGlmICgxKSB7XG5cblx0XHRcdGxldCBwYWRkaW5nID0gMTA7XG5cdFx0XHRsZXQgeCA9IDA7XG5cdFx0XHRsZXQgaCA9IDA7XG5cdFx0XHRmb3IgKGxldCBbbmFtZSwgYWN0aW9uXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmFjdGlvbnMpKSB7XG5cblx0XHRcdFx0aWYgKGFjdGlvbi5kaXNwbGF5ICE9PSB0cnVlKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmKCdpY29uJyBpbiBhY3Rpb24pIHtcblx0XHRcdFx0XHRpZih0eXBlb2YgYWN0aW9uLmljb24gPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdGlmKFV0aWwuaXNTVkdTdHJpbmcoYWN0aW9uLmljb24pKSB7XG5cdFx0XHRcdFx0XHRcdGFjdGlvbi5pY29uID0gVXRpbC5TVkdGcm9tU3RyaW5nKGFjdGlvbi5pY29uKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGFjdGlvbi5pY29uID0gYXdhaXQgVXRpbC5sb2FkU1ZHKGFjdGlvbi5pY29uKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFjdGlvbi5pY29uLmNsYXNzTGlzdC5hZGQoJ29wZW5saW1lLWJ1dHRvbicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhY3Rpb24uaWNvbiA9ICcub3BlbmxpbWUtJyArIG5hbWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhY3Rpb24uZWxlbWVudCA9IGF3YWl0IFNraW4uYXBwZW5kSWNvbih0b29sYmFyLCBhY3Rpb24uaWNvbik7XG5cdFx0XHRcdGlmICh0aGlzLmVuYWJsZVRvb2x0aXApIHtcblx0XHRcdFx0XHRsZXQgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3RpdGxlJyk7XG5cdFx0XHRcdFx0dGl0bGUudGV4dENvbnRlbnQgPSBhY3Rpb24udGl0bGU7XG5cdFx0XHRcdFx0YWN0aW9uLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGl0bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoMCkgeyAgLy9zaW5nbGUgc3ZnIHRvb2xiYXJcblx0XHRcdGxldCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpO1xuXHRcdFx0dG9vbGJhci5hcHBlbmRDaGlsZChzdmcpOyB1aS50b2dnbGVMaWdodENvbnRyb2xsZXIoKTtcblx0XHRcdGxldCB4ID0gcGFkZGluZztcblx0XHRcdGxldCBoID0gMDtcblx0XHRcdGZvciAobGV0IFtuYW1lLCBhY3Rpb25dIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYWN0aW9ucykpIHtcblx0XHRcdFx0aWYgKGFjdGlvbi5kaXNwbGF5ICE9PSB0cnVlKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRsZXQgZWxlbWVudCA9IHNraW4ucXVlcnlTZWxlY3RvcignLm9wZW5saW1lLScgKyBuYW1lKS5jbG9uZU5vZGUodHJ1ZSk7XG5cdFx0XHRcdGlmICghZWxlbWVudCkgY29udGludWU7XG5cdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0bGV0IGJveCA9IGVsZW1lbnQuZ2V0QkJveCgpO1xuXHRcdFx0XHRoID0gTWF0aC5tYXgoaCwgYm94LmhlaWdodCk7XG5cdFx0XHRcdGxldCB0bGlzdCA9IGVsZW1lbnQudHJhbnNmb3JtLmJhc2VWYWw7XG5cdFx0XHRcdGlmICh0bGlzdC5udW1iZXJPZkl0ZW1zID09IDApXG5cdFx0XHRcdFx0dGxpc3QuYXBwZW5kSXRlbShzdmcuY3JlYXRlU1ZHVHJhbnNmb3JtKCkpO1xuXHRcdFx0XHR0bGlzdC5nZXRJdGVtKDApLnNldFRyYW5zbGF0ZSgtYm94LnggKyB4LCAtYm94LnkpO1xuXHRcdFx0XHR4ICs9IGJveC53aWR0aCArIHBhZGRpbmc7XG5cdFx0XHR9XG5cblx0XHRcdHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBgMCAwICR7eH0gJHtofWApO1xuXHRcdFx0c3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XG5cdFx0fVxuXG5cblxuXHRcdC8vVE9ETzogbm90IG5lZWRlZCwgcHJvYmFibHkuIFRvb2xiYXIgYnVpbGQgZnJvbSB0aGUgc2tpbiBkaXJlY3RseVxuXHRcdGlmICgwKSB7XG5cdFx0XHR0b29sYmFyLmFwcGVuZENoaWxkKHNraW4pO1xuXG5cdFx0XHRsZXQgdyA9IHNraW4uZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXHRcdFx0bGV0IGggPSBza2luLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG5cdFx0XHRsZXQgdmlld2JveCA9IHNraW4uZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG5cdFx0XHRpZiAoIXZpZXdib3gpXG5cdFx0XHRcdHNraW4uc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgYDAgMCAke3d9ICR7aH1gKTtcblx0XHR9XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRzZXR1cEFjdGlvbnMoKSB7XG5cdFx0Zm9yIChsZXQgW25hbWUsIGFjdGlvbl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5hY3Rpb25zKSkge1xuXHRcdFx0bGV0IGVsZW1lbnQgPSBhY3Rpb24uZWxlbWVudDtcblx0XHRcdGlmICghZWxlbWVudClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHQvLyBsZXQgcG9pbnRlck1hbmFnZXIgPSBuZXcgUG9pbnRlck1hbmFnZXIoZWxlbWVudCk7XG5cdFx0XHQvLyBwb2ludGVyTWFuYWdlci5vbkV2ZW50KHsgZmluZ2VyU2luZ2xlVGFwOiBhY3Rpb24udGFzaywgcHJpb3JpdHk6IC0yMDAwIH0pO1xuXHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG5cdFx0XHRcdGFjdGlvbi50YXNrKGUpO1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0bGV0IGl0ZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm9wZW5saW1lLWxheWVycy1idXR0b24nKTtcblx0XHRmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKSB7XG5cdFx0XHRsZXQgaWQgPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1sYXllcicpO1xuXHRcdFx0aWYgKCFpZCkgY29udGludWU7XG5cdFx0XHRpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnNldExheWVyKHRoaXMudmlld2VyLmxheWVyc1tpZF0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Ly93ZSBuZWVkIHRoZSBjb25jZXB0IG9mIGFjdGl2ZSBsYXllciEgc28gd2UgYW4gdHVybiBvbiBhbmQgb2ZmIGxpZ2h0LlxuXHQvKiogQGlnbm9yZSAqL1xuXHR0b2dnbGVMaWdodENvbnRyb2xsZXIob24pIHtcblx0XHRsZXQgZGl2ID0gdGhpcy52aWV3ZXIuY29udGFpbmVyRWxlbWVudDtcblx0XHRsZXQgYWN0aXZlID0gZGl2LmNsYXNzTGlzdC50b2dnbGUoJ29wZW5saW1lLWxpZ2h0LWFjdGl2ZScsIG9uKTtcblx0XHR0aGlzLmxpZ2h0QWN0aXZlID0gYWN0aXZlO1xuXG5cdFx0Zm9yIChsZXQgbGF5ZXIgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnZpZXdlci5jYW52YXMubGF5ZXJzKSlcblx0XHRcdGZvciAobGV0IGMgb2YgbGF5ZXIuY29udHJvbGxlcnMpXG5cdFx0XHRcdGlmIChjLmNvbnRyb2wgPT0gJ2xpZ2h0Jykge1xuXHRcdFx0XHRcdGMuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0XHRjLmFjdGl2ZU1vZGlmaWVycyA9IGFjdGl2ZSA/IFswLCAyLCA0XSA6IFsyLCA0XTsgIC8vbm90aGluZywgc2hpZnQgYW5kIGFsdFxuXHRcdFx0XHR9XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR0b2dnbGVGdWxsc2NyZWVuKCkge1xuXHRcdGxldCBjYW52YXMgPSB0aGlzLnZpZXdlci5jYW52YXNFbGVtZW50O1xuXHRcdGxldCBkaXYgPSB0aGlzLnZpZXdlci5jb250YWluZXJFbGVtZW50O1xuXHRcdGxldCBhY3RpdmUgPSBkaXYuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbmxpbWUtZnVsbHNjcmVlbi1hY3RpdmUnKTtcblxuXHRcdGlmICghYWN0aXZlKSB7XG5cdFx0XHR2YXIgcmVxdWVzdCA9IGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuIHx8IGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuIHx8XG5cdFx0XHRcdGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4gfHwgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbjtcblx0XHRcdHJlcXVlc3QuY2FsbChkb2N1bWVudCk7IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcGVubGltZS1zY2FsZSA+IGxpbmUnKTtcblxuXHRcdFx0dGhpcy52aWV3ZXIucmVzaXplKGNhbnZhcy5vZmZzZXRXaWR0aCwgY2FudmFzLm9mZnNldEhlaWdodCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciByZXF1ZXN0ID0gZGl2LnJlcXVlc3RGdWxsc2NyZWVuIHx8IGRpdi53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiB8fFxuXHRcdFx0XHRkaXYubW96UmVxdWVzdEZ1bGxTY3JlZW4gfHwgZGl2Lm1zUmVxdWVzdEZ1bGxzY3JlZW47XG5cdFx0XHRyZXF1ZXN0LmNhbGwoZGl2KTtcblx0XHR9XG5cdFx0dGhpcy52aWV3ZXIucmVzaXplKGNhbnZhcy5vZmZzZXRXaWR0aCwgY2FudmFzLm9mZnNldEhlaWdodCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR0b2dnbGVSdWxlcigpIHtcblx0XHRpZighdGhpcy5ydWxlcikge1xuXHRcdFx0dGhpcy5ydWxlciA9IG5ldyBSdWxlcih0aGlzLnZpZXdlciwgdGhpcy5waXhlbFNpemUpO1xuXHRcdFx0dGhpcy52aWV3ZXIucG9pbnRlck1hbmFnZXIub25FdmVudCh0aGlzLnJ1bGVyKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYoIXRoaXMucnVsZXIuZW5hYmxlZClcblx0XHRcdHRoaXMucnVsZXIuc3RhcnQoKTtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLnJ1bGVyLmVuZCgpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0dG9nZ2xlSGVscChoZWxwLCBvbikge1xuXHRcdGlmKCFoZWxwLmRpYWxvZykge1xuXHRcdFx0aGVscC5kaWFsb2cgPSBuZXcgVUlEaWFsb2codGhpcy52aWV3ZXIuY29udGFpbmVyRWxlbWVudCwgeyBtb2RhbDogdHJ1ZSwgY2xhc3M6ICdvcGVubGltZS1oZWxwLWRpYWxvZycgfSk7XG5cdFx0XHRoZWxwLmRpYWxvZy5zZXRDb250ZW50KGhlbHAuaHRtbCk7XG5cdFx0fSBlbHNlXG5cdFx0XHRoZWxwLmRpYWxvZy50b2dnbGUob24pO1x0XHRcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHNuYXBzaG90KCkge1xuXHRcdHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdGUuc2V0QXR0cmlidXRlKCdocmVmJywgdGhpcy52aWV3ZXIuY2FudmFzLmNhbnZhc0VsZW1lbnQudG9EYXRhVVJMKCkpO1xuXHRcdGUuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsICdzbmFwc2hvdC5wbmcnKTtcblx0XHRlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTtcblx0XHRlLmNsaWNrKCk7XG5cdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlKTtcblx0fVxuXG5cdC8qIExheWVyIG1hbmFnZW1lbnQgKi9cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRjcmVhdGVFbnRyeShlbnRyeSkge1xuXHRcdGlmICghKCdpZCcgaW4gZW50cnkpKVxuXHRcdFx0ZW50cnkuaWQgPSAnZW50cnlfJyArICh0aGlzLmVudHJ5X2NvdW50KyspO1xuXG5cdFx0bGV0IGlkID0gYGlkPVwiJHtlbnRyeS5pZH1cImA7XG5cdFx0bGV0IHRvb2x0aXAgPSAndG9vbHRpcCcgaW4gZW50cnkgPyBgdGl0bGU9XCIke2VudHJ5LnRvb2x0aXB9XCJgIDogJyc7XG5cdFx0bGV0IGNsYXNzZXMgPSAnY2xhc3NlcycgaW4gZW50cnkgPyBlbnRyeS5jbGFzc2VzIDogJyc7XG5cdFx0bGV0IGh0bWwgPSAnJztcblx0XHRpZiAoJ3RpdGxlJyBpbiBlbnRyeSkge1xuXHRcdFx0aHRtbCArPSBgPGgyICR7aWR9IGNsYXNzPVwib3BlbmxpbWUtdGl0bGUgJHtjbGFzc2VzfVwiICR7dG9vbHRpcH0+JHtlbnRyeS50aXRsZX08L2gyPmA7XG5cblx0XHR9IGVsc2UgaWYgKCdzZWN0aW9uJyBpbiBlbnRyeSkge1xuXHRcdFx0aHRtbCArPSBgPGgzICR7aWR9IGNsYXNzPVwib3BlbmxpbWUtc2VjdGlvbiAke2NsYXNzZXN9XCIgJHt0b29sdGlwfT4ke2VudHJ5LnNlY3Rpb259PC9oMz5gO1xuXG5cdFx0fSBlbHNlIGlmICgnaHRtbCcgaW4gZW50cnkpIHtcblx0XHRcdGh0bWwgKz0gYDxkaXYgJHtpZH0gY2xhc3M9XCIke2NsYXNzZXN9XCI+JHtlbnRyeS5odG1sfTwvZGl2PmA7XG5cblx0XHR9IGVsc2UgaWYgKCdidXR0b24nIGluIGVudHJ5KSB7XG5cdFx0XHRsZXQgZ3JvdXAgPSAnZ3JvdXAnIGluIGVudHJ5ID8gYGRhdGEtZ3JvdXA9XCIke2VudHJ5Lmdyb3VwfVwiYCA6ICcnO1xuXHRcdFx0bGV0IGxheWVyID0gJ2xheWVyJyBpbiBlbnRyeSA/IGBkYXRhLWxheWVyPVwiJHtlbnRyeS5sYXllcn1cImAgOiAnJztcblx0XHRcdGxldCBtb2RlID0gJ21vZGUnIGluIGVudHJ5ID8gYGRhdGEtbW9kZT1cIiR7ZW50cnkubW9kZX1cImAgOiAnJztcblx0XHRcdGh0bWwgKz0gYDxhIGhyZWY9XCIjXCIgJHtpZH0gJHtncm91cH0gJHtsYXllcn0gJHttb2RlfSAke3Rvb2x0aXB9IGNsYXNzPVwib3BlbmxpbWUtZW50cnkgJHtjbGFzc2VzfVwiPiR7ZW50cnkuYnV0dG9ufTwvYT5gO1xuXHRcdH0gZWxzZSBpZiAoJ3NsaWRlcicgaW4gZW50cnkpIHtcblx0XHRcdGxldCB2YWx1ZSA9ICgndmFsdWUnIGluIGVudHJ5KSA/IGVudHJ5Wyd2YWx1ZSddIDogNTA7XG5cdFx0XHRodG1sICs9IGA8aW5wdXQgdHlwZT1cInJhbmdlXCIgbWluPVwiMVwiIG1heD1cIjEwMFwiIHZhbHVlPVwiJHt2YWx1ZX1cIiBjbGFzcz1cIm9wZW5saW1lLXNsaWRlciAke2NsYXNzZXN9XCIgJHtpZH0+YDtcblx0XHR9XG5cblx0XHRpZiAoJ2xpc3QnIGluIGVudHJ5KSB7XG5cdFx0XHRsZXQgdWwgPSBgPGRpdiBjbGFzcz1cIm9wZW5saW1lLWxpc3QgJHtjbGFzc2VzfVwiPmA7XG5cdFx0XHRmb3IgKGxldCBsaSBvZiBlbnRyeS5saXN0KVxuXHRcdFx0XHR1bCArPSB0aGlzLmNyZWF0ZUVudHJ5KGxpKTtcblx0XHRcdHVsICs9ICc8L2Rpdj4nO1xuXHRcdFx0aHRtbCArPSB1bDtcblx0XHR9XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRhZGRFbnRyeUNhbGxiYWNrcyhlbnRyeSkge1xuXHRcdGVudHJ5LmVsZW1lbnQgPSB0aGlzLmxheWVyTWVudS5xdWVyeVNlbGVjdG9yKCcjJyArIGVudHJ5LmlkKTtcblx0XHRpZiAoZW50cnkub25jbGljaylcblx0XHRcdGVudHJ5LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuXHRcdFx0XHRlbnRyeS5vbmNsaWNrKCk7XG5cdFx0XHRcdC8vdGhpcy51cGRhdGVNZW51KCk7XG5cdFx0XHR9KTtcblx0XHRpZiAoZW50cnkub25pbnB1dClcblx0XHRcdGVudHJ5LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBlbnRyeS5vbmlucHV0KTtcblx0XHRpZiAoZW50cnkub25jcmVhdGUpXG5cdFx0XHRlbnRyeS5vbmNyZWF0ZSgpO1xuXG5cdFx0aWYgKCdsaXN0JyBpbiBlbnRyeSlcblx0XHRcdGZvciAobGV0IGUgb2YgZW50cnkubGlzdClcblx0XHRcdFx0dGhpcy5hZGRFbnRyeUNhbGxiYWNrcyhlKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHVwZGF0ZUVudHJ5KGVudHJ5KSB7XG5cdFx0bGV0IHN0YXR1cyA9IGVudHJ5LnN0YXR1cyA/IGVudHJ5LnN0YXR1cygpIDogJyc7XG5cdFx0ZW50cnkuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnLCBzdGF0dXMgPT0gJ2FjdGl2ZScpO1xuXG5cdFx0aWYgKCdsaXN0JyBpbiBlbnRyeSlcblx0XHRcdGZvciAobGV0IGUgb2YgZW50cnkubGlzdClcblx0XHRcdFx0dGhpcy51cGRhdGVFbnRyeShlKTtcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHVwZGF0ZU1lbnUoKSB7XG5cdFx0Zm9yIChsZXQgZW50cnkgb2YgdGhpcy5tZW51KVxuXHRcdFx0dGhpcy51cGRhdGVFbnRyeShlbnRyeSk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRjcmVhdGVNZW51KCkge1xuXHRcdHRoaXMuZW50cnlfY291bnQgPSAwO1xuXHRcdGxldCBodG1sID0gYDxkaXYgY2xhc3M9XCJvcGVubGltZS1sYXllcnMtbWVudVwiPmA7XG5cdFx0Zm9yIChsZXQgZW50cnkgb2YgdGhpcy5tZW51KSB7XG5cdFx0XHRodG1sICs9IHRoaXMuY3JlYXRlRW50cnkoZW50cnkpO1xuXHRcdH1cblx0XHRodG1sICs9ICc8L2Rpdj4nO1xuXG5cblx0XHRsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRcdHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWwudHJpbSgpO1xuXHRcdHRoaXMubGF5ZXJNZW51ID0gdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkO1xuXHRcdHRoaXMudmlld2VyLmNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllck1lbnUpO1xuXG5cdFx0Zm9yIChsZXQgZW50cnkgb2YgdGhpcy5tZW51KSB7XG5cdFx0XHR0aGlzLmFkZEVudHJ5Q2FsbGJhY2tzKGVudHJ5KTtcblx0XHR9XG5cblxuXHRcdC8qXHRcdGZvcihsZXQgbGkgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbGF5ZXJdJykpXG5cdFx0XHRcdFx0bGkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRMYXllcih0aGlzLnZpZXdlci5jYW52YXMubGF5ZXJzW2xpLmdldEF0dHJpYnV0ZSgnZGF0YS1sYXllcicpXSk7XG5cdFx0XHRcdFx0fSk7ICovXG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHR0b2dnbGVMYXllcnMoKSB7XG5cdFx0dGhpcy5sYXllck1lbnUuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0c2V0TGF5ZXIobGF5ZXJfb24pIHtcblx0XHRpZiAodHlwZW9mIGxheWVyX29uID09ICdzdHJpbmcnKVxuXHRcdFx0bGF5ZXJfb24gPSB0aGlzLnZpZXdlci5jYW52YXMubGF5ZXJzW2xheWVyX29uXTtcblxuXHRcdGlmIChsYXllcl9vbi5vdmVybGF5KSB7IC8vanVzdCB0b2dnbGVcblx0XHRcdGxheWVyX29uLnNldFZpc2libGUoIWxheWVyX29uLnZpc2libGUpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAobGV0IGxheWVyIG9mIE9iamVjdC52YWx1ZXModGhpcy52aWV3ZXIuY2FudmFzLmxheWVycykpIHtcblx0XHRcdFx0aWYgKGxheWVyLm92ZXJsYXkpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0bGF5ZXIuc2V0VmlzaWJsZShsYXllciA9PSBsYXllcl9vbik7XG5cdFx0XHRcdGZvciAobGV0IGMgb2YgbGF5ZXIuY29udHJvbGxlcnMpIHtcblx0XHRcdFx0XHRpZiAoYy5jb250cm9sID09ICdsaWdodCcpXG5cdFx0XHRcdFx0XHRjLmFjdGl2ZSA9IHRoaXMubGlnaHRBY3RpdmUgJiYgbGF5ZXIgPT0gbGF5ZXJfb247XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy51cGRhdGVNZW51KCk7XG5cdFx0dGhpcy52aWV3ZXIucmVkcmF3KCk7XG5cdH1cblxuXHQvKiogQGlnbm9yZSAqL1xuXHRjbG9zZUxheWVyc01lbnUoKSB7XG5cdFx0dGhpcy5sYXllck1lbnUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0fVxufVxuXG4vKipcbiAqIEEgKipVSURpYWxvZyoqIGlzIGEgdG9wLWxldmVsIHdpbmRvdyB1c2VkIGZvciBjb21tdW5pY2F0aW9ucyB3aXRoIHRoZSB1c2VyLiBJdCBtYXkgYmUgbW9kYWwgb3IgbW9kZWxlc3MuXG4gKiBUaGUgY29udGVudCBvZiB0aGUgZGlhbG9nIGNhbiBiZSBlaXRoZXIgYW4gSFRNTCB0ZXh0IG9yIGEgcHJlLWJ1aWx0IERPTSBlbGVtZW50LlxuICogV2hlbiBoaWRkZW4sIGEgZGlhbG9nIGVtaXRzIGEgJ2Nsb3NlZCcgZXZlbnQuXG4gKi9cbmNsYXNzIFVJRGlhbG9nIHsgLy9GSVhNRSBzdGFuZGFsb25lIGNsYXNzXG5cdC8qKlxuXHQgKiBJbnN0YXRpYXRlcyBhIFVJRGlhbG9nIG9iamVjdC5cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBIVE1MRWxlbWVudCBvbiB3aGljaCB0aGUgZGlhbG9nIGlzIGZvY3VzZWRcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIFVJRGlhbG9nIHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7Ym9vbH0gb3B0aW9ucy5tb2RhbCBXaGV0aGVyIHRoZSBkaWFsb2cgaXMgbW9kYWwuIFxuXHQgKi9cblx0Y29uc3RydWN0b3IoY29udGFpbmVyLCBvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XG5cdFx0XHRkaWFsb2c6IG51bGwsXG5cdFx0XHRjb250ZW50OiBudWxsLFxuXHRcdFx0Y29udGFpbmVyOiBjb250YWluZXIsXG5cdFx0XHRtb2RhbDogZmFsc2UsXG5cdFx0XHRjbGFzczogbnVsbCxcblx0XHRcdHZpc2libGU6IGZhbHNlLFxuXHRcdFx0YmFja2Ryb3BFdmVudHM6IHRydWVcblx0XHR9LCBvcHRpb25zKTtcblx0XHR0aGlzLmNyZWF0ZSgpO1xuXHR9XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0Y3JlYXRlKCkge1xuXHRcdGxldCBiYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0YmFja2dyb3VuZC5jbGFzc0xpc3QuYWRkKCdvcGVubGltZS1kaWFsb2ctYmFja2dyb3VuZCcpO1xuXG5cdFx0bGV0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdvcGVubGltZS1kaWFsb2cnKTtcblx0XHRpZiAodGhpcy5jbGFzcylcblx0XHRcdGRpYWxvZy5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3MpO1xuXG5cdFx0KGFzeW5jICgpID0+IHtcblx0XHRcdGxldCBjbG9zZSA9IGF3YWl0IFNraW4uYXBwZW5kSWNvbihkaWFsb2csICcub3BlbmxpbWUtY2xvc2UnKTtcblx0XHRcdGNsb3NlLmNsYXNzTGlzdC5hZGQoJ29wZW5saW1lLWNsb3NlJyk7XG5cdFx0XHRjbG9zZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuaGlkZSgpKTtcblx0XHRcdC8vY29udGVudC5hcHBlbmRDaGlsZChjbG9zZSk7XG5cdFx0fSkoKTtcblxuXG5cdFx0Ly8gbGV0IGNsb3NlID0gU2tpbi5hcHBlbmRJY29uKGRpYWxvZywgJy5vcGVubGltZS1jbG9zZScpO1xuXHRcdC8vIGNsb3NlLmNsYXNzTGlzdC5hZGQoJ29wZW5saW1lLWNsb3NlJyk7XG5cdFx0Ly8gY2xvc2UuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhpZGUoKSk7XG5cblx0XHRsZXQgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnb3BlbmxpbWUtZGlhbG9nLWNvbnRlbnQnKTtcblx0XHRkaWFsb2cuYXBwZW5kKGNvbnRlbnQpO1xuXG5cdFx0aWYgKHRoaXMubW9kYWwpIHsgLy9GSVhNRSBiYWNrZHJvd24gPT4gYmFja2Ryb3Bcblx0XHRcdGlmKHRoaXMuYmFja2Ryb3BFdmVudHMpIGJhY2tncm91bmQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4geyBpZiAoZS50YXJnZXQgPT0gYmFja2dyb3VuZCkgdGhpcy5oaWRlKCk7IH0pO1xuXHRcdFx0YmFja2dyb3VuZC5hcHBlbmRDaGlsZChkaWFsb2cpO1xuXHRcdFx0dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBiYWNrZ3JvdW5kO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkaWFsb2cpO1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gZGlhbG9nO1xuXHRcdH1cblxuXHRcdHRoaXMuZGlhbG9nID0gZGlhbG9nO1xuXHRcdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0dGhpcy5oaWRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgZGlhbG9nLlxuXHQgKiBAcGFyYW0geyhzdHJpbmd8SFRNTEVsZW1lbnQpfSBodG1sIFRoZSBjb250ZW50IG9mIHRoZSBkaWFsb2cgKGEgSFRNTCB0ZXh0IG9yIGVsZW1lbnQpLiBcblx0ICovXG5cdHNldENvbnRlbnQoaHRtbCkge1xuXHRcdGlmICh0eXBlb2YgKGh0bWwpID09ICdzdHJpbmcnKVxuXHRcdFx0dGhpcy5jb250ZW50LmlubmVySFRNTCA9IGh0bWw7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5jb250ZW50LnJlcGxhY2VDaGlsZHJlbihodG1sKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNob3dzIHRoZSBkaWFsb2cuXG5cdCAqL1xuXHRzaG93KCkge1xuXHRcdHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcblx0XHR0aGlzLnZpc2libGU9dHJ1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEhpZGVzIHRoZSBkaWFsb2cuXG5cdCAqL1xuXHRoaWRlKCkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlxuXHRcdCAqIEBldmVudCBVSURpYWxvZyNjbG9zZWRcblx0XHQgKi9cblx0XHR0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG5cdFx0dGhpcy52aXNpYmxlPWZhbHNlO1xuXHRcdHRoaXMuZW1pdCgnY2xvc2VkJyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGRzIGZhZGluZyBlZmZlY3QgdG8gdGhlIGRpYWxvZy5cblx0ICogQHBhcmFtIHtib29sfSBvbiBXaGV0aGVyIHRoZSBmYWRpbmcgZWZmZWN0IGlzIGVuYWJsZWQuXG5cdCAqL1xuXHRmYWRlKG9uKSB7IC8vRklYTUUgRG9lcyBpdCB3b3JrP1xuXHRcdHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdmYWRpbmcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGVzIHRoZSBkaXNwbGF5IG9mIHRoZSBkaWFsb2cuXG5cdCAqIEBwYXJhbSB7Ym9vbH0gZm9yY2UgV2hldGhlciB0byB0dXJuIHRoZSBkaWFsb2cgaW50byBhIG9uZSB3YXktb25seSBvcGVyYXRpb24uXG5cdCAqL1xuXHR0b2dnbGUoZm9yY2UpIHsgLy9GSVhNRSBXaHkgbm90IHJlbW92ZSBmb3JjZT9cblx0XHR0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgnaGlkZGVuJywgZm9yY2UpO1xuXHRcdHRoaXMudmlzaWJsZSA9ICF0aGlzLnZpc2libGU7IC8vRklYTUUgbm90IGluIHN5bmMgd2l0aCAnZm9yY2UnXG5cdH1cbn1cblxuYWRkU2lnbmFscyhVSURpYWxvZywgJ2Nsb3NlZCcpO1xuXG5leHBvcnQgeyBVSUJhc2ljLCBVSURpYWxvZyB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/UIBasic.js\n");

/***/ }),

/***/ "./src/Util.js":
/*!*********************!*\
  !*** ./src/Util.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Util\": () => (/* binding */ Util)\n/* harmony export */ });\n// HELPERS\nwindow.structuredClone = typeof(structuredClone) == \"function\" ? structuredClone : function (value) { return  JSON.parse(JSON.stringify(value)); };\n\n// Utilities\nclass Util {\n\n    static createSVGElement(tag, attributes) {\n        let e = document.createElementNS('http://www.w3.org/2000/svg', tag);\n        if (attributes)\n            for (const [key, value] of Object.entries(attributes))\n                e.setAttribute(key, value);\n        return e;\n    }\n    \n    static SVGFromString(text) {\n\t\tconst parser = new DOMParser();\n\t\treturn parser.parseFromString(text, \"image/svg+xml\").documentElement;\n\t}\n\n    static async loadSVG(url) {\n        let response = await fetch(url);\n        if (!response.ok) {\n            const message = `An error has occured: ${response.status}`;\n            throw new Error(message);\n        }\n        let data = await response.text();\n        let result = null;\n        if(Util.isSVGString(data)) {\n            result = Util.SVGFromString(data);\n        } else {\n            const message = `${url} is not an SVG file`;\n            throw new Error(message);\n        }\n        return result;\n    };\n\n    static async loadHTML(url) {\n        let response = await fetch(url);\n        if (!response.ok) {\n            const message = `An error has occured: ${response.status}`;\n            throw new Error(message);\n        }\n        let data = await response.text();\n        return data;\n    };\n    \n    static async loadJSON(url) {\n        let response = await fetch(url);\n        if (!response.ok) {\n            const message = `An error has occured: ${response.status}`;\n            throw new Error(message);\n        }\n        let data = await response.json();\n        return data;\n    }\n    \n    static async loadImage(url) {\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.addEventListener('load', () => resolve(img));\n            img.addEventListener('error', (err) => reject(err));\n            img.src = url;\n        });\n    }\n    \n    static async appendImg(container, url, imgClass = null) {\n        const img = await Util.loadImage(url);\n        if (imgClass) img.classList.add(imgClass);\n        container.appendChild(img);\n    }\n    \n    static async appendImgs(container, urls, imgClass = null) {\n        for (const u of urls) {\n            const img = await Util.loadImage(u);\n            if (imgClass) img.classList.add(imgClass);\n            container.appendChild(img);\n        }\n    }\n    \n    static isSVGString(input) {\n        const regex = /^\\s*(?:<\\?xml[^>]*>\\s*)?(?:<!doctype svg[^>]*\\s*(?:\\[?(?:\\s*<![^>]*>\\s*)*\\]?)*[^>]*>\\s*)?(?:<svg[^>]*>[^]*<\\/svg>|<svg[^/>]*\\/\\s*>)\\s*$/i\n        if (input == undefined || input == null)\n            return false;\n        input = input.toString().replace(/\\s*<!Entity\\s+\\S*\\s*(?:\"|')[^\"]+(?:\"|')\\s*>/img, '');\n        input = input.replace(/<!--([\\s\\S]*?)-->/g, '');\n        return Boolean(input) && regex.test(input);\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxzR0FBc0c7O0FBRXRHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvVXRpbC5qcz84YmY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEhFTFBFUlNcbndpbmRvdy5zdHJ1Y3R1cmVkQ2xvbmUgPSB0eXBlb2Yoc3RydWN0dXJlZENsb25lKSA9PSBcImZ1bmN0aW9uXCIgPyBzdHJ1Y3R1cmVkQ2xvbmUgOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7IH07XG5cbi8vIFV0aWxpdGllc1xuY2xhc3MgVXRpbCB7XG5cbiAgICBzdGF0aWMgY3JlYXRlU1ZHRWxlbWVudCh0YWcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbGV0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSlcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIFxuICAgIHN0YXRpYyBTVkdGcm9tU3RyaW5nKHRleHQpIHtcblx0XHRjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0cmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJpbWFnZS9zdmcreG1sXCIpLmRvY3VtZW50RWxlbWVudDtcblx0fVxuXG4gICAgc3RhdGljIGFzeW5jIGxvYWRTVkcodXJsKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQW4gZXJyb3IgaGFzIG9jY3VyZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZihVdGlsLmlzU1ZHU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBVdGlsLlNWR0Zyb21TdHJpbmcoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7dXJsfSBpcyBub3QgYW4gU1ZHIGZpbGVgO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHN0YXRpYyBhc3luYyBsb2FkSFRNTCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBBbiBlcnJvciBoYXMgb2NjdXJlZDogJHtyZXNwb25zZS5zdGF0dXN9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBcbiAgICBzdGF0aWMgYXN5bmMgbG9hZEpTT04odXJsKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQW4gZXJyb3IgaGFzIG9jY3VyZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBcbiAgICBzdGF0aWMgYXN5bmMgbG9hZEltYWdlKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHJlc29sdmUoaW1nKSk7XG4gICAgICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXJyKSA9PiByZWplY3QoZXJyKSk7XG4gICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgc3RhdGljIGFzeW5jIGFwcGVuZEltZyhjb250YWluZXIsIHVybCwgaW1nQ2xhc3MgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGltZyA9IGF3YWl0IFV0aWwubG9hZEltYWdlKHVybCk7XG4gICAgICAgIGlmIChpbWdDbGFzcykgaW1nLmNsYXNzTGlzdC5hZGQoaW1nQ2xhc3MpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9XG4gICAgXG4gICAgc3RhdGljIGFzeW5jIGFwcGVuZEltZ3MoY29udGFpbmVyLCB1cmxzLCBpbWdDbGFzcyA9IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCB1IG9mIHVybHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGF3YWl0IFV0aWwubG9hZEltYWdlKHUpO1xuICAgICAgICAgICAgaWYgKGltZ0NsYXNzKSBpbWcuY2xhc3NMaXN0LmFkZChpbWdDbGFzcyk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzdGF0aWMgaXNTVkdTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSAvXlxccyooPzo8XFw/eG1sW14+XSo+XFxzKik/KD86PCFkb2N0eXBlIHN2Z1tePl0qXFxzKig/OlxcWz8oPzpcXHMqPCFbXj5dKj5cXHMqKSpcXF0/KSpbXj5dKj5cXHMqKT8oPzo8c3ZnW14+XSo+W15dKjxcXC9zdmc+fDxzdmdbXi8+XSpcXC9cXHMqPilcXHMqJC9pXG4gICAgICAgIGlmIChpbnB1dCA9PSB1bmRlZmluZWQgfHwgaW5wdXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC50b1N0cmluZygpLnJlcGxhY2UoL1xccyo8IUVudGl0eVxccytcXFMqXFxzKig/OlwifCcpW15cIl0rKD86XCJ8JylcXHMqPi9pbWcsICcnKTtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICcnKTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oaW5wdXQpICYmIHJlZ2V4LnRlc3QoaW5wdXQpO1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBVdGlsIH0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Util.js\n");

/***/ }),

/***/ "./src/Viewer.js":
/*!***********************!*\
  !*** ./src/Viewer.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Viewer\": () => (/* binding */ Viewer)\n/* harmony export */ });\n/* harmony import */ var _Canvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Canvas.js */ \"./src/Canvas.js\");\n/* harmony import */ var _Camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Camera.js */ \"./src/Camera.js\");\n/* harmony import */ var _PointerManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PointerManager.js */ \"./src/PointerManager.js\");\n/* harmony import */ var _Controller_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Controller.js */ \"./src/Controller.js\");\n/* harmony import */ var _Signals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signals.js */ \"./src/Signals.js\");\n\n\n\n\n\n\n\n/** **Viewer** is the central class of the OpenLIME framework. It is used to create a viewer on a web page and manipulate it.\n * In the following example, after instantiating a Viewer, a LayerImage is added to it.\n * ```\n * // Create an OpenLIME canvas into .openlime\n * const lime = new OpenLIME.Viewer('.openlime');\n *\n * // Create an image layer and add it to the canvans\n * const layer = new OpenLIME.Layer({\n *     layout: 'image',\n *     type: 'image',\n *     url: '../../assets/lime/image/lime.jpg'\n * });\n * lime.addLayer('Base', layer);\n * \n * // Access to internal structures\n * const camera = lime.camera;\n * const canvas = lime.canvas;\n * const layers = canvas.layers;\n * ```\n*/\nclass Viewer {\n    /**\n     * Instantiates a viewer object given the `div` element or a DOM selector of a `div` element.\n     * Additionally, an object literal with Viewer `options` can be specified.\n     * The class creates the canvas, enables the WebGL context and takes care of the content redrawing when needed.\n     * Viewer is the main class of the OpenLIME framework. It allows access to all the internal structures that make up the system.\n     * \n     * @param {(HTMLElement|string)} div A DOM element or a selector (es. '#openlime' or '.openlime').\n     * @param {Object} [options]  An object literal describing the viewer content.\n     * @param {color} options.background CSS style for background (it overwrites CSS if present).\n     * @param {bool} options.autofit=true Whether the initial position of the camera is set to fit the scene model.\n    */\n    constructor(div, options) {\n\n        Object.assign(this, {\n            background: null,\n            autofit: true,\n            canvas: {},\n            camera: new _Camera_js__WEBPACK_IMPORTED_MODULE_1__.Camera(),\n        });\n        if (typeof (div) == 'string')\n            div = document.querySelector(div);\n\n        if (!div)\n            throw \"Missing element parameter\";\n\n        Object.assign(this, options);\n        if (this.background)\n            div.style.background = this.background;\n\n        this.containerElement = div;\n        this.canvasElement = div.querySelector('canvas');\n        if (!this.canvasElement) {\n            this.canvasElement = document.createElement('canvas');\n            div.prepend(this.canvasElement);\n        }\n\n        this.overlayElement = document.createElement('div');\n        this.overlayElement.classList.add('openlime-overlay');\n        this.containerElement.appendChild(this.overlayElement);\n\n        this.canvas = new _Canvas_js__WEBPACK_IMPORTED_MODULE_0__.Canvas(this.canvasElement, this.overlayElement, this.camera, this.canvas);\n        this.canvas.addEvent('update', () => { this.redraw(); });\n\n        if (this.autofit)\n            this.canvas.addEvent('updateSize', () => this.camera.fitCameraBox(0));\n\n        this.pointerManager = new _PointerManager_js__WEBPACK_IMPORTED_MODULE_2__.PointerManager(this.overlayElement);\n\n        this.canvasElement.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n            return false;\n        });\n\n        var resizeobserver = new ResizeObserver(entries => {\n            for (let entry of entries) {\n                this.resize(entry.contentRect.width, entry.contentRect.height);\n            }\n        });\n        resizeobserver.observe(this.canvasElement);\n\n        this.resize(this.canvasElement.clientWidth, this.canvasElement.clientHeight);\n    }\n\n    /**\n     * Adds a device event controller to the viewer.\n     * @param {Controller} controller An OpenLIME controller.\n     */\n    addController(controller) {\n        this.pointerManager.onEvent(controller);\n    }\n\n    /** Adds the given layer to the Viewer.\n    * @param {string} id A label to identify the layer.\n    * @param {Layer} layer An OpenLIME Layer object.\n    */\n    addLayer(id, layer) {\n        this.canvas.addLayer(id, layer);\n        this.redraw();\n    }\n\n    /** Remove the given layer from the Viewer.\n    * @param {(Layer|string)} layer An OpenLIME Layer or a Layer identifier.\n    */\n    removeLayer(layer) {\n        if (typeof (layer) == 'string')\n            layer = this.canvas.layers[layer];\n        if (layer) {\n            this.canvas.removeLayer(layer);\n            this.redraw();\n        }\n    }\n\n    /* Resizes the canvas (and the overlay) and triggers a redraw.\n     * This method is internal and used by a ResizeObserver of the Canvas size.\n     * @param {number} width A width value defined in CSS pixel.\n     * @param {number} height A height value defined in CSS pixel.\n    */\n    /**\n     * @ignore\n    */\n    resize(width, height) {\n        // Test with retina display!\n        this.canvasElement.width = width * window.devicePixelRatio;\n        this.canvasElement.height = height * window.devicePixelRatio;\n\n        this.camera.setViewport({ x: 0, y: 0, dx: width, dy: height, w: width, h: height });\n    \n        this.canvas.prefetch();\n        this.redraw();\n    }\n\n    /**\n     * Schedules a redrawing.\n    */\n    redraw() {\n        if (this.animaterequest) return;\n        this.animaterequest = requestAnimationFrame((time) => { this.draw(time); });\n    }\n\n    /*\n     * Renders the canvas content.\n     * This method is internal.\n     * @param {time} time The current time (a DOMHighResTimeStamp variable, as in `performance.now()`).\n    */\n    /**\n    * @ignore\n   */\n    draw(time) {\n        if (!time) time = performance.now();\n        this.animaterequest = null;\n\n        let viewport = this.camera.viewport;\n        let transform = this.camera.getCurrentTransform(time);\n\n        let done = this.canvas.draw(time);\n        if (!done)\n            this.redraw();\n        this.emit('draw');\n    }\n}\n\n(0,_Signals_js__WEBPACK_IMPORTED_MODULE_4__.addSignals)(Viewer, 'draw');\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVmlld2VyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvQztBQUNBO0FBQ2dCO0FBQ1A7QUFDSjs7O0FBR3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsd0JBQXdCLDhDQUFNO0FBQzlCLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLDhDQUFNO0FBQ2hDLCtDQUErQyxnQkFBZ0I7O0FBRS9EO0FBQ0E7O0FBRUEsa0NBQWtDLDhEQUFjOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx3REFBd0Q7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvVmlld2VyLmpzP2Q0YzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FudmFzIH0gZnJvbSAnLi9DYW52YXMuanMnXG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tICcuL0NhbWVyYS5qcydcbmltcG9ydCB7IFBvaW50ZXJNYW5hZ2VyIH0gZnJvbSAnLi9Qb2ludGVyTWFuYWdlci5qcydcbmltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICcuL0NvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHsgYWRkU2lnbmFscyB9IGZyb20gJy4vU2lnbmFscy5qcydcblxuXG4vKiogKipWaWV3ZXIqKiBpcyB0aGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgT3BlbkxJTUUgZnJhbWV3b3JrLiBJdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIHZpZXdlciBvbiBhIHdlYiBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBhZnRlciBpbnN0YW50aWF0aW5nIGEgVmlld2VyLCBhIExheWVySW1hZ2UgaXMgYWRkZWQgdG8gaXQuXG4gKiBgYGBcbiAqIC8vIENyZWF0ZSBhbiBPcGVuTElNRSBjYW52YXMgaW50byAub3BlbmxpbWVcbiAqIGNvbnN0IGxpbWUgPSBuZXcgT3BlbkxJTUUuVmlld2VyKCcub3BlbmxpbWUnKTtcbiAqXG4gKiAvLyBDcmVhdGUgYW4gaW1hZ2UgbGF5ZXIgYW5kIGFkZCBpdCB0byB0aGUgY2FudmFuc1xuICogY29uc3QgbGF5ZXIgPSBuZXcgT3BlbkxJTUUuTGF5ZXIoe1xuICogICAgIGxheW91dDogJ2ltYWdlJyxcbiAqICAgICB0eXBlOiAnaW1hZ2UnLFxuICogICAgIHVybDogJy4uLy4uL2Fzc2V0cy9saW1lL2ltYWdlL2xpbWUuanBnJ1xuICogfSk7XG4gKiBsaW1lLmFkZExheWVyKCdCYXNlJywgbGF5ZXIpO1xuICogXG4gKiAvLyBBY2Nlc3MgdG8gaW50ZXJuYWwgc3RydWN0dXJlc1xuICogY29uc3QgY2FtZXJhID0gbGltZS5jYW1lcmE7XG4gKiBjb25zdCBjYW52YXMgPSBsaW1lLmNhbnZhcztcbiAqIGNvbnN0IGxheWVycyA9IGNhbnZhcy5sYXllcnM7XG4gKiBgYGBcbiovXG5jbGFzcyBWaWV3ZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIHZpZXdlciBvYmplY3QgZ2l2ZW4gdGhlIGBkaXZgIGVsZW1lbnQgb3IgYSBET00gc2VsZWN0b3Igb2YgYSBgZGl2YCBlbGVtZW50LlxuICAgICAqIEFkZGl0aW9uYWxseSwgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBWaWV3ZXIgYG9wdGlvbnNgIGNhbiBiZSBzcGVjaWZpZWQuXG4gICAgICogVGhlIGNsYXNzIGNyZWF0ZXMgdGhlIGNhbnZhcywgZW5hYmxlcyB0aGUgV2ViR0wgY29udGV4dCBhbmQgdGFrZXMgY2FyZSBvZiB0aGUgY29udGVudCByZWRyYXdpbmcgd2hlbiBuZWVkZWQuXG4gICAgICogVmlld2VyIGlzIHRoZSBtYWluIGNsYXNzIG9mIHRoZSBPcGVuTElNRSBmcmFtZXdvcmsuIEl0IGFsbG93cyBhY2Nlc3MgdG8gYWxsIHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmVzIHRoYXQgbWFrZSB1cCB0aGUgc3lzdGVtLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fHN0cmluZyl9IGRpdiBBIERPTSBlbGVtZW50IG9yIGEgc2VsZWN0b3IgKGVzLiAnI29wZW5saW1lJyBvciAnLm9wZW5saW1lJykuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQW4gb2JqZWN0IGxpdGVyYWwgZGVzY3JpYmluZyB0aGUgdmlld2VyIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtjb2xvcn0gb3B0aW9ucy5iYWNrZ3JvdW5kIENTUyBzdHlsZSBmb3IgYmFja2dyb3VuZCAoaXQgb3ZlcndyaXRlcyBDU1MgaWYgcHJlc2VudCkuXG4gICAgICogQHBhcmFtIHtib29sfSBvcHRpb25zLmF1dG9maXQ9dHJ1ZSBXaGV0aGVyIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBjYW1lcmEgaXMgc2V0IHRvIGZpdCB0aGUgc2NlbmUgbW9kZWwuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkaXYsIG9wdGlvbnMpIHtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IG51bGwsXG4gICAgICAgICAgICBhdXRvZml0OiB0cnVlLFxuICAgICAgICAgICAgY2FudmFzOiB7fSxcbiAgICAgICAgICAgIGNhbWVyYTogbmV3IENhbWVyYSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZGl2KSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGl2KTtcblxuICAgICAgICBpZiAoIWRpdilcbiAgICAgICAgICAgIHRocm93IFwiTWlzc2luZyBlbGVtZW50IHBhcmFtZXRlclwiO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmJhY2tncm91bmQpXG4gICAgICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZDtcblxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBkaXY7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGRpdi5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZGl2LnByZXBlbmQodGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3ZlcmxheUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5vdmVybGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdvcGVubGltZS1vdmVybGF5Jyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlFbGVtZW50KTtcblxuICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcy5jYW52YXNFbGVtZW50LCB0aGlzLm92ZXJsYXlFbGVtZW50LCB0aGlzLmNhbWVyYSwgdGhpcy5jYW52YXMpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudCgndXBkYXRlJywgKCkgPT4geyB0aGlzLnJlZHJhdygpOyB9KTtcblxuICAgICAgICBpZiAodGhpcy5hdXRvZml0KVxuICAgICAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnQoJ3VwZGF0ZVNpemUnLCAoKSA9PiB0aGlzLmNhbWVyYS5maXRDYW1lcmFCb3goMCkpO1xuXG4gICAgICAgIHRoaXMucG9pbnRlck1hbmFnZXIgPSBuZXcgUG9pbnRlck1hbmFnZXIodGhpcy5vdmVybGF5RWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlc2l6ZW9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoLCBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzaXplb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNhbnZhc0VsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMuY2FudmFzRWxlbWVudC5jbGllbnRXaWR0aCwgdGhpcy5jYW52YXNFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGRldmljZSBldmVudCBjb250cm9sbGVyIHRvIHRoZSB2aWV3ZXIuXG4gICAgICogQHBhcmFtIHtDb250cm9sbGVyfSBjb250cm9sbGVyIEFuIE9wZW5MSU1FIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgYWRkQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMucG9pbnRlck1hbmFnZXIub25FdmVudChjb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICAvKiogQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIFZpZXdlci5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIGxhYmVsIHRvIGlkZW50aWZ5IHRoZSBsYXllci5cbiAgICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIEFuIE9wZW5MSU1FIExheWVyIG9iamVjdC5cbiAgICAqL1xuICAgIGFkZExheWVyKGlkLCBsYXllcikge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRMYXllcihpZCwgbGF5ZXIpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKiBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIFZpZXdlci5cbiAgICAqIEBwYXJhbSB7KExheWVyfHN0cmluZyl9IGxheWVyIEFuIE9wZW5MSU1FIExheWVyIG9yIGEgTGF5ZXIgaWRlbnRpZmllci5cbiAgICAqL1xuICAgIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGxheWVyKSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGxheWVyID0gdGhpcy5jYW52YXMubGF5ZXJzW2xheWVyXTtcbiAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogUmVzaXplcyB0aGUgY2FudmFzIChhbmQgdGhlIG92ZXJsYXkpIGFuZCB0cmlnZ2VycyBhIHJlZHJhdy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlcm5hbCBhbmQgdXNlZCBieSBhIFJlc2l6ZU9ic2VydmVyIG9mIHRoZSBDYW52YXMgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggQSB3aWR0aCB2YWx1ZSBkZWZpbmVkIGluIENTUyBwaXhlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEEgaGVpZ2h0IHZhbHVlIGRlZmluZWQgaW4gQ1NTIHBpeGVsLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICovXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gVGVzdCB3aXRoIHJldGluYSBkaXNwbGF5IVxuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggPSB3aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cbiAgICAgICAgdGhpcy5jYW1lcmEuc2V0Vmlld3BvcnQoeyB4OiAwLCB5OiAwLCBkeDogd2lkdGgsIGR5OiBoZWlnaHQsIHc6IHdpZHRoLCBoOiBoZWlnaHQgfSk7XG4gICAgXG4gICAgICAgIHRoaXMuY2FudmFzLnByZWZldGNoKCk7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgcmVkcmF3aW5nLlxuICAgICovXG4gICAgcmVkcmF3KCkge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRlcmVxdWVzdCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmFuaW1hdGVyZXF1ZXN0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lKSA9PiB7IHRoaXMuZHJhdyh0aW1lKTsgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBSZW5kZXJzIHRoZSBjYW52YXMgY29udGVudC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlcm5hbC5cbiAgICAgKiBAcGFyYW0ge3RpbWV9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSAoYSBET01IaWdoUmVzVGltZVN0YW1wIHZhcmlhYmxlLCBhcyBpbiBgcGVyZm9ybWFuY2Uubm93KClgKS5cbiAgICAqL1xuICAgIC8qKlxuICAgICogQGlnbm9yZVxuICAgKi9cbiAgICBkcmF3KHRpbWUpIHtcbiAgICAgICAgaWYgKCF0aW1lKSB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuYW5pbWF0ZXJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgIGxldCB2aWV3cG9ydCA9IHRoaXMuY2FtZXJhLnZpZXdwb3J0O1xuICAgICAgICBsZXQgdHJhbnNmb3JtID0gdGhpcy5jYW1lcmEuZ2V0Q3VycmVudFRyYW5zZm9ybSh0aW1lKTtcblxuICAgICAgICBsZXQgZG9uZSA9IHRoaXMuY2FudmFzLmRyYXcodGltZSk7XG4gICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIHRoaXMuZW1pdCgnZHJhdycpO1xuICAgIH1cbn1cblxuYWRkU2lnbmFscyhWaWV3ZXIsICdkcmF3Jyk7XG5cbmV4cG9ydCB7IFZpZXdlciB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Viewer.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Viewer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Viewer.js */ \"./src/Viewer.js\");\n/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ \"./src/Layer.js\");\n/* harmony import */ var _LayerImage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LayerImage.js */ \"./src/LayerImage.js\");\n/* harmony import */ var _LayerDstretch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LayerDstretch.js */ \"./src/LayerDstretch.js\");\n/* harmony import */ var _LayerCombiner_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LayerCombiner.js */ \"./src/LayerCombiner.js\");\n/* harmony import */ var _ShaderCombiner_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShaderCombiner.js */ \"./src/ShaderCombiner.js\");\n/* harmony import */ var _ControllerPanZoom_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ControllerPanZoom.js */ \"./src/ControllerPanZoom.js\");\n/* harmony import */ var _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UIBasic.js */ \"./src/UIBasic.js\");\n/* harmony import */ var _LayerLens_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LayerLens.js */ \"./src/LayerLens.js\");\n/* harmony import */ var _Skin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Skin.js */ \"./src/Skin.js\");\n/* harmony import */ var _LayerAnnotation_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LayerAnnotation.js */ \"./src/LayerAnnotation.js\");\n/* harmony import */ var _LayerSvgAnnotation_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LayerSvgAnnotation.js */ \"./src/LayerSvgAnnotation.js\");\n/* harmony import */ var _EditorSvgAnnotation_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./EditorSvgAnnotation.js */ \"./src/EditorSvgAnnotation.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet lime = new _Viewer_js__WEBPACK_IMPORTED_MODULE_0__.Viewer('.openlime', { background: 'black', canvas: { preserveDrawingBuffer: true} });\n\ndstretchTest();\n//combinerTest();\n//imageTest('google'); // image google deepzoom deepzoom1px zoomify iiif tarzoon itarzoom\n//flipTest();\n//brdfTest();\n//rtiTest('rbf');\n//tomeTest();\n//testUIBasic();\n\n//testUISvg();\n//lensTest();\n//testSVGAnnotations();\n\n//testMedicalAnnotations();\n\n//testAnnotationEditor();\n\nfunction dstretchTest() {\n\tconsole.log(\"Dstretching\");\n\n\tlet dstretch = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({\n\t\ttype: 'dstretch',\n\t\tlayout: 'image',\n\t\turl: 'assets/dstretch/coin/plane_0.jpg'\n\t});\n\n\tlime.canvas.addLayer('dstretch', dstretch);\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\tui.actions.light.active = true;\n}\n\nfunction testAnnotationEditor() {\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({ \n\t\tlabel: 'Coin 10',\n\t\tlayout: 'image', \n\t\ttype:'rti',\n\t\turl: 'assets/rti/hsh/info.json',\n\t\tnormals: false\n\t});\n\tlime.canvas.addLayer('hsh', layer0);\n\t\n\tlet layer1 = new _LayerSvgAnnotation_js__WEBPACK_IMPORTED_MODULE_11__.LayerSvgAnnotation({ \n\t\tlabel: 'Annotations',\n\t\tviewBox: \"0 0 256 256\",\n\t\tstyle:` \n\t\t\t.openlime-annotation { pointer-events:all; opacity: 0.7; }\n\t\t\t.openlime-annotation:hover { cursor:pointer; opacity: 1.0; }\n\t\t\t\n\t\t\t:focus { fill:yellow; }\n\t\t\tpolyline, path { fill:none; stroke-width:1; stroke:#800; vector-effect:non-scaling-stroke; pointer-events:all; }\n\t\t\tpolyline, path:hover { cursor:pointer; stroke:#f00; }\n\n\t\t\trect { fill:rgba(255, 0, 0, 0.2); stroke:rgba(127, 0, 0, 0.7); vector-effect:non-scaling-stroke;}\n\t\t\tcircle { fill:rgba(255, 0, 0, 0.2); stroke:#800; stroke-width:1px; vector-effect:non-scaling-stroke; }\n\t\t\tcircle.point { stroke-width:10px }\n\t\t\t.selected { fill:#ffaaaa; stroke:$ff0000 }\n\t\t`,\n\t\tinfoTemplate: (annotation) => { return `\n\t\t\t<h3>${annotation.class}</h3>\n\t\t\t<p>${annotation.description}</p>\n\t\t\t\n\t\t`; },\n\t\tannotations: 'assets/medical/PH1101-1.json',\n\t\teditable: true,\n\n\t}); \n\tlime.canvas.addLayer('anno', layer1); //here the overlayelement created and attached to layer1\n\t_Skin_js__WEBPACK_IMPORTED_MODULE_9__.Skin.setUrl('skin/skin.svg');\n\n\tlet editor = new _EditorSvgAnnotation_js__WEBPACK_IMPORTED_MODULE_12__.EditorSvgAnnotation(lime, layer1, { lime: lime });\n\teditor.classes = {\n\t\t'': { color: '#000', label: '' },\n\t\t'class1': { color: '#770', label: '' },\n\t\t'class2': { color: '#707', label: '' },\n\t\t'class3': { color: '#777', label: '' },\n\t\t'class4': { color: '#070', label: '' },\n\t\t'class5': { color: '#007', label: '' },\n\t\t'class6': { color: '#077', label: '' },\n\t};\n\t\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\tlime.camera.maxFixedZoom = 4;\n\tui.actions.help.display = true;\n\tui.actions.help.html = \"Help text could be here.\";\n\tui.actions.snapshot.display = true;\n\n\n\teditor.createCallback = (annotation) => { console.log(\"Created annotation: \", annotation); return true; };\n\teditor.deleteCallback = (annotation) => { console.log(\"Deleted annotation: \", annotation); return true; };\n\teditor.updateCallback = (annotation) => { console.log(\"Updated annotation: \", annotation); return true; };\n\n\teditor.multiple = true;\n\t\n}\n\nfunction testMedicalAnnotations() {\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({\n\t\ttype: 'image',\n\t\turl: 'https://ome-digipath-demo.crs4.it/ome_seadragon/deepzoom/get/7.dzi',\n\t\tlayout: 'deepzoom1px',\n\t\tzindex: 0,\n\t});\n\n\tlet layer1 = new _LayerSvgAnnotation_js__WEBPACK_IMPORTED_MODULE_11__.LayerSvgAnnotation({ \n\t\tlayout: layer0.layout,\n\t\tstyle:` \n\t\t\t.openlime-annotation { pointer-events:all; opacity: 0.7; }\n\t\t\t.openlime-annotation:hover { cursor:pointer; opacity: 1.0; }\n\t\t\t\n\t\t\tpath { fill:none; stroke-width:1; stroke:#800; vector-effect:non-scaling-stroke; pointer-events:all; }\n\t\t\tpath:hover { cursor:pointer; stroke:#f00; }\n\n\t\t\trect { fill:rgba(255, 0, 0, 0.2); stroke:rgba(127, 0, 0, 0.7); vector-effect:non-scaling-stroke;}\n\t\t\tcircle { fill:rgba(255, 0, 0, 0.2); stroke:#800; stroke-width:1px; vector-effect:non-scaling-stroke; }\n\n\t\t\t.selected { fill:#ffaaaa; stroke:$ff0000 }\n\t\t`,\n\t\tinfoTemplate: (annotation) => { return `\n\t\t\t<h3>${annotation.class}</h3>\n\t\t\t<p>${annotation.description}</p>\n\t\t\t\n\t\t`; },\n\t\tannotations: 'assets/medical/PH1101-1.json',\n\t\teditable: true,\n\n\t}); \n\n\tlime.canvas.addLayer('img', layer0);\n\tlime.canvas.addLayer('anno', layer1);\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\tui.panzoom.zoomAmount = 2.0;\n}\n\n\t\nfunction testSVGAnnotations() {\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({\n\t\ttype: 'image',\n\t\turl: 'assets/svbrdf/vis/kdMap.jpg',\n\t\tlayout: 'image',\n\t\tzindex: 0,\n\t\ttransform: { x: 0, y: 0, z: 1.2, a: 0 },\n\t});\n\n\tlet layer1 = new _LayerAnnotation_js__WEBPACK_IMPORTED_MODULE_10__.LayerAnnotation({ \n\t\tlayout: layer0.layout,\n\t\tsvgURL: 'assets/svbrdf/vis/annotations.svg',\n\t\tstyle:` \n\t\t\t.openlime-annotation { pointer-events:all; opacity: 0.7; }\n\t\t\t.openlime-annotation:hover { cursor:pointer; opacity: 1.0; }\n\t\t`,\n\t\tannotations: { aura: {}, sun: {} },\n\t\ttransform: { x: 0, y: 0, z: 1.2, a: 0 },\n\t}); \n\n\tlime.canvas.addLayer('img', layer0);\n\tlime.canvas.addLayer('anno', layer1);\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\t// const { home, fullscreen, rotate } = ui.actions;\n\t// ui.actions = { home, fullscreen, rotate };\n\t// ui.actions.zoomin = { title: \"Zoom in\", task: (event) => { lime.camera.deltaZoom(1000, 2, 0, 0); } }; //actions can be modified just after ui creation (not later!)\n}\n\nfunction testUIBasic() {\n\ttomeTest();\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime, { skin: null });\n}\n\n\nfunction testUISvg() {\n\ttomeTest();\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n}\n\n\nfunction tomeTest() {\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({ \n\t\tlayout: 'deepzoom', \n\t\ttype:'rti',\n\t\turl: 'assets/rti/tome/info.json'\n\t});\n\tlime.canvas.addLayer('tome', layer0); \n\tlayer0.setLight([0.4, 0.4], 2000);\n\tsetTimeout(() => { \n\t\tlayer0.setLight([-1, 0], 2000); \n\t}, 2000); \n}\n\n\nfunction flipTest() {\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({ \n\t\tlayout: 'image', \n\t\ttype:'rti',\n\t\turl: 'assets/rti/bln/info.json'\n\t});\n\tlime.canvas.addLayer('bln', layer0); \n\n\tlet layer1 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({ \n\t\tlayout: 'image', \n\t\ttype:'rti',\n\t\turl: 'assets/rti/ptm/info.json'\n\t});\n\tlayer1.visible = false;\n\t//layer0.transform.x = -1000;\n\tlime.canvas.addLayer('ptm', layer1); \n\t\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\tui.actions.flip = { title: 'Flip', display: true,  task: (event) => { \n\t\tlayer0.setVisible(!layer0.visible);\n\t\tlayer1.setVisible(!layer1.visible);\n\t\tlime.redraw();\n\t}\n\t};\n\tui.actions.light.active = true;\n\tlime.camera.maxFixedZoom = 1;\n\t\n\t//ui.actions.light.display = true;\n\t//const { home, fullscreen, rotate } = ui.actions;\n\t//ui.actions = { home, fullscreen, rotate };\n\t\n//\tsetTimeout(() => { layer0.shader.setLight([0.4, 0.4, Math.sqrt(0.68)], ); lime.canvas.emit('update'); }, 2000);\n}\n\n\nfunction rtiTest(dataset) {\n\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({ \n\t\tlabel: '4',\n\t\tlayout: 'image', \n\t\ttype:'rti',\n\t\turl: 'assets/rti/hsh/info.json',\n\t\tnormals: false\n\t});\n\tlime.canvas.addLayer('coin', layer0);\n\n\t// let layer0 = new Layer({ \n\t// \tlayout: 'image', \n\t// \ttype:'rti',\n\t// \turl: 'assets/rti/hsh/info.json',\n\t// \tnormals: true\n\t// });\n\t// //layer0.transform.x = -200;\n\t// lime.canvas.addLayer('hsh', layer0); \n\n\n\t/*let layer1 = new Layer({ \n\t\tlayout: 'image', \n\t\ttype:'rti',\n\t\turl: 'assets/rti/ptm/info.json'\n\t});\n\tlayer1.transform.x = +200;\n\tlime.canvas.addLayer('ptm', layer1);  */\n\n\n\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\tlime.camera.maxFixedZoom = 4;\n\tui.menu[0].section = \"Prova\";\n\tui.menu.push({ html: \"<p>Prova</p>\" });\n\tui.scale = 0.002;\n\t//ui.actions.light.display = true;\n\t//const { home, fullscreen, rotate } = ui.actions;\n\t//ui.actions = { home, fullscreen, rotate };\n\t\n//\tsetTimeout(() => { layer0.shader.setLight([0.4, 0.4, Math.sqrt(0.68)], ); lime.canvas.emit('update'); }, 2000);\n}\n\n\n/* COMBINER TEST */\nfunction combinerTest() {\n\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({\n\t\ttype: 'image',\n\t\turl: './assets/lighthouse/image/lighthouse-kdmap.jpg',\n\t\tlayout: 'image',\n\t\tzindex: 0,\n\t\ttransform: { x: 100, y: 0, z: 1, a: 0 },\n\t\tvisible: false\n\t});\n\n\tlet layer1 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({\n\t\ttype: 'image',\n\t\turl: './assets/lighthouse/image/lighthouse-nomap.jpg',\n\t\tlayout: 'image',\n\t\tzindex: 0,\n\t\ttransform: { x: 0, y: 0, z: 1, a: 0 },\n\t\tvisible: false\n\t});\n\n\tlet combiner = new _LayerCombiner_js__WEBPACK_IMPORTED_MODULE_4__.LayerCombiner({\n\t\tlayers: [layer0, layer1]\n\t});\n\n\tlet shader = new _ShaderCombiner_js__WEBPACK_IMPORTED_MODULE_5__.ShaderCombiner();\n\tshader.mode = 'diff';\n\n\tcombiner.shaders = {'standard': shader };\n\tcombiner.setShader('standard'); \n\n\tlet panzoom = new _ControllerPanZoom_js__WEBPACK_IMPORTED_MODULE_6__.ControllerPanZoom(lime.camera, { priority: -1000 });\n\tlime.pointerManager.onEvent(panzoom); //register wheel, doubleclick, pan and pinch\n\n\tlime.canvas.addLayer('kdmap', layer0);\n\tlime.canvas.addLayer('ksmap', layer1);\n\tlime.canvas.addLayer('combiner', combiner);\n\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\tui.actions.snapshot.display = true;\n}\n\n/* COMBINER TEST */\nfunction lensTest() {\n\n\t// let layer0 = new Layer({\n\t// \ttype: 'brdf',\n\t// \tchannels: {\n\t// \t\t'kd': 'assets/nivola_mural_cropped_brdf/nivola_mural_cropped_kd.tzi',\n\t// \t\t'ks': 'assets/nivola_mural_cropped_brdf/nivola_mural_cropped_ks.tzi',\n\t// \t\t'normals': 'assets/nivola_mural_cropped_brdf/nivola_mural_cropped_n.tzi',\n\t// \t\t'gloss': 'assets/nivola_mural_cropped_brdf/nivola_mural_cropped_gm.tzi'\n\t// \t},\n\t// \tcolorspaces: {\n\t// \t\t'kd': 'linear',\n\t// \t\t'ks': 'linear'\n\t// \t},\n\t// \tlayout: 'tarzoom',\n\t\t\n\t// \ttransform: { x: 0, y: 0, z: 1, a: 0 },\n\t// });\n\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({\n\t\ttype: 'image',\n\t\turl: 'assets/svbrdf/vis/kdMap.jpg',\n\t\tlayout: 'image',\n\t\tzindex: 0,\n\t\ttransform: { x: 0, y: 0, z: 1, a: 0 },\n\t\tvisible: false\n\t});\n\n\tlet lensLayer = new _LayerLens_js__WEBPACK_IMPORTED_MODULE_8__.LayerLens({\n\t\tlayers: [layer0],\n\t\tcamera: lime.camera,\n\t\tradius:50,\n\t\tborder:10\n\t});\n\n\tlime.camera.bounded = false;\n\tconst controllerLens = new OpenLIME.ControllerLens({\n\t\tlensLayer: lensLayer,\n\t\tcamera: lime.camera,\n\t\thover: true,\n\t\tpriority: 0\n\t});\n\n\tlime.pointerManager.onEvent(controllerLens); \n\tlensLayer.controllers.push(controllerLens);\n\n\tlet cameraCtrl = new _ControllerPanZoom_js__WEBPACK_IMPORTED_MODULE_6__.ControllerPanZoom(lime.camera, { priority: -1000 });\n\tlime.camera.setPosition(1000,0,0,1,0);\n\tlime.pointerManager.onEvent(cameraCtrl); //register wheel, doubleclick, pan and pinch\n\tlime.camera.maxFixedZoom = 4;\n\n\tlime.canvas.addLayer('kdmap', layer0);\n\tlime.canvas.addLayer('lens', lensLayer);\n\t//let ui = new UIBasic(lime);\n\n}\n\n/* IMAGE TEST */\nfunction imageTest(layout) {\n\tif (!layout)\n\t\tlayout = 'deepzoom';\n\n//\tlet options = { layout: layout, type: 'image', transform: { x: -100, a: 45 } };\n\tlet options = { layout: layout, type: 'image'};\n\tconsole.log(\"OPTIONS: \", options);\n\tswitch (layout) {\n\t\tcase 'image':\n\t\t\toptions.url = 'assets/lime/image/lime.jpg';\n//\t\t\toptions.url = 'http://dev.isti.cnr.it/iipsrv/iipsrv.fcgi?IIIF=/home/ponchio/Sync/html/cenobium/sites/monreale/tif/N1ShNWNW.tif/2048,0,1952,2048/244.875,256/0/default.jpg';\n\t\t\tbreak;\n\n\t\t\tcase 'deepzoom1px':\n\t\t\t\toptions.url = 'assets/lime/deepzoom1px/lime.dzi';\n\t\t\tbreak;\t\n\t\t\tcase 'deepzoom':\n\t\t\t\t//options.url = 'https://ome-digipath-demo.crs4.it/ome_seadragon/deepzoom/get/7.dzi'; //'assets/svbrdf/vis/ksMap.dzi';\n\t\t\t\t//options.url = 'https://openseadragon.github.io/example-images/highsmith/highsmith.dzi'; //'assets/svbrdf/vis/ksMap.dzi';\n\t\t\tbreak;\n\n\t\t// case 'google':\n\t\t// \toptions.width = 3184;\n        //     options.height = 2024;\n        //     options.url = 'assets/lime/google/lime';\n\t\t// \tbreak;\n\n\t\tcase 'google':\n\t\t\tconst l=19;\n\t\t\toptions.width = Math.pow(2, l+8);\n\t\t\toptions.height = Math.pow(2, l+8);\n\t\t\toptions.mipmapBias = 0.4;\n\t\t\toptions.url= 'http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';\n\t\t\t//options.url = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\t\t\tbreak;\n\n\t\tcase 'zoomify':\n\t\t\toptions.url = 'assets/lime/zoomify/lime/ImageProperties.xml';\n\t\t\tbreak;\n\n\t\tcase 'iiif':\n\t\t\t//options.url = 'https://merovingio.c2rmf.cnrs.fr/fcgi-bin/iipsrv.fcgi?IIIF=PIA03883.pyr.tif/info.json';\n\t\t\t//options.url = 'https://merovingio.c2rmf.cnrs.fr/fcgi-bin/iipsrv.fcgi?IIIF=HD3/HD3_pyr_000_090.tif/info.json';\n\t\t\toptions.url = 'http://dev.isti.cnr.it/iipsrv/iipsrv.fcgi?IIIF=/home/ponchio/Sync/html/cenobium/sites/monreale/tif/N1ShNWNW.tif/info.json';\n\t\t\tbreak;\n\n\t\tcase 'tarzoom':\n\t\t\toptions.url = 'assets/lime/tarzoom/lime.tzi';\n\t\t\tbreak;\n\n\t\tcase 'itarzoom':\n\t\t\t//options.url = 'assets/rti/hsh/planes.tzi';\n\t\t\tbreak;\n\t\t\n\t}\n\tlet layer0 = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer(options);\n\tlime.canvas.addLayer('kdmap', layer0);\n\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\n\tsetTimeout(() => { \n\t\tconsole.log(layer0);\n\t\tlime.removeLayer('kdmap');\n\t}, 3000);\n\tsetTimeout(() => {\n\t\tconsole.log(layer0);\n\t\tlime.addLayer('kdmap', layer0);\n\t}, 6000);\n\n}\n\n\n/* BRDF TEST */\nfunction brdfTest() {\n\tlet brdf = new _Layer_js__WEBPACK_IMPORTED_MODULE_1__.Layer({\n\t\ttype: 'brdf',\n\t\tchannels: {\n\t\t\t'kd': 'assets/svbrdf/vis/kdMap.jpg',\n\t\t\t'ks': 'assets/svbrdf/vis/ksMap.jpg',\n\t\t\t'normals': 'assets/svbrdf/normalMap.jpg',\n\t\t\t'gloss': 'assets/svbrdf/vis/glossMap.jpg'\n\t\t},\n\t\tcolorspaces: {\n\t\t\t'kd': 'linear',\n\t\t\t'ks': 'linear'\n\t\t},\n\t\tlayout: 'image',\n\t});\n\n\tlime.canvas.addLayer('brdf', brdf);\n\tlet ui = new _UIBasic_js__WEBPACK_IMPORTED_MODULE_7__.UIBasic(lime);\n\n}\n\n\nlime.draw();\n\n//setTimeout(() => { lime.camera.fit([-150, -276, 150, 277], 200); }, 1000);\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRjtBQUNVO0FBQ007QUFDQTtBQUNFO0FBQ007QUFDcEI7QUFDSTtBQUNWO0FBQ3NCO0FBQ007QUFDRTs7QUFFOUQsZUFBZSw4Q0FBTSxnQkFBZ0IsK0JBQStCLDhCQUE4Qjs7QUFFbEc7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQiw0Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsY0FBYyxnREFBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDRDQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGtCQUFrQix1RUFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QyxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0EsWUFBWTtBQUNaLG9CQUFvQixXQUFXLGdCQUFnQixhQUFhLGtDQUFrQztBQUM5RiwwQkFBMEIsZ0JBQWdCOztBQUUxQyxVQUFVLDJCQUEyQiw2QkFBNkI7QUFDbEUsWUFBWSwyQkFBMkIsYUFBYSxrQkFBa0I7QUFDdEUsa0JBQWtCO0FBQ2xCLGVBQWUsY0FBYztBQUM3QjtBQUNBLGtDQUFrQztBQUNsQyxTQUFTLGlCQUFpQjtBQUMxQixRQUFRLHVCQUF1QjtBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLEVBQUU7QUFDRix1Q0FBdUM7QUFDdkMsQ0FBQyxpREFBVzs7QUFFWixrQkFBa0IseUVBQW1CLGlCQUFpQixZQUFZO0FBQ2xFO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBLGNBQWMsZ0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDJDQUEyQyxpREFBaUQ7QUFDNUYsMkNBQTJDLGlEQUFpRDtBQUM1RiwyQ0FBMkMsaURBQWlEOztBQUU1RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsNENBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGtCQUFrQix1RUFBa0I7QUFDcEM7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUMsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBLFVBQVUsV0FBVyxnQkFBZ0IsYUFBYSxrQ0FBa0M7QUFDcEYsZ0JBQWdCLGdCQUFnQjs7QUFFaEMsVUFBVSwyQkFBMkIsNkJBQTZCO0FBQ2xFLFlBQVksMkJBQTJCLGFBQWEsa0JBQWtCOztBQUV0RSxlQUFlLGNBQWM7QUFDN0I7QUFDQSxrQ0FBa0M7QUFDbEMsU0FBUyxpQkFBaUI7QUFDMUIsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxjQUFjLGdEQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLEVBQUU7O0FBRUYsa0JBQWtCLGlFQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUMsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBLGlCQUFpQixRQUFRLFdBQVc7QUFDcEMsZUFBZSwwQkFBMEI7QUFDekMsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsY0FBYyxnREFBTztBQUNyQixZQUFZLDJCQUEyQjtBQUN2QyxtQkFBbUI7QUFDbkIsMEJBQTBCLHFDQUFxQywyQ0FBMkM7QUFDMUc7O0FBRUE7QUFDQTtBQUNBLGNBQWMsZ0RBQU8sU0FBUyxZQUFZO0FBQzFDOzs7QUFHQTtBQUNBO0FBQ0EsY0FBYyxnREFBTztBQUNyQjs7O0FBR0E7QUFDQSxrQkFBa0IsNENBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsa0JBQWtCLDRDQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQU87QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQix1REFBdUQsNkJBQTZCO0FBQzFHOzs7QUFHQTs7QUFFQSxrQkFBa0IsNENBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsdUNBQXVDOzs7O0FBSXZDLGNBQWMsZ0RBQU87QUFDckI7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLGtCQUFrQjtBQUNsQjtBQUNBLHNCQUFzQix1REFBdUQsNkJBQTZCO0FBQzFHOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0EsRUFBRTs7QUFFRixrQkFBa0IsNENBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBLEVBQUU7O0FBRUYsb0JBQW9CLDREQUFhO0FBQ2pDO0FBQ0EsRUFBRTs7QUFFRixrQkFBa0IsOERBQWM7QUFDaEM7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBLG1CQUFtQixvRUFBaUIsZ0JBQWdCLGlCQUFpQjtBQUNyRSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdEQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUMsS0FBSzs7QUFFTCxrQkFBa0IsNENBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBLEVBQUU7O0FBRUYscUJBQXFCLG9EQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsc0JBQXNCLG9FQUFpQixnQkFBZ0IsaUJBQWlCO0FBQ3hFO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNENBQTRDO0FBQy9ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUYsOEZBQThGO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDN0csNkJBQTZCLEVBQUUseUJBQXlCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSztBQUN2Qjs7QUFFQSxjQUFjLGdEQUFPOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7O0FBR0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGNBQWMsZ0RBQU87O0FBRXJCOzs7QUFHQTs7QUFFQSxxQkFBcUIsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3BlbmxpbWUvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaWV3ZXIgfSBmcm9tICcuL1ZpZXdlci5qcydcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi9MYXllci5qcydcbmltcG9ydCB7IExheWVySW1hZ2UgfSBmcm9tICcuL0xheWVySW1hZ2UuanMnXG5pbXBvcnQgeyBMYXllckRzdHJldGNoIH0gZnJvbSAnLi9MYXllckRzdHJldGNoLmpzJ1xuaW1wb3J0IHsgTGF5ZXJDb21iaW5lciB9IGZyb20gJy4vTGF5ZXJDb21iaW5lci5qcydcbmltcG9ydCB7IFNoYWRlckNvbWJpbmVyIH0gZnJvbSAnLi9TaGFkZXJDb21iaW5lci5qcydcbmltcG9ydCB7IENvbnRyb2xsZXJQYW5ab29tIH0gZnJvbSAnLi9Db250cm9sbGVyUGFuWm9vbS5qcydcbmltcG9ydCB7IFVJQmFzaWMgfSBmcm9tICcuL1VJQmFzaWMuanMnXG5pbXBvcnQgeyBMYXllckxlbnMgfSBmcm9tICcuL0xheWVyTGVucy5qcydcbmltcG9ydCB7IFNraW4gfSBmcm9tICcuL1NraW4uanMnXG5pbXBvcnQgeyBMYXllckFubm90YXRpb24gfSBmcm9tICcuL0xheWVyQW5ub3RhdGlvbi5qcydcbmltcG9ydCB7IExheWVyU3ZnQW5ub3RhdGlvbiB9IGZyb20gJy4vTGF5ZXJTdmdBbm5vdGF0aW9uLmpzJ1xuaW1wb3J0IHsgRWRpdG9yU3ZnQW5ub3RhdGlvbiB9IGZyb20gJy4vRWRpdG9yU3ZnQW5ub3RhdGlvbi5qcydcblxubGV0IGxpbWUgPSBuZXcgVmlld2VyKCcub3BlbmxpbWUnLCB7IGJhY2tncm91bmQ6ICdibGFjaycsIGNhbnZhczogeyBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWV9IH0pO1xuXG5kc3RyZXRjaFRlc3QoKTtcbi8vY29tYmluZXJUZXN0KCk7XG4vL2ltYWdlVGVzdCgnZ29vZ2xlJyk7IC8vIGltYWdlIGdvb2dsZSBkZWVwem9vbSBkZWVwem9vbTFweCB6b29taWZ5IGlpaWYgdGFyem9vbiBpdGFyem9vbVxuLy9mbGlwVGVzdCgpO1xuLy9icmRmVGVzdCgpO1xuLy9ydGlUZXN0KCdyYmYnKTtcbi8vdG9tZVRlc3QoKTtcbi8vdGVzdFVJQmFzaWMoKTtcblxuLy90ZXN0VUlTdmcoKTtcbi8vbGVuc1Rlc3QoKTtcbi8vdGVzdFNWR0Fubm90YXRpb25zKCk7XG5cbi8vdGVzdE1lZGljYWxBbm5vdGF0aW9ucygpO1xuXG4vL3Rlc3RBbm5vdGF0aW9uRWRpdG9yKCk7XG5cbmZ1bmN0aW9uIGRzdHJldGNoVGVzdCgpIHtcblx0Y29uc29sZS5sb2coXCJEc3RyZXRjaGluZ1wiKTtcblxuXHRsZXQgZHN0cmV0Y2ggPSBuZXcgTGF5ZXIoe1xuXHRcdHR5cGU6ICdkc3RyZXRjaCcsXG5cdFx0bGF5b3V0OiAnaW1hZ2UnLFxuXHRcdHVybDogJ2Fzc2V0cy9kc3RyZXRjaC9jb2luL3BsYW5lXzAuanBnJ1xuXHR9KTtcblxuXHRsaW1lLmNhbnZhcy5hZGRMYXllcignZHN0cmV0Y2gnLCBkc3RyZXRjaCk7XG5cdGxldCB1aSA9IG5ldyBVSUJhc2ljKGxpbWUpO1xuXHR1aS5hY3Rpb25zLmxpZ2h0LmFjdGl2ZSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHRlc3RBbm5vdGF0aW9uRWRpdG9yKCkge1xuXHRsZXQgbGF5ZXIwID0gbmV3IExheWVyKHsgXG5cdFx0bGFiZWw6ICdDb2luIDEwJyxcblx0XHRsYXlvdXQ6ICdpbWFnZScsIFxuXHRcdHR5cGU6J3J0aScsXG5cdFx0dXJsOiAnYXNzZXRzL3J0aS9oc2gvaW5mby5qc29uJyxcblx0XHRub3JtYWxzOiBmYWxzZVxuXHR9KTtcblx0bGltZS5jYW52YXMuYWRkTGF5ZXIoJ2hzaCcsIGxheWVyMCk7XG5cdFxuXHRsZXQgbGF5ZXIxID0gbmV3IExheWVyU3ZnQW5ub3RhdGlvbih7IFxuXHRcdGxhYmVsOiAnQW5ub3RhdGlvbnMnLFxuXHRcdHZpZXdCb3g6IFwiMCAwIDI1NiAyNTZcIixcblx0XHRzdHlsZTpgIFxuXHRcdFx0Lm9wZW5saW1lLWFubm90YXRpb24geyBwb2ludGVyLWV2ZW50czphbGw7IG9wYWNpdHk6IDAuNzsgfVxuXHRcdFx0Lm9wZW5saW1lLWFubm90YXRpb246aG92ZXIgeyBjdXJzb3I6cG9pbnRlcjsgb3BhY2l0eTogMS4wOyB9XG5cdFx0XHRcblx0XHRcdDpmb2N1cyB7IGZpbGw6eWVsbG93OyB9XG5cdFx0XHRwb2x5bGluZSwgcGF0aCB7IGZpbGw6bm9uZTsgc3Ryb2tlLXdpZHRoOjE7IHN0cm9rZTojODAwOyB2ZWN0b3ItZWZmZWN0Om5vbi1zY2FsaW5nLXN0cm9rZTsgcG9pbnRlci1ldmVudHM6YWxsOyB9XG5cdFx0XHRwb2x5bGluZSwgcGF0aDpob3ZlciB7IGN1cnNvcjpwb2ludGVyOyBzdHJva2U6I2YwMDsgfVxuXG5cdFx0XHRyZWN0IHsgZmlsbDpyZ2JhKDI1NSwgMCwgMCwgMC4yKTsgc3Ryb2tlOnJnYmEoMTI3LCAwLCAwLCAwLjcpOyB2ZWN0b3ItZWZmZWN0Om5vbi1zY2FsaW5nLXN0cm9rZTt9XG5cdFx0XHRjaXJjbGUgeyBmaWxsOnJnYmEoMjU1LCAwLCAwLCAwLjIpOyBzdHJva2U6IzgwMDsgc3Ryb2tlLXdpZHRoOjFweDsgdmVjdG9yLWVmZmVjdDpub24tc2NhbGluZy1zdHJva2U7IH1cblx0XHRcdGNpcmNsZS5wb2ludCB7IHN0cm9rZS13aWR0aDoxMHB4IH1cblx0XHRcdC5zZWxlY3RlZCB7IGZpbGw6I2ZmYWFhYTsgc3Ryb2tlOiRmZjAwMDAgfVxuXHRcdGAsXG5cdFx0aW5mb1RlbXBsYXRlOiAoYW5ub3RhdGlvbikgPT4geyByZXR1cm4gYFxuXHRcdFx0PGgzPiR7YW5ub3RhdGlvbi5jbGFzc308L2gzPlxuXHRcdFx0PHA+JHthbm5vdGF0aW9uLmRlc2NyaXB0aW9ufTwvcD5cblx0XHRcdFxuXHRcdGA7IH0sXG5cdFx0YW5ub3RhdGlvbnM6ICdhc3NldHMvbWVkaWNhbC9QSDExMDEtMS5qc29uJyxcblx0XHRlZGl0YWJsZTogdHJ1ZSxcblxuXHR9KTsgXG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCdhbm5vJywgbGF5ZXIxKTsgLy9oZXJlIHRoZSBvdmVybGF5ZWxlbWVudCBjcmVhdGVkIGFuZCBhdHRhY2hlZCB0byBsYXllcjFcblx0U2tpbi5zZXRVcmwoJ3NraW4vc2tpbi5zdmcnKTtcblxuXHRsZXQgZWRpdG9yID0gbmV3IEVkaXRvclN2Z0Fubm90YXRpb24obGltZSwgbGF5ZXIxLCB7IGxpbWU6IGxpbWUgfSk7XG5cdGVkaXRvci5jbGFzc2VzID0ge1xuXHRcdCcnOiB7IGNvbG9yOiAnIzAwMCcsIGxhYmVsOiAnJyB9LFxuXHRcdCdjbGFzczEnOiB7IGNvbG9yOiAnIzc3MCcsIGxhYmVsOiAnJyB9LFxuXHRcdCdjbGFzczInOiB7IGNvbG9yOiAnIzcwNycsIGxhYmVsOiAnJyB9LFxuXHRcdCdjbGFzczMnOiB7IGNvbG9yOiAnIzc3NycsIGxhYmVsOiAnJyB9LFxuXHRcdCdjbGFzczQnOiB7IGNvbG9yOiAnIzA3MCcsIGxhYmVsOiAnJyB9LFxuXHRcdCdjbGFzczUnOiB7IGNvbG9yOiAnIzAwNycsIGxhYmVsOiAnJyB9LFxuXHRcdCdjbGFzczYnOiB7IGNvbG9yOiAnIzA3NycsIGxhYmVsOiAnJyB9LFxuXHR9O1xuXHRcblx0bGV0IHVpID0gbmV3IFVJQmFzaWMobGltZSk7XG5cdGxpbWUuY2FtZXJhLm1heEZpeGVkWm9vbSA9IDQ7XG5cdHVpLmFjdGlvbnMuaGVscC5kaXNwbGF5ID0gdHJ1ZTtcblx0dWkuYWN0aW9ucy5oZWxwLmh0bWwgPSBcIkhlbHAgdGV4dCBjb3VsZCBiZSBoZXJlLlwiO1xuXHR1aS5hY3Rpb25zLnNuYXBzaG90LmRpc3BsYXkgPSB0cnVlO1xuXG5cblx0ZWRpdG9yLmNyZWF0ZUNhbGxiYWNrID0gKGFubm90YXRpb24pID0+IHsgY29uc29sZS5sb2coXCJDcmVhdGVkIGFubm90YXRpb246IFwiLCBhbm5vdGF0aW9uKTsgcmV0dXJuIHRydWU7IH07XG5cdGVkaXRvci5kZWxldGVDYWxsYmFjayA9IChhbm5vdGF0aW9uKSA9PiB7IGNvbnNvbGUubG9nKFwiRGVsZXRlZCBhbm5vdGF0aW9uOiBcIiwgYW5ub3RhdGlvbik7IHJldHVybiB0cnVlOyB9O1xuXHRlZGl0b3IudXBkYXRlQ2FsbGJhY2sgPSAoYW5ub3RhdGlvbikgPT4geyBjb25zb2xlLmxvZyhcIlVwZGF0ZWQgYW5ub3RhdGlvbjogXCIsIGFubm90YXRpb24pOyByZXR1cm4gdHJ1ZTsgfTtcblxuXHRlZGl0b3IubXVsdGlwbGUgPSB0cnVlO1xuXHRcbn1cblxuZnVuY3Rpb24gdGVzdE1lZGljYWxBbm5vdGF0aW9ucygpIHtcblx0bGV0IGxheWVyMCA9IG5ldyBMYXllcih7XG5cdFx0dHlwZTogJ2ltYWdlJyxcblx0XHR1cmw6ICdodHRwczovL29tZS1kaWdpcGF0aC1kZW1vLmNyczQuaXQvb21lX3NlYWRyYWdvbi9kZWVwem9vbS9nZXQvNy5kemknLFxuXHRcdGxheW91dDogJ2RlZXB6b29tMXB4Jyxcblx0XHR6aW5kZXg6IDAsXG5cdH0pO1xuXG5cdGxldCBsYXllcjEgPSBuZXcgTGF5ZXJTdmdBbm5vdGF0aW9uKHsgXG5cdFx0bGF5b3V0OiBsYXllcjAubGF5b3V0LFxuXHRcdHN0eWxlOmAgXG5cdFx0XHQub3BlbmxpbWUtYW5ub3RhdGlvbiB7IHBvaW50ZXItZXZlbnRzOmFsbDsgb3BhY2l0eTogMC43OyB9XG5cdFx0XHQub3BlbmxpbWUtYW5ub3RhdGlvbjpob3ZlciB7IGN1cnNvcjpwb2ludGVyOyBvcGFjaXR5OiAxLjA7IH1cblx0XHRcdFxuXHRcdFx0cGF0aCB7IGZpbGw6bm9uZTsgc3Ryb2tlLXdpZHRoOjE7IHN0cm9rZTojODAwOyB2ZWN0b3ItZWZmZWN0Om5vbi1zY2FsaW5nLXN0cm9rZTsgcG9pbnRlci1ldmVudHM6YWxsOyB9XG5cdFx0XHRwYXRoOmhvdmVyIHsgY3Vyc29yOnBvaW50ZXI7IHN0cm9rZTojZjAwOyB9XG5cblx0XHRcdHJlY3QgeyBmaWxsOnJnYmEoMjU1LCAwLCAwLCAwLjIpOyBzdHJva2U6cmdiYSgxMjcsIDAsIDAsIDAuNyk7IHZlY3Rvci1lZmZlY3Q6bm9uLXNjYWxpbmctc3Ryb2tlO31cblx0XHRcdGNpcmNsZSB7IGZpbGw6cmdiYSgyNTUsIDAsIDAsIDAuMik7IHN0cm9rZTojODAwOyBzdHJva2Utd2lkdGg6MXB4OyB2ZWN0b3ItZWZmZWN0Om5vbi1zY2FsaW5nLXN0cm9rZTsgfVxuXG5cdFx0XHQuc2VsZWN0ZWQgeyBmaWxsOiNmZmFhYWE7IHN0cm9rZTokZmYwMDAwIH1cblx0XHRgLFxuXHRcdGluZm9UZW1wbGF0ZTogKGFubm90YXRpb24pID0+IHsgcmV0dXJuIGBcblx0XHRcdDxoMz4ke2Fubm90YXRpb24uY2xhc3N9PC9oMz5cblx0XHRcdDxwPiR7YW5ub3RhdGlvbi5kZXNjcmlwdGlvbn08L3A+XG5cdFx0XHRcblx0XHRgOyB9LFxuXHRcdGFubm90YXRpb25zOiAnYXNzZXRzL21lZGljYWwvUEgxMTAxLTEuanNvbicsXG5cdFx0ZWRpdGFibGU6IHRydWUsXG5cblx0fSk7IFxuXG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCdpbWcnLCBsYXllcjApO1xuXHRsaW1lLmNhbnZhcy5hZGRMYXllcignYW5ubycsIGxheWVyMSk7XG5cdGxldCB1aSA9IG5ldyBVSUJhc2ljKGxpbWUpO1xuXHR1aS5wYW56b29tLnpvb21BbW91bnQgPSAyLjA7XG59XG5cblx0XG5mdW5jdGlvbiB0ZXN0U1ZHQW5ub3RhdGlvbnMoKSB7XG5cdGxldCBsYXllcjAgPSBuZXcgTGF5ZXIoe1xuXHRcdHR5cGU6ICdpbWFnZScsXG5cdFx0dXJsOiAnYXNzZXRzL3N2YnJkZi92aXMva2RNYXAuanBnJyxcblx0XHRsYXlvdXQ6ICdpbWFnZScsXG5cdFx0emluZGV4OiAwLFxuXHRcdHRyYW5zZm9ybTogeyB4OiAwLCB5OiAwLCB6OiAxLjIsIGE6IDAgfSxcblx0fSk7XG5cblx0bGV0IGxheWVyMSA9IG5ldyBMYXllckFubm90YXRpb24oeyBcblx0XHRsYXlvdXQ6IGxheWVyMC5sYXlvdXQsXG5cdFx0c3ZnVVJMOiAnYXNzZXRzL3N2YnJkZi92aXMvYW5ub3RhdGlvbnMuc3ZnJyxcblx0XHRzdHlsZTpgIFxuXHRcdFx0Lm9wZW5saW1lLWFubm90YXRpb24geyBwb2ludGVyLWV2ZW50czphbGw7IG9wYWNpdHk6IDAuNzsgfVxuXHRcdFx0Lm9wZW5saW1lLWFubm90YXRpb246aG92ZXIgeyBjdXJzb3I6cG9pbnRlcjsgb3BhY2l0eTogMS4wOyB9XG5cdFx0YCxcblx0XHRhbm5vdGF0aW9uczogeyBhdXJhOiB7fSwgc3VuOiB7fSB9LFxuXHRcdHRyYW5zZm9ybTogeyB4OiAwLCB5OiAwLCB6OiAxLjIsIGE6IDAgfSxcblx0fSk7IFxuXG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCdpbWcnLCBsYXllcjApO1xuXHRsaW1lLmNhbnZhcy5hZGRMYXllcignYW5ubycsIGxheWVyMSk7XG5cdGxldCB1aSA9IG5ldyBVSUJhc2ljKGxpbWUpO1xuXHQvLyBjb25zdCB7IGhvbWUsIGZ1bGxzY3JlZW4sIHJvdGF0ZSB9ID0gdWkuYWN0aW9ucztcblx0Ly8gdWkuYWN0aW9ucyA9IHsgaG9tZSwgZnVsbHNjcmVlbiwgcm90YXRlIH07XG5cdC8vIHVpLmFjdGlvbnMuem9vbWluID0geyB0aXRsZTogXCJab29tIGluXCIsIHRhc2s6IChldmVudCkgPT4geyBsaW1lLmNhbWVyYS5kZWx0YVpvb20oMTAwMCwgMiwgMCwgMCk7IH0gfTsgLy9hY3Rpb25zIGNhbiBiZSBtb2RpZmllZCBqdXN0IGFmdGVyIHVpIGNyZWF0aW9uIChub3QgbGF0ZXIhKVxufVxuXG5mdW5jdGlvbiB0ZXN0VUlCYXNpYygpIHtcblx0dG9tZVRlc3QoKTtcblx0bGV0IHVpID0gbmV3IFVJQmFzaWMobGltZSwgeyBza2luOiBudWxsIH0pO1xufVxuXG5cbmZ1bmN0aW9uIHRlc3RVSVN2ZygpIHtcblx0dG9tZVRlc3QoKTtcblx0bGV0IHVpID0gbmV3IFVJQmFzaWMobGltZSk7XG59XG5cblxuZnVuY3Rpb24gdG9tZVRlc3QoKSB7XG5cdGxldCBsYXllcjAgPSBuZXcgTGF5ZXIoeyBcblx0XHRsYXlvdXQ6ICdkZWVwem9vbScsIFxuXHRcdHR5cGU6J3J0aScsXG5cdFx0dXJsOiAnYXNzZXRzL3J0aS90b21lL2luZm8uanNvbidcblx0fSk7XG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCd0b21lJywgbGF5ZXIwKTsgXG5cdGxheWVyMC5zZXRMaWdodChbMC40LCAwLjRdLCAyMDAwKTtcblx0c2V0VGltZW91dCgoKSA9PiB7IFxuXHRcdGxheWVyMC5zZXRMaWdodChbLTEsIDBdLCAyMDAwKTsgXG5cdH0sIDIwMDApOyBcbn1cblxuXG5mdW5jdGlvbiBmbGlwVGVzdCgpIHtcblx0bGV0IGxheWVyMCA9IG5ldyBMYXllcih7IFxuXHRcdGxheW91dDogJ2ltYWdlJywgXG5cdFx0dHlwZToncnRpJyxcblx0XHR1cmw6ICdhc3NldHMvcnRpL2Jsbi9pbmZvLmpzb24nXG5cdH0pO1xuXHRsaW1lLmNhbnZhcy5hZGRMYXllcignYmxuJywgbGF5ZXIwKTsgXG5cblx0bGV0IGxheWVyMSA9IG5ldyBMYXllcih7IFxuXHRcdGxheW91dDogJ2ltYWdlJywgXG5cdFx0dHlwZToncnRpJyxcblx0XHR1cmw6ICdhc3NldHMvcnRpL3B0bS9pbmZvLmpzb24nXG5cdH0pO1xuXHRsYXllcjEudmlzaWJsZSA9IGZhbHNlO1xuXHQvL2xheWVyMC50cmFuc2Zvcm0ueCA9IC0xMDAwO1xuXHRsaW1lLmNhbnZhcy5hZGRMYXllcigncHRtJywgbGF5ZXIxKTsgXG5cdFxuXHRsZXQgdWkgPSBuZXcgVUlCYXNpYyhsaW1lKTtcblx0dWkuYWN0aW9ucy5mbGlwID0geyB0aXRsZTogJ0ZsaXAnLCBkaXNwbGF5OiB0cnVlLCAgdGFzazogKGV2ZW50KSA9PiB7IFxuXHRcdGxheWVyMC5zZXRWaXNpYmxlKCFsYXllcjAudmlzaWJsZSk7XG5cdFx0bGF5ZXIxLnNldFZpc2libGUoIWxheWVyMS52aXNpYmxlKTtcblx0XHRsaW1lLnJlZHJhdygpO1xuXHR9XG5cdH07XG5cdHVpLmFjdGlvbnMubGlnaHQuYWN0aXZlID0gdHJ1ZTtcblx0bGltZS5jYW1lcmEubWF4Rml4ZWRab29tID0gMTtcblx0XG5cdC8vdWkuYWN0aW9ucy5saWdodC5kaXNwbGF5ID0gdHJ1ZTtcblx0Ly9jb25zdCB7IGhvbWUsIGZ1bGxzY3JlZW4sIHJvdGF0ZSB9ID0gdWkuYWN0aW9ucztcblx0Ly91aS5hY3Rpb25zID0geyBob21lLCBmdWxsc2NyZWVuLCByb3RhdGUgfTtcblx0XG4vL1x0c2V0VGltZW91dCgoKSA9PiB7IGxheWVyMC5zaGFkZXIuc2V0TGlnaHQoWzAuNCwgMC40LCBNYXRoLnNxcnQoMC42OCldLCApOyBsaW1lLmNhbnZhcy5lbWl0KCd1cGRhdGUnKTsgfSwgMjAwMCk7XG59XG5cblxuZnVuY3Rpb24gcnRpVGVzdChkYXRhc2V0KSB7XG5cblx0bGV0IGxheWVyMCA9IG5ldyBMYXllcih7IFxuXHRcdGxhYmVsOiAnNCcsXG5cdFx0bGF5b3V0OiAnaW1hZ2UnLCBcblx0XHR0eXBlOidydGknLFxuXHRcdHVybDogJ2Fzc2V0cy9ydGkvaHNoL2luZm8uanNvbicsXG5cdFx0bm9ybWFsczogZmFsc2Vcblx0fSk7XG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCdjb2luJywgbGF5ZXIwKTtcblxuXHQvLyBsZXQgbGF5ZXIwID0gbmV3IExheWVyKHsgXG5cdC8vIFx0bGF5b3V0OiAnaW1hZ2UnLCBcblx0Ly8gXHR0eXBlOidydGknLFxuXHQvLyBcdHVybDogJ2Fzc2V0cy9ydGkvaHNoL2luZm8uanNvbicsXG5cdC8vIFx0bm9ybWFsczogdHJ1ZVxuXHQvLyB9KTtcblx0Ly8gLy9sYXllcjAudHJhbnNmb3JtLnggPSAtMjAwO1xuXHQvLyBsaW1lLmNhbnZhcy5hZGRMYXllcignaHNoJywgbGF5ZXIwKTsgXG5cblxuXHQvKmxldCBsYXllcjEgPSBuZXcgTGF5ZXIoeyBcblx0XHRsYXlvdXQ6ICdpbWFnZScsIFxuXHRcdHR5cGU6J3J0aScsXG5cdFx0dXJsOiAnYXNzZXRzL3J0aS9wdG0vaW5mby5qc29uJ1xuXHR9KTtcblx0bGF5ZXIxLnRyYW5zZm9ybS54ID0gKzIwMDtcblx0bGltZS5jYW52YXMuYWRkTGF5ZXIoJ3B0bScsIGxheWVyMSk7ICAqL1xuXG5cblxuXHRsZXQgdWkgPSBuZXcgVUlCYXNpYyhsaW1lKTtcblx0bGltZS5jYW1lcmEubWF4Rml4ZWRab29tID0gNDtcblx0dWkubWVudVswXS5zZWN0aW9uID0gXCJQcm92YVwiO1xuXHR1aS5tZW51LnB1c2goeyBodG1sOiBcIjxwPlByb3ZhPC9wPlwiIH0pO1xuXHR1aS5zY2FsZSA9IDAuMDAyO1xuXHQvL3VpLmFjdGlvbnMubGlnaHQuZGlzcGxheSA9IHRydWU7XG5cdC8vY29uc3QgeyBob21lLCBmdWxsc2NyZWVuLCByb3RhdGUgfSA9IHVpLmFjdGlvbnM7XG5cdC8vdWkuYWN0aW9ucyA9IHsgaG9tZSwgZnVsbHNjcmVlbiwgcm90YXRlIH07XG5cdFxuLy9cdHNldFRpbWVvdXQoKCkgPT4geyBsYXllcjAuc2hhZGVyLnNldExpZ2h0KFswLjQsIDAuNCwgTWF0aC5zcXJ0KDAuNjgpXSwgKTsgbGltZS5jYW52YXMuZW1pdCgndXBkYXRlJyk7IH0sIDIwMDApO1xufVxuXG5cbi8qIENPTUJJTkVSIFRFU1QgKi9cbmZ1bmN0aW9uIGNvbWJpbmVyVGVzdCgpIHtcblxuXHRsZXQgbGF5ZXIwID0gbmV3IExheWVyKHtcblx0XHR0eXBlOiAnaW1hZ2UnLFxuXHRcdHVybDogJy4vYXNzZXRzL2xpZ2h0aG91c2UvaW1hZ2UvbGlnaHRob3VzZS1rZG1hcC5qcGcnLFxuXHRcdGxheW91dDogJ2ltYWdlJyxcblx0XHR6aW5kZXg6IDAsXG5cdFx0dHJhbnNmb3JtOiB7IHg6IDEwMCwgeTogMCwgejogMSwgYTogMCB9LFxuXHRcdHZpc2libGU6IGZhbHNlXG5cdH0pO1xuXG5cdGxldCBsYXllcjEgPSBuZXcgTGF5ZXIoe1xuXHRcdHR5cGU6ICdpbWFnZScsXG5cdFx0dXJsOiAnLi9hc3NldHMvbGlnaHRob3VzZS9pbWFnZS9saWdodGhvdXNlLW5vbWFwLmpwZycsXG5cdFx0bGF5b3V0OiAnaW1hZ2UnLFxuXHRcdHppbmRleDogMCxcblx0XHR0cmFuc2Zvcm06IHsgeDogMCwgeTogMCwgejogMSwgYTogMCB9LFxuXHRcdHZpc2libGU6IGZhbHNlXG5cdH0pO1xuXG5cdGxldCBjb21iaW5lciA9IG5ldyBMYXllckNvbWJpbmVyKHtcblx0XHRsYXllcnM6IFtsYXllcjAsIGxheWVyMV1cblx0fSk7XG5cblx0bGV0IHNoYWRlciA9IG5ldyBTaGFkZXJDb21iaW5lcigpO1xuXHRzaGFkZXIubW9kZSA9ICdkaWZmJztcblxuXHRjb21iaW5lci5zaGFkZXJzID0geydzdGFuZGFyZCc6IHNoYWRlciB9O1xuXHRjb21iaW5lci5zZXRTaGFkZXIoJ3N0YW5kYXJkJyk7IFxuXG5cdGxldCBwYW56b29tID0gbmV3IENvbnRyb2xsZXJQYW5ab29tKGxpbWUuY2FtZXJhLCB7IHByaW9yaXR5OiAtMTAwMCB9KTtcblx0bGltZS5wb2ludGVyTWFuYWdlci5vbkV2ZW50KHBhbnpvb20pOyAvL3JlZ2lzdGVyIHdoZWVsLCBkb3VibGVjbGljaywgcGFuIGFuZCBwaW5jaFxuXG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCdrZG1hcCcsIGxheWVyMCk7XG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCdrc21hcCcsIGxheWVyMSk7XG5cdGxpbWUuY2FudmFzLmFkZExheWVyKCdjb21iaW5lcicsIGNvbWJpbmVyKTtcblxuXHRsZXQgdWkgPSBuZXcgVUlCYXNpYyhsaW1lKTtcblx0dWkuYWN0aW9ucy5zbmFwc2hvdC5kaXNwbGF5ID0gdHJ1ZTtcbn1cblxuLyogQ09NQklORVIgVEVTVCAqL1xuZnVuY3Rpb24gbGVuc1Rlc3QoKSB7XG5cblx0Ly8gbGV0IGxheWVyMCA9IG5ldyBMYXllcih7XG5cdC8vIFx0dHlwZTogJ2JyZGYnLFxuXHQvLyBcdGNoYW5uZWxzOiB7XG5cdC8vIFx0XHQna2QnOiAnYXNzZXRzL25pdm9sYV9tdXJhbF9jcm9wcGVkX2JyZGYvbml2b2xhX211cmFsX2Nyb3BwZWRfa2QudHppJyxcblx0Ly8gXHRcdCdrcyc6ICdhc3NldHMvbml2b2xhX211cmFsX2Nyb3BwZWRfYnJkZi9uaXZvbGFfbXVyYWxfY3JvcHBlZF9rcy50emknLFxuXHQvLyBcdFx0J25vcm1hbHMnOiAnYXNzZXRzL25pdm9sYV9tdXJhbF9jcm9wcGVkX2JyZGYvbml2b2xhX211cmFsX2Nyb3BwZWRfbi50emknLFxuXHQvLyBcdFx0J2dsb3NzJzogJ2Fzc2V0cy9uaXZvbGFfbXVyYWxfY3JvcHBlZF9icmRmL25pdm9sYV9tdXJhbF9jcm9wcGVkX2dtLnR6aSdcblx0Ly8gXHR9LFxuXHQvLyBcdGNvbG9yc3BhY2VzOiB7XG5cdC8vIFx0XHQna2QnOiAnbGluZWFyJyxcblx0Ly8gXHRcdCdrcyc6ICdsaW5lYXInXG5cdC8vIFx0fSxcblx0Ly8gXHRsYXlvdXQ6ICd0YXJ6b29tJyxcblx0XHRcblx0Ly8gXHR0cmFuc2Zvcm06IHsgeDogMCwgeTogMCwgejogMSwgYTogMCB9LFxuXHQvLyB9KTtcblxuXHRsZXQgbGF5ZXIwID0gbmV3IExheWVyKHtcblx0XHR0eXBlOiAnaW1hZ2UnLFxuXHRcdHVybDogJ2Fzc2V0cy9zdmJyZGYvdmlzL2tkTWFwLmpwZycsXG5cdFx0bGF5b3V0OiAnaW1hZ2UnLFxuXHRcdHppbmRleDogMCxcblx0XHR0cmFuc2Zvcm06IHsgeDogMCwgeTogMCwgejogMSwgYTogMCB9LFxuXHRcdHZpc2libGU6IGZhbHNlXG5cdH0pO1xuXG5cdGxldCBsZW5zTGF5ZXIgPSBuZXcgTGF5ZXJMZW5zKHtcblx0XHRsYXllcnM6IFtsYXllcjBdLFxuXHRcdGNhbWVyYTogbGltZS5jYW1lcmEsXG5cdFx0cmFkaXVzOjUwLFxuXHRcdGJvcmRlcjoxMFxuXHR9KTtcblxuXHRsaW1lLmNhbWVyYS5ib3VuZGVkID0gZmFsc2U7XG5cdGNvbnN0IGNvbnRyb2xsZXJMZW5zID0gbmV3IE9wZW5MSU1FLkNvbnRyb2xsZXJMZW5zKHtcblx0XHRsZW5zTGF5ZXI6IGxlbnNMYXllcixcblx0XHRjYW1lcmE6IGxpbWUuY2FtZXJhLFxuXHRcdGhvdmVyOiB0cnVlLFxuXHRcdHByaW9yaXR5OiAwXG5cdH0pO1xuXG5cdGxpbWUucG9pbnRlck1hbmFnZXIub25FdmVudChjb250cm9sbGVyTGVucyk7IFxuXHRsZW5zTGF5ZXIuY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyTGVucyk7XG5cblx0bGV0IGNhbWVyYUN0cmwgPSBuZXcgQ29udHJvbGxlclBhblpvb20obGltZS5jYW1lcmEsIHsgcHJpb3JpdHk6IC0xMDAwIH0pO1xuXHRsaW1lLmNhbWVyYS5zZXRQb3NpdGlvbigxMDAwLDAsMCwxLDApO1xuXHRsaW1lLnBvaW50ZXJNYW5hZ2VyLm9uRXZlbnQoY2FtZXJhQ3RybCk7IC8vcmVnaXN0ZXIgd2hlZWwsIGRvdWJsZWNsaWNrLCBwYW4gYW5kIHBpbmNoXG5cdGxpbWUuY2FtZXJhLm1heEZpeGVkWm9vbSA9IDQ7XG5cblx0bGltZS5jYW52YXMuYWRkTGF5ZXIoJ2tkbWFwJywgbGF5ZXIwKTtcblx0bGltZS5jYW52YXMuYWRkTGF5ZXIoJ2xlbnMnLCBsZW5zTGF5ZXIpO1xuXHQvL2xldCB1aSA9IG5ldyBVSUJhc2ljKGxpbWUpO1xuXG59XG5cbi8qIElNQUdFIFRFU1QgKi9cbmZ1bmN0aW9uIGltYWdlVGVzdChsYXlvdXQpIHtcblx0aWYgKCFsYXlvdXQpXG5cdFx0bGF5b3V0ID0gJ2RlZXB6b29tJztcblxuLy9cdGxldCBvcHRpb25zID0geyBsYXlvdXQ6IGxheW91dCwgdHlwZTogJ2ltYWdlJywgdHJhbnNmb3JtOiB7IHg6IC0xMDAsIGE6IDQ1IH0gfTtcblx0bGV0IG9wdGlvbnMgPSB7IGxheW91dDogbGF5b3V0LCB0eXBlOiAnaW1hZ2UnfTtcblx0Y29uc29sZS5sb2coXCJPUFRJT05TOiBcIiwgb3B0aW9ucyk7XG5cdHN3aXRjaCAobGF5b3V0KSB7XG5cdFx0Y2FzZSAnaW1hZ2UnOlxuXHRcdFx0b3B0aW9ucy51cmwgPSAnYXNzZXRzL2xpbWUvaW1hZ2UvbGltZS5qcGcnO1xuLy9cdFx0XHRvcHRpb25zLnVybCA9ICdodHRwOi8vZGV2LmlzdGkuY25yLml0L2lpcHNydi9paXBzcnYuZmNnaT9JSUlGPS9ob21lL3BvbmNoaW8vU3luYy9odG1sL2Nlbm9iaXVtL3NpdGVzL21vbnJlYWxlL3RpZi9OMVNoTldOVy50aWYvMjA0OCwwLDE5NTIsMjA0OC8yNDQuODc1LDI1Ni8wL2RlZmF1bHQuanBnJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdkZWVwem9vbTFweCc6XG5cdFx0XHRcdG9wdGlvbnMudXJsID0gJ2Fzc2V0cy9saW1lL2RlZXB6b29tMXB4L2xpbWUuZHppJztcblx0XHRcdGJyZWFrO1x0XG5cdFx0XHRjYXNlICdkZWVwem9vbSc6XG5cdFx0XHRcdC8vb3B0aW9ucy51cmwgPSAnaHR0cHM6Ly9vbWUtZGlnaXBhdGgtZGVtby5jcnM0Lml0L29tZV9zZWFkcmFnb24vZGVlcHpvb20vZ2V0LzcuZHppJzsgLy8nYXNzZXRzL3N2YnJkZi92aXMva3NNYXAuZHppJztcblx0XHRcdFx0Ly9vcHRpb25zLnVybCA9ICdodHRwczovL29wZW5zZWFkcmFnb24uZ2l0aHViLmlvL2V4YW1wbGUtaW1hZ2VzL2hpZ2hzbWl0aC9oaWdoc21pdGguZHppJzsgLy8nYXNzZXRzL3N2YnJkZi92aXMva3NNYXAuZHppJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Ly8gY2FzZSAnZ29vZ2xlJzpcblx0XHQvLyBcdG9wdGlvbnMud2lkdGggPSAzMTg0O1xuICAgICAgICAvLyAgICAgb3B0aW9ucy5oZWlnaHQgPSAyMDI0O1xuICAgICAgICAvLyAgICAgb3B0aW9ucy51cmwgPSAnYXNzZXRzL2xpbWUvZ29vZ2xlL2xpbWUnO1xuXHRcdC8vIFx0YnJlYWs7XG5cblx0XHRjYXNlICdnb29nbGUnOlxuXHRcdFx0Y29uc3QgbD0xOTtcblx0XHRcdG9wdGlvbnMud2lkdGggPSBNYXRoLnBvdygyLCBsKzgpO1xuXHRcdFx0b3B0aW9ucy5oZWlnaHQgPSBNYXRoLnBvdygyLCBsKzgpO1xuXHRcdFx0b3B0aW9ucy5taXBtYXBCaWFzID0gMC40O1xuXHRcdFx0b3B0aW9ucy51cmw9ICdodHRwOi8vc2VydmVyLmFyY2dpc29ubGluZS5jb20vQXJjR0lTL3Jlc3Qvc2VydmljZXMvV29ybGRfSW1hZ2VyeS9NYXBTZXJ2ZXIvdGlsZS97en0ve3l9L3t4fSc7XG5cdFx0XHQvL29wdGlvbnMudXJsID0gJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnem9vbWlmeSc6XG5cdFx0XHRvcHRpb25zLnVybCA9ICdhc3NldHMvbGltZS96b29taWZ5L2xpbWUvSW1hZ2VQcm9wZXJ0aWVzLnhtbCc7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2lpaWYnOlxuXHRcdFx0Ly9vcHRpb25zLnVybCA9ICdodHRwczovL21lcm92aW5naW8uYzJybWYuY25ycy5mci9mY2dpLWJpbi9paXBzcnYuZmNnaT9JSUlGPVBJQTAzODgzLnB5ci50aWYvaW5mby5qc29uJztcblx0XHRcdC8vb3B0aW9ucy51cmwgPSAnaHR0cHM6Ly9tZXJvdmluZ2lvLmMycm1mLmNucnMuZnIvZmNnaS1iaW4vaWlwc3J2LmZjZ2k/SUlJRj1IRDMvSEQzX3B5cl8wMDBfMDkwLnRpZi9pbmZvLmpzb24nO1xuXHRcdFx0b3B0aW9ucy51cmwgPSAnaHR0cDovL2Rldi5pc3RpLmNuci5pdC9paXBzcnYvaWlwc3J2LmZjZ2k/SUlJRj0vaG9tZS9wb25jaGlvL1N5bmMvaHRtbC9jZW5vYml1bS9zaXRlcy9tb25yZWFsZS90aWYvTjFTaE5XTlcudGlmL2luZm8uanNvbic7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ3Rhcnpvb20nOlxuXHRcdFx0b3B0aW9ucy51cmwgPSAnYXNzZXRzL2xpbWUvdGFyem9vbS9saW1lLnR6aSc7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2l0YXJ6b29tJzpcblx0XHRcdC8vb3B0aW9ucy51cmwgPSAnYXNzZXRzL3J0aS9oc2gvcGxhbmVzLnR6aSc7XG5cdFx0XHRicmVhaztcblx0XHRcblx0fVxuXHRsZXQgbGF5ZXIwID0gbmV3IExheWVyKG9wdGlvbnMpO1xuXHRsaW1lLmNhbnZhcy5hZGRMYXllcigna2RtYXAnLCBsYXllcjApO1xuXG5cdGxldCB1aSA9IG5ldyBVSUJhc2ljKGxpbWUpO1xuXG5cdHNldFRpbWVvdXQoKCkgPT4geyBcblx0XHRjb25zb2xlLmxvZyhsYXllcjApO1xuXHRcdGxpbWUucmVtb3ZlTGF5ZXIoJ2tkbWFwJyk7XG5cdH0sIDMwMDApO1xuXHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRjb25zb2xlLmxvZyhsYXllcjApO1xuXHRcdGxpbWUuYWRkTGF5ZXIoJ2tkbWFwJywgbGF5ZXIwKTtcblx0fSwgNjAwMCk7XG5cbn1cblxuXG4vKiBCUkRGIFRFU1QgKi9cbmZ1bmN0aW9uIGJyZGZUZXN0KCkge1xuXHRsZXQgYnJkZiA9IG5ldyBMYXllcih7XG5cdFx0dHlwZTogJ2JyZGYnLFxuXHRcdGNoYW5uZWxzOiB7XG5cdFx0XHQna2QnOiAnYXNzZXRzL3N2YnJkZi92aXMva2RNYXAuanBnJyxcblx0XHRcdCdrcyc6ICdhc3NldHMvc3ZicmRmL3Zpcy9rc01hcC5qcGcnLFxuXHRcdFx0J25vcm1hbHMnOiAnYXNzZXRzL3N2YnJkZi9ub3JtYWxNYXAuanBnJyxcblx0XHRcdCdnbG9zcyc6ICdhc3NldHMvc3ZicmRmL3Zpcy9nbG9zc01hcC5qcGcnXG5cdFx0fSxcblx0XHRjb2xvcnNwYWNlczoge1xuXHRcdFx0J2tkJzogJ2xpbmVhcicsXG5cdFx0XHQna3MnOiAnbGluZWFyJ1xuXHRcdH0sXG5cdFx0bGF5b3V0OiAnaW1hZ2UnLFxuXHR9KTtcblxuXHRsaW1lLmNhbnZhcy5hZGRMYXllcignYnJkZicsIGJyZGYpO1xuXHRsZXQgdWkgPSBuZXcgVUlCYXNpYyhsaW1lKTtcblxufVxuXG5cbmxpbWUuZHJhdygpO1xuXG4vL3NldFRpbWVvdXQoKCkgPT4geyBsaW1lLmNhbWVyYS5maXQoWy0xNTAsIC0yNzYsIDE1MCwgMjc3XSwgMjAwKTsgfSwgMTAwMCk7XG5cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;